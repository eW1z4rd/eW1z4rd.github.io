

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/global/favicon.ico">
  <link rel="icon" href="/img/global/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="eW1z4rd">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文作为透视 HTTP 协议的进阶篇，介绍了 HTTP 中的实体结构、大文件传输、连接管理、Cookie 机制、代理服务、缓存控制的实现原理和细节。">
<meta property="og:type" content="article">
<meta property="og:title" content="透视 HTTP 协议（二）">
<meta property="og:url" content="https://ew1z4rd.github.io/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="栖丘">
<meta property="og:description" content="本文作为透视 HTTP 协议的进阶篇，介绍了 HTTP 中的实体结构、大文件传输、连接管理、Cookie 机制、代理服务、缓存控制的实现原理和细节。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5191bce1329efa157a6cc37ab9e789b9.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/0e9bcd6922fa8908bdba79d98ae5fa10.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b2118315a977969ddfcc7ab9d26cb358.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/25e7b09cf8cb4eaebba42b4598192410.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/fffa3a65e367c496428f3c0c4dac8a37.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/54315ed9ac37fbc6547258040f00a80c.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/57b3d80234a1f1b8c538a376aa01d3b4.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/6a6d30a89fb085d5f1773a887aaf5572.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/9f6cca61802d65d063e24aa9ca7c38a4.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/28237ef93ce0ddca076d2dc19c16fdf9.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/52a3bd760584972011f6be1a5258e2d7.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/a1968821f214df4a3ae16c9b30f99a5b.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b239d0804be630ce182e24ea9e4ab237.png">
<meta property="og:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5e8d10b5758685850aeed2a473a6cdc2.png">
<meta property="article:published_time" content="2021-10-24T01:34:53.000Z">
<meta property="article:modified_time" content="2022-02-07T13:43:32.361Z">
<meta property="article:author" content="eW1z4rd">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="Cookie">
<meta property="article:tag" content="Proxy">
<meta property="article:tag" content="Cache">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ew1z4rd.github.io/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5191bce1329efa157a6cc37ab9e789b9.png">
  
  
  <title>透视 HTTP 协议（二） - 栖丘</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ew1z4rd.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":"f307ed711fcf86fe5ceb149239b6cfc3","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>eW1z4rd&#39;s space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/global/post-bg.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="透视 HTTP 协议（二）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-24 09:34" pubdate>
        2021年10月24日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">透视 HTTP 协议（二）</h1>
            
            <div class="markdown-body">
              <h2 id="实体结构"><a href="#实体结构" class="headerlink" title="实体结构"></a>实体结构</h2><p>一个 HTTP 报文是由 header+body 组成的，本章主要研究 HTTP 的实体结构，也就是 body 部分。</p>
<h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><p><strong>MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）</strong>也被称为 <strong>MIME 类型</strong>，是一个很大的标准规范，最早应用于电子邮件系统，用于描述多媒体数据的类型。HTTP 协议只取了其中的一部分，用来标记 body 的数据类型。</p>
<blockquote>
<p>MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 <code>/</code> 分隔而成，通用形式是 <code>type/subtype</code>。</p>
<p>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理 URL，因此 Web 服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p>
</blockquote>
<p>在 HTTP 中常见的 MIME 类型有：</p>
<ol>
<li>text：文本格式的可读数据<ul>
<li>text/plain：纯文本文件，文本文件默认值。</li>
<li>text/html：超文本文件，最常见的文本类型之一。</li>
<li>text/css：样式表文件。</li>
<li>text/javascript：JavaScript 文件。</li>
</ul>
</li>
<li>image：图像数据<ul>
<li>image/gif：GIF 图片（支持动态图）。</li>
<li>image/jpeg：JPEG 图片（最常用的压缩图片）。</li>
<li>image/png：PNG 图片（无损压缩图片）。</li>
<li>image/svg+xml： SVG 图片（矢量图）。</li>
</ul>
</li>
<li>audio/video：音频和视频数据<ul>
<li>audio/mpeg：mpeg 音频文件。</li>
<li>video/mp4：mp4 视频文件。</li>
</ul>
</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释<ul>
<li>application/json：json 数据格式。</li>
<li>application/xml：xml 数据格式。</li>
<li>application/x-www-form-urlencoded：表单的标准编码格式。</li>
<li>application/pdf：pdf 格式。</li>
<li>application/octet-stream：二进制数据流，表示未知的应用程序文件，浏览器一般不会自动执行或询问执行。</li>
</ul>
</li>
</ol>
<p>但仅有 MIME 类型还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，因此还需要有一个 <strong>编码类型</strong>，说明数据使用的是什么编码格式。常用编码类型有以下三种：</p>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式。</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip。</li>
<li>br：Brotli 压缩算法，专门为 HTTP 设计，压缩效率和性能更好。</li>
</ol>
<p><strong>数据类型使用的头字段</strong></p>
<p>有了 MIME 类型和编码类型，无论是浏览器还是服务器就都可以轻松识别出 body 的数据类型，也就能够正确处理数据了。</p>
<p>HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 响应头字段，用于客户端和服务器进行 <strong>内容协商</strong>。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5191bce1329efa157a6cc37ab9e789b9.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><p>MIME 类型和编码类型解决了计算机理解 body 数据的问题，但互联网遍布全球，不同国家不同地区的人使用了很多不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可理解可阅读的语言文字呢？</p>
<p>这实际上就是 <strong>国际化</strong> 的问题。HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：<strong>语言类型与字符集</strong>。</p>
<p>所谓语言类型就是人类使用的自然语言，例如汉语、英语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用 <code>type-subtype</code> 的形式。比如 <code>en</code> 表示任意英语，<code>en-US</code> 表示美式英语，<code>en-GB</code> 表示英式英语，而 <code>zh-CN</code> 就表示我们最常使用的汉语。</p>
<p>而字符集是由于在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理自己的文字，比如英语世界用的 ASCII、汉语世界用的 GBK、日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。所以后来就出现了 <strong>Unicode 字符集</strong> 和 <strong>UTF-8 编码方式</strong>，把世界上所有的语言都容纳在一种编码方案里，UTF-8 也成为了互联网上的标准字符编码。</p>
<p><strong>语言类型使用的头字段</strong></p>
<p>同样的，HTTP 协议也使用了 Accept 请求头字段和 Content 响应头字段，用于客户端和服务器就语言与编码进行内容协商。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/0e9bcd6922fa8908bdba79d98ae5fa10.png" srcset="/img/loading.gif" lazyload></p>
<p>需要注意的是，字符集在 HTTP 里使用的请求头字段是 <strong>Accept-Charset</strong>，但响应头里却没有对应的 Content-Charset，而是在 <strong>Content-Type</strong> 字段的数据类型后面用 <code>charset=xxx</code> 来表示。</p>
<p>而且由于现在的浏览器都支持多种字符集，因此通常不会发送 Accept-Charset。同时服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来。所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</p>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p><strong>内容协商的质量值</strong></p>
<p>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的 <code>q</code> 参数表示权重来设定优先级，这里的 q 是 quality factor 的意思。</p>
<p>权重的最大值是 1，最小值是 0.01，<strong>默认值是 1</strong>，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个 <code>;</code> 后面 <code>q=value</code>。例如下面的 Accept 字段，表示浏览器最希望使用的是 HTML 文件，权重是 1；其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: text/html,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p><strong>内容协商的结果</strong></p>
<p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 <strong>Vary</strong> 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Vary: <span class="hljs-keyword">Accept</span>-Encoding,User-Agent,<span class="hljs-keyword">Accept</span><br></code></pre></td></tr></table></figure>

<p>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</p>
<p>Vary 字段可以认为是响应报文的一个特殊的 <strong>版本标记</strong>，每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的版本，主要用于在传输链路中间的代理服务器上实现缓存服务。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b2118315a977969ddfcc7ab9d26cb358.png" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th align="left">请求头字段</th>
<th align="left">说明</th>
<th align="left">响应头字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">客户端支持的 MIME 类型</td>
<td align="left">Content-Type</td>
<td>服务器选择的 MIME 类型</td>
</tr>
<tr>
<td align="left">Accept-Charset ❌</td>
<td align="left">客户端支持的字符集类型</td>
<td align="left"><strong>Content-Type</strong></td>
<td>服务器选择的字符集类型</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">客户端支持的编码类型</td>
<td align="left">Content-Encoding</td>
<td>服务器选择的编码类型</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">客户端支持的自然语言类型</td>
<td align="left">Content-Language ❌</td>
<td>服务器选择的自然语言类型</td>
</tr>
</tbody></table>
<p>注：<strong>Content-</strong>* 字段也可以用在请求报文里，说明请求体的数据类型。比如使用 POST 方法向服务器提交 JSON 格式的数据，里面包含有中文，请求头应该形如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/service/v1/user/auth</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Content-type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Content-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh<br></code></pre></td></tr></table></figure>

<h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p>早期互联网上传输的基本上都是只有几 K 大小的文本和小图片，现在的情况则大有不同。网页里包含的信息实在是太多了，随随便便一个主页 HTML 就有可能上百 K，高质量的图片都以 M 论，更不要说那些电影、电视剧了，几 G、几十 G 都有可能。</p>
<p>相比之下，100M 的光纤固网或者 4G 移动网络在这些大文件的压力下都变成了“小水管”，无论是上传还是下载，都会把网络传输链路挤的“满满当当”。所以，如何在有限的带宽下高效快捷地传输这些大文件就成了一个重要的课题。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>压缩 HTML 等文本文件是传输大文件 <strong>最基本的方法</strong>。通常浏览器在发送请求时都会带着 <strong>Accept-Encoding</strong> 头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进 <strong>Content-Encoding</strong> 响应头里，再把原数据压缩后发给浏览器。</p>
<p>如果压缩率能有 50%，也就是说 100K 的数据能够压缩成 50K 的大小，那么就相当于在带宽不变的情况下网速提升了一倍，加速的效果是非常明显的。</p>
<p>不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率（通常能超过 60%），而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</p>
<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>在数据压缩之外，还能有什么办法来解决大文件的问题呢？</p>
<p>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。</p>
<p>这种 <strong>化整为零</strong> 的思路在 HTTP 协议里就是 <strong>分块传输编码（chunked）</strong>，在响应报文里用头字段 <strong>Transfer-Encoding: chunked</strong> 来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的 <strong>块（chunk）</strong>逐个发送。</p>
<p>分块传输也可以用于 <strong>流式数据</strong>，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段 <strong>Content-Length</strong> 里给出确切的长度，所以也只能用 chunked 方式分块发送。</p>
<blockquote>
<p>Transfer-Encoding: chunked 和 Content-Length 这两个字段是 <strong>互斥的</strong>，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。</p>
<p>Transfer-Encoding 最常见的值是 chunked，但也可以用 gzip、deflate 等，表示传输时使用了压缩编码。但这与 Content-Encoding 不同，Transfer-Encoding 在传输后会被自动解码还原出原始数据，而 Content-Encoding 则必须由应用自己解码。</p>
</blockquote>
<p>分块传输的编码规则，如图所示：</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/25e7b09cf8cb4eaebba42b4598192410.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即 \r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾（分块传输数据中含有 CRLF 不会影响分块处理，因为分块前有数据长度说明）；</li>
<li>最后用一个长度为 0 的分块表示结束，即 0\r\n\r\n 。</li>
</ol>
<p><strong>请求报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-1</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br></code></pre></td></tr></table></figure>

<p><strong>响应报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 08:01:52 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 1</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 2</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 3</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-number">0</span></span><br></code></pre></td></tr></table></figure>

<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>有了分块传输编码，服务器就可以轻松地收发大文件了，但对于几 G 的超大文件，还有一些问题需要考虑。</p>
<p>比如，你在看当下正热播的某穿越剧，想跳过片头直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</p>
<p>HTTP 协议为了满足这样的需求，提出了 <strong>范围请求（range requests）</strong>的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是 <strong>客户端的化整为零</strong>。</p>
<p>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段 <strong>Accept-Ranges: bytes</strong> 明确告知客户端：我支持范围请求。如果不支持的话，服务器可以发送 Accept-Ranges: none，或者干脆不发送 Accept-Ranges 字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</p>
<p>请求头 <strong>Range: bytes=x-y</strong> 是 HTTP 范围请求的专用字段，其中的 x 和 y 是以字节为单位的数据范围，表示数据的偏移量，从 0 开始计数。Range 的格式也很灵活，x 和 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</p>
<ul>
<li>“0-”：表示从文档起点到文档结尾，相当于 0-99，即整个文件；</li>
<li>“10-”：表示从第 10 个字节开始到文档结尾，相当于 10-99；</li>
<li>“-1”：表示文档的最后一个字节，相当于 99-99；</li>
<li>“-10”：表示从文档结尾倒数 10 个字节，相当于 90-99。</li>
</ul>
<blockquote>
<p>注：Range 请求的数据范围针对于压缩前的原文件。</p>
</blockquote>
<p>服务器收到 Range 字段后，需要做四件事。</p>
<ol>
<li>必须检查请求的范围是否合法，比如文件只有 100 个字节，但请求 “200-300”，这就是范围越界了。服务器就会返回状态码 <strong>416</strong>，意思是所请求的范围无法满足；</li>
<li>如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码 <strong>206 Partial Content</strong>，和 200 的意思差不多，但表示 body 只是原数据的一部分。</li>
<li>服务器要添加一个响应头字段 <strong>Content-Range: bytes x-y/length</strong>，告诉片段的实际偏移量和资源的总大小，与 Range 头区别在没有 “=”，范围后多了总长度。例如，对于 “0-10” 的范围请求，值就是 “bytes 0-10/100”。</li>
<li>发送数据，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</li>
</ol>
<p>范围请求不仅可以用在看视频时的拖拽进度，常用的多段下载、断点续传也是基于它实现的，要点是：</p>
<ol>
<li>先发个 HEAD 请求，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 n 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发送请求传输数据；</li>
<li>下载意外中断也不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ol>
<p><strong>请求报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-2</span> <span class="hljs-meta">HTTP/1.1</span><br>Host:www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br>Range:bytes=0-31<br></code></pre></td></tr></table></figure>

<p><strong>响应报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 06:27:26 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>32<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Sat, 29 May 2021 11:07:40 GMT<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;60b2207c-5a&quot;<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 0-31/90<br><br><span class="pgsql">// this <span class="hljs-keyword">is</span> a plain <span class="hljs-type">text</span> <span class="hljs-type">json</span> doc</span><br></code></pre></td></tr></table></figure>

<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个 “x-y”，一次性获取多个片段数据。</p>
<p>这种情况需要使用一种特殊的 MIME 类型：<strong>multipart/byteranges</strong>，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数 <strong>boundary=xxx</strong> 给出段之间的分隔标记。</p>
<p>多段数据的格式与范围请求也比较类似，但它需要用 <strong>分隔标记（boundary）</strong>来区分不同的片段，每一个分段必须以 “–boundary” 开始，之后用 Content-Type 和 Content-Range 标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个 “–boundary–” 表示所有的分段结束。</p>
<p>多段数据的编码规则，如图所示：</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/fffa3a65e367c496428f3c0c4dac8a37.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>请求报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-2</span> <span class="hljs-meta">HTTP/1.1</span><br>Host:www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br>Range:bytes=0-9,20-29<br></code></pre></td></tr></table></figure>

<p><strong>响应报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 06:13:04 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=00000000001<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>189<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Sat, 29 May 2021 11:07:40 GMT<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;60b2207c-5a&quot;<br><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-comment">--00000000001</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">0</span><span class="hljs-number">-9</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">// this <span class="hljs-keyword">is</span></span><br><span class="pgsql"><span class="hljs-comment">--00000000001</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">20</span><span class="hljs-number">-29</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">ext <span class="hljs-type">json</span> d</span><br><span class="pgsql"><span class="hljs-comment">--00000000001--</span></span><br></code></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>HTTP 处理大文件有四种方法，要注意这四种方法不是互斥的，而是可以混合起来使用。例如，压缩后再分块传输，或者分段后再分块。下面就模拟了后一种场景：</p>
<p><strong>请求报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-3</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.chrono.com<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9<br></code></pre></td></tr></table></figure>

<p><strong>响应报文</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 08:07:26 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=xyz<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><br><span class="pgsql"><span class="hljs-number">47</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">0</span><span class="hljs-number">-9</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">// this <span class="hljs-keyword">is</span></span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">49</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">20</span><span class="hljs-number">-29</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">ext <span class="hljs-type">json</span> d</span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">8</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz--</span></span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">0</span></span><br></code></pre></td></tr></table></figure>

<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>HTTP 的性能问题可以说是：“不算差，不够好”，这次就来好好看看 HTTP 在连接这方面的表现。</p>
<h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求-应答” 方式。</p>
<p>底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 <strong>短连接（short-lived connections）</strong>，早期的 HTTP 协议也被称为是 <strong>无连接</strong> 的协议。</p>
<p>短连接的缺点相当严重，因为在 TCP 协议里，<strong>建立连接和关闭连接都是非常昂贵的操作</strong>。TCP 建立连接要有三次握手，发送 3 个数据包，需要 1 个 RTT；关闭连接是四次挥手，4 个数据包需要 2 个 RTT。而 HTTP 的一次简单 “请求-应答” 通常只需要 <strong>4 个包</strong>，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是 3÷5=60%，传输效率低得惊人。</p>
<blockquote>
<p>RTT（Round-Trip Time）：往返时延，为数据完全发送完成到收到确认信号的时间。</p>
</blockquote>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/54315ed9ac37fbc6547258040f00a80c.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>针对短连接暴露出的缺点，HTTP 协议提出了 <strong>长连接（persistent connections）</strong> 的通信方式。</p>
<p>其实解决办法也很简单，用的就是 <strong>成本均摊</strong> 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求-应答” 均摊到多个 “请求-应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 <strong>分母效应</strong>，每个 “请求-应答” 的无效时间就会降低不少，整体传输效率也就提高了。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/57b3d80234a1f1b8c538a376aa01d3b4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="连接字段"><a href="#连接字段" class="headerlink" title="连接字段"></a>连接字段</h3><p>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会 <strong>默认启用长连接</strong>。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</p>
<p>当然，我们也可以明确要求使用长连接机制，只需要在请求头中加上 <strong>Connection: keep-alive</strong> 字段。不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个 <strong>Connection: keep-alive</strong> 字段，告诉客户端：我支持长连接。</p>
<p>不过长连接也有一些小缺点，<strong>问题就出在它的 “长” 上</strong>。因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p>
<p>所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p>
<p>在客户端，可以在请求头里加上 <strong>Connection: close</strong> 字段，告诉服务器：这次通信后就关闭连接。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>而服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ol>
<li>使用 <code>keepalive_timeout</code> 指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用 <code>keepalive_requests</code> 指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<p>另外，客户端和服务器都可以在报文里附加通用头字段 <strong>Keep-Alive: timeout=value</strong>，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</p>
<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p><strong>队头阻塞（head-of-line blocking）</strong>与短连接和长连接无关，而是由 HTTP 基本的 “请求-应答” 模型所导致的。</p>
<p>因为 HTTP 规定报文必须是 “一发一收”，这就形成了一个先进先出的 “串行” 队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p>
<p>在性能优化上，由于 “请求-应答” 模型不能变，所以队头阻塞问题在 HTTP/1.1 里无法解决，只能通过 <strong>并发连接（concurrent connections）</strong>和 <strong>域名分片（domain sharding）</strong>技术进行缓解。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/6a6d30a89fb085d5f1773a887aaf5572.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="Cookie-机制"><a href="#Cookie-机制" class="headerlink" title="Cookie 机制"></a>Cookie 机制</h2><p>HTTP 协议是 <strong>无状态</strong> 的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点是无法支持需要记录状态的事务操作。好在 HTTP 协议是可扩展的，通过 Cookie 技术，就给 HTTP 增加了 “记忆能力”。</p>
<blockquote>
<p>目前虽然已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。</p>
</blockquote>
<h3 id="Cookie-的工作流程"><a href="#Cookie-的工作流程" class="headerlink" title="Cookie 的工作流程"></a>Cookie 的工作流程</h3><p>Cookie 的传递要用到两个字段，分别是响应头字段 <strong>Set-Cookie</strong> 和请求头字段 <strong>Cookie</strong>，这个过程如下所示：</p>
<ol>
<li>当用户通过浏览器第一次访问服务器的时候，服务器不知道他的身份，会创建一个独特的身份标识数据，格式是 <strong>Set-Cookie: key=value</strong>，随着响应报文一同发给浏览器。</li>
<li>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器，格式是 <strong>Cookie: key=value</strong>。</li>
<li>因为第二次请求里面有了 Cookie 字段，服务器就可以拿到 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。</li>
</ol>
<blockquote>
<p>服务器有时会在响应头里添加多个 Set-Cookie，存储多个 “key=value”，但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行中用 “;” 隔开就行。</p>
<p>Cookie 是由浏览器负责存储的，而不是操作系统，所以它只能在本浏览器内生效。</p>
</blockquote>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/9f6cca61802d65d063e24aa9ca7c38a4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3><p>常见的 Cookie 属性可以分为三类：</p>
<ul>
<li><p><strong>生存周期：</strong>即 Cookie 的有效期，限制 Cookie 只能在一段时间内可用，可以使用 <strong>Expires</strong> 和 <strong>Max-Age</strong> 两个属性来设置。Expires 使用绝对时间，可以理解为是截止日期；Max-Age 使用相对时间，单位为秒，表示浏览器收到报文后经过的时间。</p>
<blockquote>
<p>如果不指定 Expires 或 Max-Age 属性，那么 Cookie 仅在浏览器运行时有效，一旦关闭浏览器就会失效，这也被称为 <strong>会话Cookie（session cookie）</strong>。</p>
</blockquote>
</li>
<li><p><strong>作用域：</strong>让浏览器仅把 Cookie 发送给特定的服务器和 URI，避免被其他网站盗用。作用域的设置比较简单，使用 <strong>Domain</strong> 和 <strong>Path</strong> 指定 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p>
<blockquote>
<p>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如 “/19-1” 用一个 Cookie，“/19-2” 再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个 “/” 表示或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。</p>
</blockquote>
</li>
<li><p><strong>安全性：</strong>尽量不要让用户和服务器以外的人获取到 Cookie 的内容，在 Cookie 中有三个与安全相关的属性。</p>
<ul>
<li><strong>HttpOnly</strong> 属性会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，可以缓解 XSS 跨站脚本攻击。</li>
<li><strong>SameSite</strong> 属性可以防范 CSRF 跨站请求伪造攻击，设置成 <code>SameSite=Strict</code> 可以严格限定 Cookie 不能随着跳转链接跨站发送，而 <code>SameSite=Lax</code> 则略微宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</li>
<li><strong>Secure</strong> 属性表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li>
</ul>
</li>
</ul>
<h3 id="Cookie-的应用"><a href="#Cookie-的应用" class="headerlink" title="Cookie 的应用"></a>Cookie 的应用</h3><p>Cookie 最基本的一个用途就是 <strong>身份识别</strong>，保存用户的登录信息，实现会话事务。</p>
<p>比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie，内容大概是 “name=yourid”，这样就成功地把身份标签贴在了你身上。</p>
<p>之后你在网站里随便访问哪件商品的页面，浏览器都会自动把身份 Cookie 发给服务器，所以服务器总会知道你的身份，一方面免去了重复登录的麻烦，另一方面也能够自动记录你的浏览记录和购物下单，实现了 “状态保持”。</p>
<p>Cookie 的另一个常见用途是 <strong>广告跟踪</strong>。</p>
<p>比如，上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会 “偷偷地” 给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。</p>
<p>这种 Cookie 不是由访问的主站存储的，所以又叫 <strong>第三方 Cookie（third-party cookie）</strong>。如果广告商势力很大，广告到处都是，那么就比较恐怖了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告的 “精准打击”。</p>
<p>为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大。</p>
<h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p><strong>代理（Proxy）</strong> 是 HTTP 协议中请求方和应答方中间的一个环节，所谓 “代理服务” 就是指 <strong>服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份</strong>：面向下游的用户时，表现为服务器，代表源服务器进行响应；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。 </p>
<p>代理有很多的种类，常见的有：</p>
<ol>
<li>匿名代理：完全 “隐匿” 了被代理的机器，外界看到的只是代理服务器。</li>
<li>透明代理：在传输过程中是 “透明开放” 的，外界既知道代理，也知道客户端。</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求。</li>
<li>反向代理：靠近服务器，代表服务器响应客户端的请求。</li>
</ol>
<p>现在无处不在的 <strong>内容分发网络（CDN，Content Delivery Network）</strong>，实际上就是一种代理（缓存代理），它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/28237ef93ce0ddca076d2dc19c16fdf9.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><p>由于代理处在 HTTP 通信过程的中间位置，对上屏蔽了真实客户端，对下屏蔽了真实服务器，所以在这个中间环节就可以做很多有意思的事情，为 HTTP 协议增加更多的灵活性。</p>
<p>代理最基本的一个功能就是 <strong>负载均衡</strong>：把访问请求均匀分散到多台机器，实现访问集群化。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道，真正由哪台服务器来响应请求完全由代理服务器决定。</p>
<p>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</p>
<ul>
<li><strong>健康检查</strong>：使用 “心跳” 等机制监控后端服务器，发现有故障就及时 “踢出” 集群，保证服务高可用。</li>
<li><strong>安全防护</strong>：隐匿源站 IP，使用 WAF 等工具抵御网络攻击，以及限制 IP 访问或流量过载，保护被代理的后端服务器。</li>
<li><strong>加密卸载</strong>：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，省去加解密成本。</li>
<li><strong>数据处理</strong>：提供压缩、加密、修改上下行数据等功能。</li>
<li><strong>内容缓存</strong>：暂存、复用服务器响应，减轻后端的压力。</li>
</ul>
<h3 id="代理字段"><a href="#代理字段" class="headerlink" title="代理字段"></a>代理字段</h3><p>代理的好处很多，但因为它 “欺上瞒下” 的特点，隐藏了真实客户端和服务器，如果双方想要获得这些被隐藏的原始信息，该怎么办呢？</p>
<p>首先，代理服务器需要用 <strong>Via</strong> 字段 <strong>标明代理的身份</strong>。Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</p>
<p>例如下图中有两个代理：proxy1 和 proxy2，客户端发送请求会经过这两个代理，依次添加就是 <strong>Via: proxy1, proxy2</strong>，等到服务器返回响应报文的时候就要反过来，依次是 <strong>Via: proxy2, proxy1</strong>。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/52a3bd760584972011f6be1a5258e2d7.png" srcset="/img/loading.gif" lazyload></p>
<p>Via 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。但服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</p>
<p>可惜的是 HTTP 标准里并没有为此定义头字段，但已经出现了很多 “事实上的标准”，最常用的两个头字段是 <strong>X-Forwarded-For</strong> 和 <strong>X-Real-IP</strong>。</p>
<p>X-Forwarded-For（XFF）的字面意思是 “为谁而转发”，形式上和 Via 差不多，也是每经过一个代理节点就会在字段里追加一个信息。但 Via 追加的是 <strong>代理主机名</strong>（或者域名），而 X-Forwarded-For 追加的是 <strong>请求方的 IP 地址</strong>。所以，在 X-Forwarded-For 字段里最左边的 IP 就是客户端的地址。此外还有两个字段：X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端请求的原始域名和原始协议名。</p>
<p>X-Real-IP 是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录 <strong>客户端 IP 地址</strong>，没有中间的代理信息，相当于是 X-Forwarded-For 的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。</p>
<h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3><p>有了 X-Forwarded-For 等头字段，源站就可以拿到准确的客户端信息了，但对于代理服务器来说它并不是一个最佳的解决方案。</p>
<p>因为通过 X-Forwarded-For 操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能；另一个问题是 X-Forwarded-For 等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 加密通信）。</p>
<p>所以就出现了一个专门的 <strong>代理协议（PROXY protocol）</strong>，可以在不改动原始报文的情况下传递客户端的真实 IP。它由知名的代理软件 HAProxy 定义，也是一个被广泛采用的 “事实标准”（并不是 RFC），目前有 v1（明文格式）和 v2（二进制格式）两个版本。</p>
<p> v1 会在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头，格式形如：<code>PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</code>。服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情。</p>
<h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><p><strong>缓存（Cache）</strong>是计算机领域里的一个重要概念，是 <strong>优化系统性能</strong> 的重要手段。</p>
<p>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把来之不易的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次 “请求-应答” 的通信成本，节约网络带宽，也可以加快响应速度。</p>
<p>实际上，HTTP 传输的 <strong>每一个环节</strong> 基本上都会有缓存，非常复杂。基于 “请求-应答” 模式的特点，可以大致分为客户端缓存和服务器端缓存。</p>
<blockquote>
<p>没有请求的请求，才是最快的请求。</p>
</blockquote>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>缓存控制的运行机制实际上和 Cookie 机制十分相似，在传递中使用了 <strong>Cache-Control</strong> 头字段，这个过程如下所示：</p>
<ol>
<li>浏览器请求一个资源，发现缓存中没有数据，于是发送请求，向服务器获取资源；</li>
<li>服务器响应请求，返回资源，同时标记资源的有效期，格式是 <strong>Cache-Control: max-age=30</strong>；</li>
<li>浏览器缓存资源，等待下次重用。</li>
</ol>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/a1968821f214df4a3ae16c9b30f99a5b.png" srcset="/img/loading.gif" lazyload></p>
<p>max-age 是 HTTP 缓存控制最常用的属性，作用和 Cookie 类似，不过时间的计算起点是响应报文的 <strong>创建时间</strong>（即 Date 字段），此外在 Cache-Control 里还可以设置其他属性来更精确地指示浏览器如何使用缓存：</p>
<ul>
<li>no_store：<strong>不允许缓存</strong>，用于某些变化非常频繁的数据，例如秒杀页面。</li>
<li>no_cache：<strong>可以缓存</strong>，但在 <strong>使用缓存前</strong> 必须去服务器验证是否过期，是否有最新的版本（等同于 max-age=0,must-revalidate）。</li>
<li>must-revalidate：<strong>可以缓存</strong>，如果缓存不过期就可以继续使用，如果 <strong>缓存失效</strong> 则必须去服务器验证。</li>
</ul>
<p>其实不止服务器可以发 Cache-Control 响应头，浏览器也可以发送 Cache-Control 请求头，也就是说 “请求-应答” 的双方都可以用这个字段进行缓存控制，<strong>互相协商</strong> 缓存的使用策略。</p>
<p>当使用 F5 刷新按钮的时候，浏览器会在请求头里加一个 <strong>Cache-Control: max-age=0</strong>，此时不使用缓存，直接向服务器发送请求。服务器看到 max-age=0，也会生成一个最新报文回应浏览器；使用 Ctrl+F5 强制刷新时，会发送 <strong>Cache-Control: no-cache</strong>，含义和 max-age=0 基本一样，依赖于后端服务器怎么理解，通常两者的效果是相同的。</p>
<p>只有在 “前进” “后退” “跳转” 这些重定向动作中，浏览器的缓存才会真正生效。此时请求头中不再有 Cache-Control，在响应码后会有 “from disk cache” 字样，表示没有发送网络请求，而是读取磁盘上的缓存。</p>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>由于浏览器在使用缓存前往往需要去服务器验证缓存是否为最新，这个验证动作可以用两个连续的请求完成：先发一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存；否则就再发一个 GET 请求，获取最新的版本。</p>
<p>但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列 <strong>If</strong> 开头的 <strong>条件请求</strong> 字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并为一个请求。并且，缓存是否过期的验证逻辑也在服务器中完成。</p>
<p>条件请求一共有 5 个头字段，我们最常用的是 <strong>If-Modified-Since</strong> 和 <strong>If-None-Match</strong> 这两个。使用条件请求需要服务器在第一次的响应报文中提供 <strong>Last-modified</strong> 或 <strong>ETag</strong> 字段，然后浏览器在接下来的条件请求中就可以带上这个字段值，验证资源是否是最新的。如果资源没有变，服务器就回应一个 <strong>304 Not Modified</strong>，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p>
<p>Last-modified 很好理解，就是文件的最后修改时间。ETag 是 <strong>实体标签（Entity Tag）</strong>的缩写，<strong>是资源的一个唯一标识</strong>，用于精确地识别资源的变动情况，解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分；再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b239d0804be630ce182e24ea9e4ab237.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理也就是支持缓存控制的代理服务，是服务器端的缓存技术。</p>
<p>在没有缓存的时候，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有最简单的中转功能。</p>
<p>加入了缓存后，代理服务会把源服务器发来的响应报文转发给客户端，同时把报文存入自己的 Cache 里。下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。 </p>
<p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5e8d10b5758685850aeed2a473a6cdc2.png" srcset="/img/loading.gif" lazyload></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/">通用技术</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/HTTP/">HTTP</a>
                    
                      <a class="hover-with-bg" href="/tags/Cookie/">Cookie</a>
                    
                      <a class="hover-with-bg" href="/tags/Proxy/">Proxy</a>
                    
                      <a class="hover-with-bg" href="/tags/Cache/">Cache</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%89%EF%BC%89/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">透视 HTTP 协议（三）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/">
                        <span class="hidden-mobile">透视 HTTP 协议（一）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>Powered by</span> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>×</span> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量: 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数: 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
