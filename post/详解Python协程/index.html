

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/global/favicon.ico">
  <link rel="icon" href="/img/global/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="eW1z4rd">
  <meta name="keywords" content="">
  
    <meta name="description" content="在 Python 中并发编程一般都是使用多线程或者多进程来实现的，其实对于 IO 密集型任务我们还有另外一种选择，就是使用协程，本文对 Python3 的协程进行了详细介绍。">
<meta property="og:type" content="article">
<meta property="og:title" content="详解 Python 协程">
<meta property="og:url" content="https://ew1z4rd.github.io/post/%E8%AF%A6%E8%A7%A3Python%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="栖丘">
<meta property="og:description" content="在 Python 中并发编程一般都是使用多线程或者多进程来实现的，其实对于 IO 密集型任务我们还有另外一种选择，就是使用协程，本文对 Python3 的协程进行了详细介绍。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ew1z4rd.github.io/img/Python/v2-243e068bad56486f3ada2c2b75603570_720w.jpg">
<meta property="og:image" content="https://ew1z4rd.github.io/img/Python/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg">
<meta property="article:published_time" content="2021-04-12T02:48:21.000Z">
<meta property="article:modified_time" content="2022-02-07T13:39:59.860Z">
<meta property="article:author" content="eW1z4rd">
<meta property="article:tag" content="Python3">
<meta property="article:tag" content="高并发">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ew1z4rd.github.io/img/Python/v2-243e068bad56486f3ada2c2b75603570_720w.jpg">
  
  
  <title>详解 Python 协程 - 栖丘</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ew1z4rd.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":"f307ed711fcf86fe5ceb149239b6cfc3","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>eW1z4rd&#39;s space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/global/post-bg.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="详解 Python 协程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-12 10:48" pubdate>
        2021年4月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">详解 Python 协程</h1>
            
            <div class="markdown-body">
              <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>通常我们认为线程是轻量级的进程，因此我们也把协程理解为轻量级的线程。</p>
</blockquote>
<p>在 Python 中并发编程一般都是使用多线程或者多进程来实现的，对于 CPU 密集型任务由于 GIL 的存在我们通常使用多进程，而对于 IO 密集型任务我们可以通过线程调度，让线程在执行 IO 任务时让出 GIL，从而实现表面上的并发。</p>
<p>其实对于 IO 密集型任务我们还有另外一种选择，就是 <strong>协程（Coroutine）</strong>。协程的作用是在执行函数 A 时可以随时中断去执行函数 B，然后中断函数 B 继续执行函数 A，即可以在任务间自由切换，<strong>由用户决定，在哪些地方交出控制权</strong>。这一过程看似像多线程，但其实<strong>只有一个线程执行</strong>，协程就相当于是运行在单线程中的“并发”。</p>
<h3 id="协程有什么优势？"><a href="#协程有什么优势？" class="headerlink" title="协程有什么优势？"></a>协程有什么优势？</h3><ol>
<li>开销少，执行效率极高：因为子程序（函数）切换不是线程切换，而是由程序自身控制，没有线程上下文切换的开销。所以与多线程相比，线程的数量越多，协程性能的优势就越明显。</li>
<li>不需要多线程的锁机制：因为只有一个线程，不存在同时写变量冲突，在协程中控制共享资源不需要加锁，也没有状态同步的开销，因此执行效率比多线程高很多。</li>
<li>方便切换控制流，简化代码逻辑。</li>
</ol>
<h3 id="协程如何处理CPU密集型任务？"><a href="#协程如何处理CPU密集型任务？" class="headerlink" title="协程如何处理CPU密集型任务？"></a>协程如何处理CPU密集型任务？</h3><p>协程可以很好地处理 IO 密集型任务的效率问题，但其本质是个单线程，处理 CPU 密集型任务不是它的长处。如果要充分发挥多核 CPU 的性能，最简单的方法是 <strong>多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可以获得极高的性能。</p>
<h3 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><blockquote>
<p>进程和线程是抢占式的调度（CPU 决定），协程是协同式的调度（代码决定）。</p>
</blockquote>
<ul>
<li><strong>进程</strong>：每个人都领一套工具（环境，上下文）去干活，要干很多工作，人多（核多）就可以做的更快。</li>
<li><strong>线程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个要听老板的（系统），遇见要等待的事情，老板会叫你先干别的。但老板不懂你干的活，比如你挖一个坑埋一个萝卜再盖土，结果他让你挖坑、埋土、放萝卜，这时候就要用锁告诉老板这个必须先放了萝卜才能埋土。</li>
<li><strong>协程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个由自己决定（代码），遇见要等待的事情，自己会先干别的。对于老板来说，协程内的工作他不会干预，比如他会让你吃饭，但不会规定先吃哪个菜。而正是因为省去了老板的工作量，才大大提高了公司的效率。</li>
<li><strong>串行</strong>：一个人有一套工具后干活，要干很多工作，先干哪个完全按写好的清单来，遇见要等待的事情，就等他执行完了再做下一个。</li>
</ul>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul>
<li>Python 2.2 中，第一次引入了生成器，生成器实现了一种惰性、多次取值的方法，此时还是通过<code>next</code>构造生成迭代链或进行多次取值。</li>
<li>Python 2.5 中，引入了<code>yield</code>关键字，使得生成器有了记忆功能，下一次从生成器取值时，可以恢复到上次<code>yield</code>执行的位置。此外，生成器还加入了<code>send</code>方法与<code>yield</code>搭配使用，可以用<code>yield</code>让生成器暂停到一个状态，还可以通过<code>send</code>方法传入一个值来改变其停止位置的状态。</li>
<li>Python 3.3 中，新增了<code>yield from</code>关键字，实现了在生成器（委派生成器）内部调用另外生成器（子生成器）的功能，可以轻易的重构生成器，比如将多个生成器连接在一起执行。</li>
<li>Python 3.4 中，新增了 asyncio 库，提供了一个默认的 Event Loop，在语法上支持使用<code>@asyncio.coroutine</code>和<code>yield from</code>实现协程，有了足够的基础工具进行异步并发编程。</li>
<li>Python 3.5 中，引入了<code>async</code>/<code>await</code>关键字，用以取代<code>@asyncio.coroutine</code>和<code>yield from</code>，从而简化了协程的使用并且便于理解。</li>
</ul>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h3><p>在 Python 中一切皆对象，对象的抽象就是类，而 <strong>对象的集合就是容器</strong>，比如字符串、列表、元组、字典、集合都是容器。不同容器的区别，在于内部数据结构的实现方法。</p>
<p>所有的容器都是 <strong>可迭代的（iterable）</strong>，即可迭代对象。这里的迭代，和枚举不完全一样。迭代可以想象成是你去买苹果，卖家并不告诉你他有多少库存。这样，每次你都需要告诉卖家，你要一个苹果，然后卖家采取行为：要么给你拿一个苹果；要么告诉你，苹果已经卖完了。你并不需要知道，卖家在仓库是怎么摆放苹果的。</p>
<p>严谨地说，<strong>迭代器（iterator）</strong>提供了一个 <strong>_<em>next</em>_</strong> 方法，调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 <code>StopIteration</code> 异常。对于可迭代对象，通过调用 <strong>iter()</strong> 函数可以得到一个迭代器，迭代器可以通过 <strong>next()</strong> 函数来得到下一个元素，从而实现遍历，<code>for...in...</code> 语句就是将这个过程隐式化。</p>
<p><strong>示例：遍历迭代器对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python">iterable_list = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterable_list))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;empty&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>

<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><strong>生成器（generator）</strong>是一种特殊的迭代器，它并不会像迭代器一样占用大量内存。合理使用生成器，可以降低内存占用、优化程序结构、提高程序速度。此外，在 Python 2 的版本中，生成器也是实现l协程的一种重要方式。</p>
<p><strong>示例：生成器与迭代器的性能差异比较</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> psutil<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_memory</span>(<span class="hljs-params">hint</span>):</span><br>    memory = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;psutil.Process(os.getpid()).memory_full_info().uss / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>:<span class="hljs-number">.4</span>f&#125;</span> MB&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;hint&#125;</span> memory used: <span class="hljs-subst">&#123;memory&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_iterator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init iterator&#x27;</span>)<br>    res = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>)]  <span class="hljs-comment"># 返回迭代器，其中的每个元素在生成后都会保存到内存中</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_generator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init generator&#x27;</span>)<br>    res = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))  <span class="hljs-comment"># 返回生成器，只有在调用next()函数的时候，才会生成下一个变量</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br>test_iterator()<br>test_generator()<br></code></pre></td></tr></table></figure>

<h2 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h2><blockquote>
<p>yield 应当取其“让步”而非“产出”或“返回”之意，这是理解协程的关键。</p>
</blockquote>
<p>yield 有让步之意，因为它交出了程序的控制权，但这个协程并没有结束，下一次执行时，将恢复到之前让出程序控制权的地方，也就是 yield 语句执行的地方继续执行。方法中包含<code>yield</code>表达式后，Python 会将其视作一个生成器对象，不再是普通的方法。</p>
<p>常用方法说明：</p>
<ul>
<li><code>__next__()</code>方法或<code>next()</code>: 作用是启动或者恢复 generator 的执行，相当于<code>send(None)</code></li>
<li><code>send(value)</code>方法：作用是发送值给 yield 表达式，启动 generator 会调用<code>send (None)</code></li>
<li>使用生成器之前需要先调用<code>__next__</code>或者<code>send(None)</code>方法，否则将报错。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：yield 的简单使用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;generator start&#x27;</span>)<br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        yield_expression_value = <span class="hljs-keyword">yield</span> n<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;yield_expression_value: <span class="hljs-subst">&#123;yield_expression_value&#125;</span>&#x27;</span>)<br>        n += <span class="hljs-number">1</span>  <span class="hljs-comment"># 创建generator对象</span><br><br><br>test_generator = test()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(test_generator))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br><span class="hljs-comment"># 启动generator</span><br>next_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># generator start</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;next_result: <span class="hljs-subst">&#123;next_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 发送值给yield表达式</span><br>send_result = test_generator.send(<span class="hljs-number">100</span>)  <span class="hljs-comment"># 100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 再次调用generator</span><br>send_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># None</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure>

<p><strong>示例二：yield 和 send 与外界的交互流程</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump_range</span>(<span class="hljs-params">up_to</span>):</span><br>    step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> step &lt; up_to:<br>        jump = <span class="hljs-keyword">yield</span> step<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;jump&#x27;</span>, jump)<br>        <span class="hljs-keyword">if</span> jump <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            jump = <span class="hljs-number">1</span><br>        step += jump<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step&#x27;</span>, step)<br><br><br>iterator = jump_range(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(iterator.send(<span class="hljs-number">4</span>))  <span class="hljs-comment"># jump 4; step 4; 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># jump None; step 5; 5</span><br><span class="hljs-built_in">print</span>(iterator.send(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># jump -1; step 4; 4</span><br></code></pre></td></tr></table></figure>

<p><strong>示例三：yield 生产者-消费者模型</strong></p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程读消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过 <code>yield</code> 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;示例说明：</span><br><span class="hljs-string">1. consumer函数是一个generator</span><br><span class="hljs-string">2. 把一个consumer传入produce后，首先调用c.send(None)启动生成器</span><br><span class="hljs-string">3. 一旦produce产生了消息，通过c.send(n)切换到consumer执行</span><br><span class="hljs-string">4. consumer通过yield拿到消息，进行处理，又通过yield把结果传回</span><br><span class="hljs-string">5. produce拿到consumer处理的结果，继续生产下一条消息</span><br><span class="hljs-string">6. produce决定不生产了，通过c.close()关闭consumer，整个过程结束</span><br><span class="hljs-string">7. 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    r = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[CONSUMER] Consuming <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = <span class="hljs-string">&#x27;200 OK&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">produce</span>(<span class="hljs-params">c</span>):</span><br>    c.send(<span class="hljs-literal">None</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Producing <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = c.send(n)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Consumer return: <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br>    c.close()<br><br><br>C = consumer()<br>produce(C)<br></code></pre></td></tr></table></figure>

<p><strong>示例四：yield from 表达式</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 子生成器</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_n</span>(<span class="hljs-params">n</span>):</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        <span class="hljs-keyword">yield</span> i<br>        i += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 委派生成器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;do something&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> main(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure>

<h2 id="asyncio-库"><a href="#asyncio-库" class="headerlink" title="asyncio 库"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio.html">asyncio 库</a></h2><p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法，是实现高性能 Python 异步框架的基础。</p>
<h3 id="协程与任务"><a href="#协程与任务" class="headerlink" title="协程与任务"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html">协程与任务</a></h3><h4 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h4><p>如果一个对象可以在 <strong>await 语句</strong> 中使用，那么它就是 <strong>可等待对象（awaitable）</strong> 。</p>
<blockquote>
<p>对 await 关键字的理解：简单的说，await就是挂起当前任务，去执行其他任务，此时是堵塞的，必须要等其他任务执行完毕才能返回到当前任务继续往下执行，这样的说的前提是，在一个时间循环中有多个 task 或 future，当 await 右面等待的对象是协程对象时，就没有了并发的作用，就是堵塞等待这个协程对象完成。</p>
</blockquote>
<p>可等待对象有三种主要类型：<strong>协程（Coroutine）</strong>、<strong>任务（Task）</strong>、<strong>Future 对象</strong>。</p>
<ol>
<li><p>协程：Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待。协程函数的调用不会立即执行，而是会返回一个协程对象。协程对象需要注册到事件循环中，由事件循环调用。</p>
<blockquote>
<p>协程函数：定义形式为 <code>async def</code> 的函数<br>协程对象：调用协程函数所返回的对象</p>
</blockquote>
</li>
<li><p>任务：<em>任务</em> 是对协程的进一步封装，其中包含有各种状态，用于 <strong>并发</strong> 运行多个协程。当一个协程通过 <code>asyncio.create_task()</code> 等函数被封装为一个 <em>任务</em>，<strong>该协程会被自动调度执行</strong>。</p>
</li>
<li><p>Future 对象：<em>Future</em> 是一种特殊的 <strong>低层级</strong> 可等待对象，是 <em>Task</em> 的父类，表示一个异步操作的 <strong>最终结果</strong>。通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p>
</li>
</ol>
<p><img src="/img/Python/v2-243e068bad56486f3ada2c2b75603570_720w.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h4><ul>
<li><code>asyncio.run(main, *, debug=False)</code><ul>
<li>创建一个新的事件循环并在结束时将循环关闭。</li>
<li>它应当被用作 asyncio 程序 <strong>最高层级的</strong> 入口点（main 方法），在理想情况下应当只被调用一次。</li>
<li>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</li>
<li>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</li>
</ul>
</li>
</ul>
<p>注：<code>asyncio.run()</code> 是 Python 3.7 中引入的，也是官方 <strong>推荐的</strong> 运行协程的方式，相当于老版本的以下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><span class="hljs-keyword">try</span>:    <br>    loop.run_until_complete(coro)<br><span class="hljs-keyword">finally</span>:    <br>    loop.close()<br></code></pre></td></tr></table></figure>

<h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ul>
<li><code>asyncio.create_task(coro, *, name=None)</code><ul>
<li>将传入的协程封装为一个 Task，并自动调度它执行，返回 Task 对象。</li>
<li>当 <em>name</em> 不为 <code>None</code> 时，它将使用 <code>Task.set_name()</code> 来设置任务的名称。</li>
</ul>
</li>
</ul>
<p>同样，此函数在 Python 3.7 中被引入，相当于低层级的 <code>asyncio.ensure_future()</code> 方法。</p>
<h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><ul>
<li><code>asyncio.sleep(delay, result=None, *)</code><ul>
<li>阻塞 <em>delay</em> 指定的秒数。</li>
<li>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</li>
<li><code>asyncio.sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</li>
<li>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行，这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</li>
</ul>
</li>
</ul>
<h4 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a>并发运行任务</h4><ul>
<li><code>asyncio.gather(*aws, return_exceptions=False)</code><ul>
<li><em>并发</em> 运行 <em>aws</em> 序列中的所有可等待对象。</li>
<li>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动被作为一个任务调度。</li>
<li>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</li>
<li>如果 <em>return_exceptions</em> 为 <code>False</code>，不捕获协程中的异常，错误会完整地 throw 到当前的执行层，但是 <em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行（可以在下次 await 的时候执行）。</li>
<li>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</li>
</ul>
</li>
</ul>
<p><strong>示例一：协程的异常处理和取消</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_1</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_2</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> / <span class="hljs-number">0</span>  <span class="hljs-comment"># 发生异常</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_3</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(worker_1())<br>    task_2 = asyncio.create_task(worker_2())<br>    task_3 = asyncio.create_task(worker_3())<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    task_3.cancel()  <span class="hljs-comment"># 取消任务</span><br><br>    res = <span class="hljs-keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 输出所有task的执行结果（包括返回值、程序异常）</span><br><br><br>ts = time.time()<br>asyncio.run(main())  <span class="hljs-comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), 3]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 2.02s</span><br></code></pre></td></tr></table></figure>

<p><strong>示例二：协程的并发分组运行</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>(<span class="hljs-params">tag</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&quot;</span>, tag)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;&quot;</span>, tag)<br>    <span class="hljs-keyword">return</span> tag<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    group1 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 1.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)])  <span class="hljs-comment"># 对任务进行高级别分组</span><br>    group2 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 2.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)])<br>    group3 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 3.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)])<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    group3.cancel()  <span class="hljs-comment"># 分组的任务可以通过调用Task.cancel()来取消</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(group1, group2, group3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(results)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<h4 id="单任务等待"><a href="#单任务等待" class="headerlink" title="单任务等待"></a>单任务等待</h4><ul>
<li><code>asyncio.wait_for(aw, timeout, *)</code><ul>
<li>等待 <em>aw</em> 可等待对象完成，在指定 timeout 秒数后超时。</li>
<li>如果 <em>aw</em> 是一个协程，它将自动被作为任务调度。</li>
<li>如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</li>
<li>如果发生超时，任务将取消并引发 <code>asyncio.TimeoutError</code>。</li>
<li>要避免任务取消，可以加上 <code>asyncio.shield()</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：单任务超时取消</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eternity</span>():</span><br>    <span class="hljs-comment"># Sleep for one hour</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Wait for at most 1 second</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="hljs-number">1.0</span>)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<h4 id="多任务等待"><a href="#多任务等待" class="headerlink" title="多任务等待"></a>多任务等待</h4><ul>
<li><p><code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code></p>
<ul>
<li><p>并发地运行 <em>aws</em>  可迭代对象中的所有可等待对象，并进入阻塞状态直到满足 <em>return_when</em> 所指定的条件。</p>
</li>
<li><p>返回两个 Task/Future 集合：<code>(done, pending)</code>。</p>
</li>
<li><p>此函数不会引发 <code>asyncio.TimeoutError</code>，当超时发生时，未完成的 Task/Future 将在指定秒数后被返回。</p>
</li>
<li><p><em>return_when</em> 指定此函数应在何时返回，它必须为以下常数之一：</p>
<table>
<thead>
<tr>
<th align="left">常数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FIRST_COMPLETED</code></td>
<td align="left">函数将在任意可等待对象结束或取消时返回</td>
</tr>
<tr>
<td align="left"><code>FIRST_EXCEPTION</code></td>
<td align="left">函数将在任意可等待对象因引发异常而结束时返回，当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code></td>
</tr>
<tr>
<td align="left"><code>ALL_COMPLETED</code></td>
<td align="left">函数将在 <strong>所有</strong> 可等待对象结束或取消时返回</td>
</tr>
</tbody></table>
</li>
<li><p>与 <code>wait_for()</code> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例：多任务超时取消</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">21</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t1 = asyncio.create_task(foo())<br>    t2 = asyncio.create_task(bar())<br><br>    done, pending = <span class="hljs-keyword">await</span> asyncio.wait([t1, t2], timeout=<span class="hljs-number">2.0</span>)<br><br>    <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">in</span> done:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s result is <span class="hljs-subst">&#123;t1.result()&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s status is <span class="hljs-subst">&#123;t1.done()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pending:<br>        p.cancel()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cancel task: <span class="hljs-subst">&#123;p.get_name()&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(asyncio.all_tasks())<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<blockquote>
<p>gather 和 wait 的区别：<code>asyncio.gather()</code> 和 <code>asyncio.wait()</code> 都可以并发执行多个协程对象或任务，但 <em>gather</em> 主要用于收集结果，它会返回一个列表，按照给定的顺序返回结果；而 <em>wait</em> 会返回一个元组（done, pending），分别表示 <em>已完成任务列表</em> 和 <em>未完成任务列表</em>，列表中的每个任务都是一个 <em>Task</em> 实例，可以通过 <code>task.result()</code> 获得协程返回值。此外，<em>wait</em> 可以指定函数的返回时机和超时时间，是比 <em>gather</em> 更低层级的调用方式。</p>
</blockquote>
<h4 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h4><ul>
<li><p><code>asyncio.current_task(loop=None)</code></p>
<ul>
<li>返回当前运行的 <em>Task</em> 实例，如果没有正在运行的任务则返回 <code>None</code>。</li>
<li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li>
</ul>
</li>
<li><p><code>asyncio.all_tasks(loop=None)</code></p>
<ul>
<li>返回事件循环所运行的未完成的 <em>Task</em> 实例的集合。</li>
<li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li>
</ul>
</li>
</ul>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html">流</a></h3><p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html">队列</a></h3><p>asyncio 队列被设计成与 <code>queue</code> 模块类似，专用于 <code>async/await</code> 代码，但它 <strong>不是线程安全</strong> 的。asyncio 的队列没有 <em>timeout</em> 形参，使用 <code>asyncio.wait_for()</code> 函数为队列添加超时操作。</p>
<p><strong>使用说明</strong></p>
<p>asyncio.queues 模块提供的类：</p>
<ul>
<li>Queue(maxsize=0, *)：先进先出队列</li>
<li>LifoQueue(maxsize=0, *)：后进先出队列</li>
<li>PriorityQueue(maxsize=0, *)：优先级队列</li>
</ul>
<p>asyncio.queues 模块提供的常用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">queue.qsize()  <span class="hljs-comment"># 返回队列的大小（准确值）</span><br>queue.empty()  <span class="hljs-comment"># 返回队列是否为空</span><br>queue.full()  <span class="hljs-comment"># 返回队列是否为满</span><br>queue.put(item)  <span class="hljs-comment"># coroutine方法，向队列中插入一个元素，如果队列为满则阻塞</span><br>queue.put_nowait(item)  <span class="hljs-comment"># 立即向队列中插入一个元素，如果队列为满则引发QueueFull异常</span><br>queue.get()  <span class="hljs-comment"># coroutine方法，从队列中获取一个元素并返回，如果队列为空则阻塞</span><br>queue.get_nowait()  <span class="hljs-comment"># 立即从队列中获取一个元素并返回，如果队列为空则引发QueueEmpty异常</span><br>queue.task_done()  <span class="hljs-comment"># 同标准queue模块</span><br>queue.join()  <span class="hljs-comment"># coroutine方法，阻塞至队列中所有的元素都被接收和处理完毕</span><br></code></pre></td></tr></table></figure>

<p><strong>示例：多个并发任务的工作量分配</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">name, queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># Get a &quot;work item&quot; out of the queue.</span><br>        sleep_for = <span class="hljs-keyword">await</span> queue.get()<br><br>        <span class="hljs-comment"># Sleep for the &quot;sleep_for&quot; seconds.</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(sleep_for)<br><br>        <span class="hljs-comment"># Notify the queue that the &quot;work item&quot; has been processed.</span><br>        queue.task_done()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> has slept for <span class="hljs-subst">&#123;sleep_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Create a queue that we will use to store our &quot;workload&quot;.</span><br>    queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># Generate random timings and put them into the queue.</span><br>    total_sleep_time = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        sleep_for = random.uniform(<span class="hljs-number">0.05</span>, <span class="hljs-number">1.0</span>)<br>        total_sleep_time += sleep_for<br>        queue.put_nowait(sleep_for)<br><br>    <span class="hljs-comment"># Create three worker tasks to process the queue concurrently.</span><br>    tasks = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        task = asyncio.create_task(worker(<span class="hljs-string">f&#x27;worker-<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>, queue))<br>        tasks.append(task)<br><br>    <span class="hljs-comment"># Wait until the queue is fully processed.</span><br>    started_at = time.monotonic()<br>    <span class="hljs-keyword">await</span> queue.join()<br>    total_slept_for = time.monotonic() - started_at<br><br>    <span class="hljs-comment"># Cancel our worker tasks.</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:<br>        task.cancel()<br>    <span class="hljs-comment"># Wait until all worker tasks are cancelled.</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;====&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;3 workers slept in parallel for <span class="hljs-subst">&#123;total_slept_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;total expected sleep time: <span class="hljs-subst">&#123;total_sleep_time:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<p><strong>queue.Queue &amp; asyncio.Queue</strong></p>
<p>queue.Queue 和 asyncio.Queue 都是支持多生产者、多消费者的队列，同样是基于 collections.deque 实现，他们都提供了 Queue、LifoQueue、PriorityQueue，所提供的接口也相同。</p>
<p>区别在于 queue.Queue 适用于多线程场景的通信，asyncio.Queue 适用于协程场景的通信。由于 asyncio 的加成，queue.Queue 下的阻塞接口在 asyncio.Queue 中则是以返回协程对象的方式执行，具体差异如下表：</p>
<p><img src="/img/Python/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html">同步原语</a></h3><p><strong>Semaphore</strong></p>
<p><code>asyncio.Semaphore(value=1)</code> 信号量对象，非线程安全。</p>
<p>信号量会管理一个内部计数器，该计数器会随每次 <code>acquire()</code> 调用递减并随每次 <code>release()</code>调用递增。计数器的值永远不会降到零以下；当 <code>acquire()</code> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <code>release()</code>。</p>
<p>使用 Semaphore 的推荐方式是通过 <code>async with</code> 语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">sem = asyncio.Semaphore(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>    <span class="hljs-comment"># work with shared resource</span><br><br>---------<br><span class="hljs-comment"># 上述代码等价于：</span><br><span class="hljs-keyword">await</span> sem.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># work with shared resource</span><br><span class="hljs-keyword">finally</span>:<br>    sem.release()<br></code></pre></td></tr></table></figure>

<p><strong>示例：协程使用 Semaphore 限制并发量</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">sem</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>        <span class="hljs-built_in">print</span>(asyncio.current_task())<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    tasks = []<br>    sem = asyncio.Semaphore(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 并发执行数为5</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 启动100个协程</span><br>        tasks.append(asyncio.create_task(hello(sem)))<br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html">子进程</a></h3><p>本节介绍了用于创建和管理子进程的高层级 async/await asyncio API。</p>
<h3 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#coroutines">复合语句</a></h3><p><strong>异步迭代器 async for</strong></p>
<p><code>async for</code> 语句允许方便地对异步可迭代对象进行迭代。</p>
<p><strong>异步上下文管理器 async with</strong></p>
<p><code>async with</code> 语句是一种上下文管理器，能够在其 <em>enter</em> 和 <em>exit</em> 方法中暂停执行。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：使用协程方法替换普通方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非协程版本</span><br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    time.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        crawl_page(url)<br><br><br>ts = time.time()<br>main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 10.03s</span><br><br>---------<br><span class="hljs-comment"># 协程版本</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">await</span> asyncio.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    tasks = [asyncio.create_task(crawl_page(url)) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]  <span class="hljs-comment"># 创建task</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:  <span class="hljs-comment"># 或把for循环替换为 await asyncio.gather(*tasks) 其中*tasks为解包列表</span><br>        <span class="hljs-keyword">await</span> task<br><br><br>ts = time.time()<br>asyncio.run(main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 4.01s</span><br></code></pre></td></tr></table></figure>

<p><strong>示例二：使用协程实现生产者-消费者模型</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        val = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; get a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        val = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">await</span> queue.put(val)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; put a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue = asyncio.Queue()<br><br>    consumer_1 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_1&#x27;</span>))<br>    consumer_2 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_2&#x27;</span>))<br><br>    producer_1 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_1&#x27;</span>))<br>    producer_2 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_2&#x27;</span>))<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 执行10s</span><br>    consumer_1.cancel()<br>    consumer_2.cancel()<br><br>    <span class="hljs-keyword">await</span> asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=<span class="hljs-literal">True</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html">事件循环</a></h3><p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p>
<p>应用开发者通常应当使用高层级的 asyncio 函数，例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p>
<p>以下低层级函数可被用于获取、设置或创建事件循环:</p>
<ul>
<li><p><code>asyncio.``get_running_loop</code>()</p>
<p>返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError"><code>RuntimeError</code></a>。 此函数只能由协程或回调来调用。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>asyncio.``get_event_loop</code>()</p>
<p>获取当前事件循环。如果当前 OS 线程没有设置当前事件循环，该 OS 线程为主线程，并且 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.set_event_loop"><code>set_event_loop()</code></a> 还没有被调用，则 asyncio 将创建一个新的事件循环并将其设为当前事件循环。由于此函数具有相当复杂的行为（特别是在使用了自定义事件循环策略的时候），更推荐在协程和回调中使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 函数而非 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_event_loop"><code>get_event_loop()</code></a>。应该考虑使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a> 函数而非使用低层级函数来手动创建和关闭事件循环。<em>3.10 版后已移除:</em> 如果没有正在运行的事件循环则会发出弃用警告。 在未来的 Python 发行版中，此函数将成为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 的别名。</p>
</li>
<li><p><code>asyncio.``set_event_loop</code>(<em>loop</em>)</p>
<p>将 <em>loop</em> 设置为当前 OS 线程的当前事件循环。</p>
</li>
<li><p><code>asyncio.``new_event_loop</code>()</p>
<p>创建一个新的事件循环。</p>
</li>
</ul>
<h2 id="aiohttp-库"><a href="#aiohttp-库" class="headerlink" title="aiohttp 库"></a><a target="_blank" rel="noopener" href="https://docs.aiohttp.org/en/stable/index.html">aiohttp 库</a></h2><p>基于 asyncio 框架实现的异步 HTTP 客户端/服务器，用于替代 requests 库。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：简单使用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># client</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">import</span> aiohttp<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Status: <span class="hljs-subst">&#123;response.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Content-type: <span class="hljs-subst">&#123;response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>]&#125;</span>&quot;</span>)<br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;html&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><br>---------<br><span class="hljs-comment"># server</span><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">request</span>):</span><br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&quot;Anonymous&quot;</span>)<br>    text = <span class="hljs-string">&quot;Hello, &quot;</span> + name<br>    <span class="hljs-keyword">return</span> web.Response(text=text)<br><br><br>app = web.Application()<br>app.add_routes([web.get(<span class="hljs-string">&#x27;/&#x27;</span>, handle), web.get(<span class="hljs-string">&#x27;/&#123;name&#125;&#x27;</span>, handle)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    web.run_app(app, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9643</span>)<br></code></pre></td></tr></table></figure>

<p><strong>示例二：ClientSession 常用方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 传递参数</span><br>    params_list = [<br>        &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;,  <span class="hljs-comment"># 字典形式（标准格式，由程序编码）</span><br>        [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)],  <span class="hljs-comment"># 元组列表形式（为一个键指定多个值）</span><br>        <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span>  <span class="hljs-comment"># 字符串形式（不会自动编码）</span><br>    ]<br>    <span class="hljs-comment"># 自定义headers</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br>                      <span class="hljs-string">&quot;AppleWebKit/537.36 (KHTML, like Gecko) &quot;</span><br>                      <span class="hljs-string">&quot;Chrome/78.0.3904.108 Safari/537.36&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> params <span class="hljs-keyword">in</span> params_list:<br>        <span class="hljs-comment"># ClientSession.get() 有一个必选的url参数，它必须是一个str或yarl.URL对象</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, params=params, headers=headers) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;status: <span class="hljs-subst">&#123;r.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;headers: <span class="hljs-subst">&#123;r.headers&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的响应头信息</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;requestInfo: <span class="hljs-subst">&#123;r.request_info&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的请求信息，包括url、method、headers</span><br><br>            res = <span class="hljs-keyword">await</span> r.text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 使用response.read()读取二进制内容</span><br>            <span class="hljs-built_in">print</span>(res)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 提交数据</span><br>    data_list = [<br>        <span class="hljs-string">&#x27;test&#x27;</span>,  <span class="hljs-comment"># 纯文本格式，text/plain</span><br>        <span class="hljs-string">b&#x27;test&#x27;</span>,  <span class="hljs-comment"># 二进制流格式，application/octet-stream</span><br>        &#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;,  <span class="hljs-comment"># 表单格式，application/x-www-form-urlencoded</span><br>    ]<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_list:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=data) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br>    <span class="hljs-comment"># json格式，application/json</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cookie</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.json())  <span class="hljs-comment"># 返回json解码后的内容</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 自定义cookies</span><br>    cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br>    <span class="hljs-comment"># 在网络请求中，会话（session）是指同一用户与服务器进行交互的过程，aiohttp使用ClientSession来管理会话。</span><br>    <span class="hljs-comment"># 注意：不要为每个请求创建一个会话，最好是为每个应用程序创建一个会话，以执行所有请求。更复杂的情况可能需要对每个站点都有一个会话，例如一个用于Github，另一个用于Facebook。</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">await</span> get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> cookie(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>, session)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

<p><strong>示例三：aiohttp 限制并发连接数和超时时间</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession, ClientTimeout, TCPConnector, client_exceptions<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>():</span><br>    conn = TCPConnector(limit=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 限制同时连接数，默认为100，limit=0时无限制</span><br>    timeout = ClientTimeout(total=<span class="hljs-number">10</span>, connect=<span class="hljs-number">2</span>, sock_connect=<span class="hljs-number">2</span>, sock_read=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 默认total=5*60, connect=None, sock_connect=None, sock_read=None，为None或0时表示禁用特定的超时检查</span><br>    <span class="hljs-comment"># total：单次请求的最长时间（包括建立连接、发送请求和读取响应）</span><br>    <span class="hljs-comment"># connect：建立新连接或等待连接池中的空闲连接的最长时间</span><br>    <span class="hljs-comment"># sock_connect：建立新连接的最长时间（不是从池中给出的）</span><br>    <span class="hljs-comment"># sock_read：从服务端获取消息的最长时间</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(connector=conn, timeout=timeout) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://127.0.0.1:9643/test&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> response.text()&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">except</span> client_exceptions.ServerTimeoutError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Request timeout: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    st = time.perf_counter()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(get(), timeout=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 协程超时</span><br>    <span class="hljs-keyword">except</span> asyncio.exceptions.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coroutines timeout&#x27;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;time: <span class="hljs-subst">&#123;time.perf_counter() - st&#125;</span>s&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/">Python</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Python3/">Python3</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/Python%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Python 函数定义</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
                        <span class="hidden-mobile">Git 使用指南</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>Powered by</span> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>×</span> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量: 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数: 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
